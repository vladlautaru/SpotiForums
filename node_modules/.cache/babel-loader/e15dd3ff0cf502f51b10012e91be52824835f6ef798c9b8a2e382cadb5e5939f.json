{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\nconst Errors = require('../misc/errors');\nconst State = {\n  Normal: 1 /* inside  query */,\n  String: 2 /* inside string */,\n  SlashStarComment: 3 /* inside slash-star comment */,\n  Escape: 4 /* found backslash */,\n  EOLComment: 5 /* # comment, or // comment, or -- comment */,\n  Backtick: 6 /* found backtick */,\n  Placeholder: 7 /* found placeholder */\n};\nconst SLASH_BYTE = '/'.charCodeAt(0);\nconst STAR_BYTE = '*'.charCodeAt(0);\nconst BACKSLASH_BYTE = '\\\\'.charCodeAt(0);\nconst HASH_BYTE = '#'.charCodeAt(0);\nconst MINUS_BYTE = '-'.charCodeAt(0);\nconst LINE_FEED_BYTE = '\\n'.charCodeAt(0);\nconst DBL_QUOTE_BYTE = '\"'.charCodeAt(0);\nconst QUOTE_BYTE = \"'\".charCodeAt(0);\nconst RADICAL_BYTE = '`'.charCodeAt(0);\nconst QUESTION_MARK_BYTE = '?'.charCodeAt(0);\nconst COLON_BYTE = ':'.charCodeAt(0);\nconst SEMICOLON_BYTE = ';'.charCodeAt(0);\n\n/**\n * Set question mark position (question mark).\n * Question mark in comment are not taken in account\n *\n * @returns {Array} question mark position\n */\nmodule.exports.splitQuery = function (query) {\n  let paramPositions = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    if (state === State.Escape && !(query[i] === QUOTE_BYTE && singleQuotes || query[i] === DBL_QUOTE_BYTE && !singleQuotes)) {\n      state = State.String;\n      lastChar = query[i];\n      continue;\n    }\n    switch (query[i]) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i, ++i);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = query[i];\n  }\n  return paramPositions;\n};\n\n/**\n * Split query according to parameters using placeholder.\n *\n * @param query           query bytes\n * @param info            connection information\n * @param initialValues   placeholder object\n * @param displaySql      display sql function\n * @returns {{paramPositions: Array, values: Array}}\n */\nmodule.exports.splitQueryPlaceholder = function (query, info, initialValues, displaySql) {\n  let paramPositions = [];\n  let values = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  let car;\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    car = query[i];\n    if (state === State.Escape && !(car === QUOTE_BYTE && singleQuotes || car === DBL_QUOTE_BYTE && !singleQuotes)) {\n      state = State.String;\n      lastChar = car;\n      continue;\n    }\n    switch (car) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i);\n          paramPositions.push(++i);\n        }\n        break;\n      case COLON_BYTE:\n        if (state === State.Normal) {\n          let j = 1;\n          while (i + j < len && query[i + j] >= '0'.charCodeAt(0) && query[i + j] <= '9'.charCodeAt(0) || query[i + j] >= 'A'.charCodeAt(0) && query[i + j] <= 'Z'.charCodeAt(0) || query[i + j] >= 'a'.charCodeAt(0) && query[i + j] <= 'z'.charCodeAt(0) || query[i + j] === '-'.charCodeAt(0) || query[i + j] === '_'.charCodeAt(0)) {\n            j++;\n          }\n          paramPositions.push(i, i + j);\n          const placeholderName = query.toString('utf8', i + 1, i + j);\n          i += j;\n          const val = initialValues[placeholderName];\n          if (val === undefined) {\n            throw Errors.createError(`Placeholder '${placeholderName}' is not defined`, Errors.ER_PLACEHOLDER_UNDEFINED, info, 'HY000', displaySql.call());\n          }\n          values.push(val);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = car;\n  }\n  return {\n    paramPositions: paramPositions,\n    values: values\n  };\n};\nmodule.exports.searchPlaceholder = function (sql) {\n  let sqlPlaceHolder = '';\n  let placeHolderIndex = [];\n  let state = State.Normal;\n  let lastChar = '\\0';\n  let singleQuotes = false;\n  let lastParameterPosition = 0;\n  let idx = 0;\n  let car = sql.charAt(idx++);\n  let placeholderName;\n  while (car !== '') {\n    if (state === State.Escape && !(car === \"'\" && singleQuotes || car === '\"' && !singleQuotes)) {\n      state = State.String;\n      lastChar = car;\n      car = sql.charAt(idx++);\n      continue;\n    }\n    switch (car) {\n      case '*':\n        if (state === State.Normal && lastChar === '/') state = State.SlashStarComment;\n        break;\n      case '/':\n        if (state === State.SlashStarComment && lastChar === '*') state = State.Normal;\n        break;\n      case '#':\n        if (state === State.Normal) state = State.EOLComment;\n        break;\n      case '-':\n        if (state === State.Normal && lastChar === '-') {\n          state = State.EOLComment;\n        }\n        break;\n      case '\\n':\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case '\"':\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape && !singleQuotes) {\n          state = State.String;\n        }\n        break;\n      case \"'\":\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n          singleQuotes = false;\n        } else if (state === State.Escape && singleQuotes) {\n          state = State.String;\n        }\n        break;\n      case '\\\\':\n        if (state === State.String) state = State.Escape;\n        break;\n      case ':':\n        if (state === State.Normal) {\n          sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + '?';\n          placeholderName = '';\n          while ((car = sql.charAt(idx++)) !== '' && car >= '0' && car <= '9' || car >= 'A' && car <= 'Z' || car >= 'a' && car <= 'z' || car === '-' || car === '_') {\n            placeholderName += car;\n          }\n          idx--;\n          placeHolderIndex.push(placeholderName);\n          lastParameterPosition = idx;\n        }\n        break;\n      case '`':\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n    }\n    lastChar = car;\n    car = sql.charAt(idx++);\n  }\n  if (lastParameterPosition === 0) {\n    sqlPlaceHolder = sql;\n  } else {\n    sqlPlaceHolder += sql.substring(lastParameterPosition);\n  }\n  return {\n    sql: sqlPlaceHolder,\n    placeHolderIndex: placeHolderIndex\n  };\n};\n\n/**\n * Ensure that filename requested by server corresponds to query\n * protocol : https://mariadb.com/kb/en/library/local_infile-packet/\n *\n * @param sql         query\n * @param parameters  parameters if any\n * @param fileName    server requested file\n * @returns {boolean} is filename corresponding to query\n */\nmodule.exports.validateFileName = function (sql, parameters, fileName) {\n  // in case of windows, file name in query are escaped\n  // so for example LOAD DATA LOCAL INFILE 'C:\\\\Temp\\\\myFile.txt' ...\n  // but server return 'C:\\Temp\\myFile.txt'\n  // so with regex escaped, must test LOAD DATA LOCAL INFILE 'C:\\\\\\\\Temp\\\\\\\\myFile.txt'\n  let queryValidator = new RegExp(\"^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+'\" + fileName.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace('.', '\\\\.') + \"'\", 'i');\n  if (queryValidator.test(sql)) return true;\n  if (parameters != null) {\n    queryValidator = new RegExp('^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+\\\\?', 'i');\n    if (queryValidator.test(sql) && parameters.length > 0) {\n      if (Array.isArray(parameters)) {\n        return parameters[0].toLowerCase() === fileName.toLowerCase();\n      }\n      return parameters.toLowerCase() === fileName.toLowerCase();\n    }\n  }\n  return false;\n};\n\n/**\n * Parse commands from buffer, returns queries separated by ';'\n * (last one is not parsed)\n *\n * @param bufState buffer\n * @returns {*[]} array of queries contained in buffer\n */\nmodule.exports.parseQueries = function (bufState) {\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let currByte;\n  let queries = [];\n  let singleQuotes = false;\n  for (let i = bufState.offset; i < bufState.end; i++) {\n    currByte = bufState.buffer[i];\n    if (state === State.Escape && !(currByte === QUOTE_BYTE && singleQuotes || currByte === DBL_QUOTE_BYTE && !singleQuotes)) {\n      state = State.String;\n      lastChar = currByte;\n      continue;\n    }\n    switch (currByte) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case SEMICOLON_BYTE:\n        if (state === State.Normal) {\n          queries.push(bufState.buffer.toString('utf8', bufState.offset, i));\n          bufState.offset = i + 1;\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = currByte;\n  }\n  return queries;\n};","map":{"version":3,"names":["Errors","require","State","Normal","String","SlashStarComment","Escape","EOLComment","Backtick","Placeholder","SLASH_BYTE","charCodeAt","STAR_BYTE","BACKSLASH_BYTE","HASH_BYTE","MINUS_BYTE","LINE_FEED_BYTE","DBL_QUOTE_BYTE","QUOTE_BYTE","RADICAL_BYTE","QUESTION_MARK_BYTE","COLON_BYTE","SEMICOLON_BYTE","module","exports","splitQuery","query","paramPositions","state","lastChar","singleQuotes","len","length","i","push","splitQueryPlaceholder","info","initialValues","displaySql","values","car","j","placeholderName","toString","val","undefined","createError","ER_PLACEHOLDER_UNDEFINED","call","searchPlaceholder","sql","sqlPlaceHolder","placeHolderIndex","lastParameterPosition","idx","charAt","substring","validateFileName","parameters","fileName","queryValidator","RegExp","replace","test","Array","isArray","toLowerCase","parseQueries","bufState","currByte","queries","offset","end","buffer"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/misc/parse.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\nconst Errors = require('../misc/errors');\n\nconst State = {\n  Normal: 1 /* inside  query */,\n  String: 2 /* inside string */,\n  SlashStarComment: 3 /* inside slash-star comment */,\n  Escape: 4 /* found backslash */,\n  EOLComment: 5 /* # comment, or // comment, or -- comment */,\n  Backtick: 6 /* found backtick */,\n  Placeholder: 7 /* found placeholder */\n};\n\nconst SLASH_BYTE = '/'.charCodeAt(0);\nconst STAR_BYTE = '*'.charCodeAt(0);\nconst BACKSLASH_BYTE = '\\\\'.charCodeAt(0);\nconst HASH_BYTE = '#'.charCodeAt(0);\nconst MINUS_BYTE = '-'.charCodeAt(0);\nconst LINE_FEED_BYTE = '\\n'.charCodeAt(0);\nconst DBL_QUOTE_BYTE = '\"'.charCodeAt(0);\nconst QUOTE_BYTE = \"'\".charCodeAt(0);\nconst RADICAL_BYTE = '`'.charCodeAt(0);\nconst QUESTION_MARK_BYTE = '?'.charCodeAt(0);\nconst COLON_BYTE = ':'.charCodeAt(0);\nconst SEMICOLON_BYTE = ';'.charCodeAt(0);\n\n/**\n * Set question mark position (question mark).\n * Question mark in comment are not taken in account\n *\n * @returns {Array} question mark position\n */\nmodule.exports.splitQuery = function (query) {\n  let paramPositions = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    if (\n      state === State.Escape &&\n      !((query[i] === QUOTE_BYTE && singleQuotes) || (query[i] === DBL_QUOTE_BYTE && !singleQuotes))\n    ) {\n      state = State.String;\n      lastChar = query[i];\n      continue;\n    }\n    switch (query[i]) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i, ++i);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = query[i];\n  }\n  return paramPositions;\n};\n\n/**\n * Split query according to parameters using placeholder.\n *\n * @param query           query bytes\n * @param info            connection information\n * @param initialValues   placeholder object\n * @param displaySql      display sql function\n * @returns {{paramPositions: Array, values: Array}}\n */\nmodule.exports.splitQueryPlaceholder = function (query, info, initialValues, displaySql) {\n  let paramPositions = [];\n  let values = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  let car;\n\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    car = query[i];\n    if (\n      state === State.Escape &&\n      !((car === QUOTE_BYTE && singleQuotes) || (car === DBL_QUOTE_BYTE && !singleQuotes))\n    ) {\n      state = State.String;\n      lastChar = car;\n      continue;\n    }\n    switch (car) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i);\n          paramPositions.push(++i);\n        }\n        break;\n      case COLON_BYTE:\n        if (state === State.Normal) {\n          let j = 1;\n\n          while (\n            (i + j < len && query[i + j] >= '0'.charCodeAt(0) && query[i + j] <= '9'.charCodeAt(0)) ||\n            (query[i + j] >= 'A'.charCodeAt(0) && query[i + j] <= 'Z'.charCodeAt(0)) ||\n            (query[i + j] >= 'a'.charCodeAt(0) && query[i + j] <= 'z'.charCodeAt(0)) ||\n            query[i + j] === '-'.charCodeAt(0) ||\n            query[i + j] === '_'.charCodeAt(0)\n          ) {\n            j++;\n          }\n\n          paramPositions.push(i, i + j);\n\n          const placeholderName = query.toString('utf8', i + 1, i + j);\n          i += j;\n\n          const val = initialValues[placeholderName];\n          if (val === undefined) {\n            throw Errors.createError(\n              `Placeholder '${placeholderName}' is not defined`,\n              Errors.ER_PLACEHOLDER_UNDEFINED,\n              info,\n              'HY000',\n              displaySql.call()\n            );\n          }\n          values.push(val);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = car;\n  }\n  return { paramPositions: paramPositions, values: values };\n};\n\nmodule.exports.searchPlaceholder = function (sql) {\n  let sqlPlaceHolder = '';\n  let placeHolderIndex = [];\n  let state = State.Normal;\n  let lastChar = '\\0';\n\n  let singleQuotes = false;\n  let lastParameterPosition = 0;\n\n  let idx = 0;\n  let car = sql.charAt(idx++);\n  let placeholderName;\n\n  while (car !== '') {\n    if (state === State.Escape && !((car === \"'\" && singleQuotes) || (car === '\"' && !singleQuotes))) {\n      state = State.String;\n      lastChar = car;\n      car = sql.charAt(idx++);\n      continue;\n    }\n\n    switch (car) {\n      case '*':\n        if (state === State.Normal && lastChar === '/') state = State.SlashStarComment;\n        break;\n\n      case '/':\n        if (state === State.SlashStarComment && lastChar === '*') state = State.Normal;\n        break;\n\n      case '#':\n        if (state === State.Normal) state = State.EOLComment;\n        break;\n\n      case '-':\n        if (state === State.Normal && lastChar === '-') {\n          state = State.EOLComment;\n        }\n        break;\n\n      case '\\n':\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case '\"':\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape && !singleQuotes) {\n          state = State.String;\n        }\n        break;\n\n      case \"'\":\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n          singleQuotes = false;\n        } else if (state === State.Escape && singleQuotes) {\n          state = State.String;\n        }\n        break;\n\n      case '\\\\':\n        if (state === State.String) state = State.Escape;\n        break;\n\n      case ':':\n        if (state === State.Normal) {\n          sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + '?';\n          placeholderName = '';\n          while (\n            ((car = sql.charAt(idx++)) !== '' && car >= '0' && car <= '9') ||\n            (car >= 'A' && car <= 'Z') ||\n            (car >= 'a' && car <= 'z') ||\n            car === '-' ||\n            car === '_'\n          ) {\n            placeholderName += car;\n          }\n          idx--;\n          placeHolderIndex.push(placeholderName);\n          lastParameterPosition = idx;\n        }\n        break;\n      case '`':\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n    }\n    lastChar = car;\n\n    car = sql.charAt(idx++);\n  }\n  if (lastParameterPosition === 0) {\n    sqlPlaceHolder = sql;\n  } else {\n    sqlPlaceHolder += sql.substring(lastParameterPosition);\n  }\n\n  return { sql: sqlPlaceHolder, placeHolderIndex: placeHolderIndex };\n};\n\n/**\n * Ensure that filename requested by server corresponds to query\n * protocol : https://mariadb.com/kb/en/library/local_infile-packet/\n *\n * @param sql         query\n * @param parameters  parameters if any\n * @param fileName    server requested file\n * @returns {boolean} is filename corresponding to query\n */\nmodule.exports.validateFileName = function (sql, parameters, fileName) {\n  // in case of windows, file name in query are escaped\n  // so for example LOAD DATA LOCAL INFILE 'C:\\\\Temp\\\\myFile.txt' ...\n  // but server return 'C:\\Temp\\myFile.txt'\n  // so with regex escaped, must test LOAD DATA LOCAL INFILE 'C:\\\\\\\\Temp\\\\\\\\myFile.txt'\n  let queryValidator = new RegExp(\n    \"^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+'\" +\n      fileName.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace('.', '\\\\.') +\n      \"'\",\n    'i'\n  );\n  if (queryValidator.test(sql)) return true;\n\n  if (parameters != null) {\n    queryValidator = new RegExp(\n      '^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+\\\\?',\n      'i'\n    );\n    if (queryValidator.test(sql) && parameters.length > 0) {\n      if (Array.isArray(parameters)) {\n        return parameters[0].toLowerCase() === fileName.toLowerCase();\n      }\n      return parameters.toLowerCase() === fileName.toLowerCase();\n    }\n  }\n  return false;\n};\n\n/**\n * Parse commands from buffer, returns queries separated by ';'\n * (last one is not parsed)\n *\n * @param bufState buffer\n * @returns {*[]} array of queries contained in buffer\n */\nmodule.exports.parseQueries = function (bufState) {\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let currByte;\n  let queries = [];\n  let singleQuotes = false;\n\n  for (let i = bufState.offset; i < bufState.end; i++) {\n    currByte = bufState.buffer[i];\n    if (\n      state === State.Escape &&\n      !((currByte === QUOTE_BYTE && singleQuotes) || (currByte === DBL_QUOTE_BYTE && !singleQuotes))\n    ) {\n      state = State.String;\n      lastChar = currByte;\n      continue;\n    }\n    switch (currByte) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case SEMICOLON_BYTE:\n        if (state === State.Normal) {\n          queries.push(bufState.buffer.toString('utf8', bufState.offset, i));\n          bufState.offset = i + 1;\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = currByte;\n  }\n  return queries;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst Queue = require('denque');\nconst Net = require('net');\nconst PacketInputStream = require('./io/packet-input-stream');\nconst PacketOutputStream = require('./io/packet-output-stream');\nconst CompressionInputStream = require('./io/compression-input-stream');\nconst CompressionOutputStream = require('./io/compression-output-stream');\nconst ServerStatus = require('./const/server-status');\nconst ConnectionInformation = require('./misc/connection-information');\nconst tls = require('tls');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\nconst Capabilities = require('./const/capabilities');\nconst ConnectionOptions = require('./config/connection-options');\n\n/*commands*/\nconst Authentication = require('./cmd/handshake/authentication');\nconst Quit = require('./cmd/quit');\nconst Ping = require('./cmd/ping');\nconst Reset = require('./cmd/reset');\nconst Query = require('./cmd/query');\nconst Prepare = require('./cmd/prepare');\nconst OkPacket = require('./cmd/class/ok-packet');\nconst Execute = require('./cmd/execute');\nconst ClosePrepare = require('./cmd/close-prepare');\nconst BatchBulk = require('./cmd/batch-bulk');\nconst ChangeUser = require('./cmd/change-user');\nconst {\n  Status\n} = require('./const/connection_status');\nconst CommandParameter = require('./command-parameter');\nconst LruPrepareCache = require('./lru-prepare-cache');\nconst fsPromises = require('fs').promises;\nconst Parse = require('./misc/parse');\nconst Collations = require('./const/collations');\nconst ConnOptions = require('./config/connection-options');\nconst convertFixedTime = function (tz, conn) {\n  if (tz === 'UTC' || tz === 'Etc/UTC' || tz === 'Z' || tz === 'Etc/GMT') {\n    return '+00:00';\n  } else if (tz.startsWith('Etc/GMT') || tz.startsWith('GMT')) {\n    let tzdiff;\n    let negate;\n\n    // strangely Etc/GMT+8 = GMT-08:00 = offset -8\n    if (tz.startsWith('Etc/GMT')) {\n      tzdiff = tz.substring(7);\n      negate = !tzdiff.startsWith('-');\n    } else {\n      tzdiff = tz.substring(3);\n      negate = tzdiff.startsWith('-');\n    }\n    let diff = parseInt(tzdiff.substring(1));\n    if (isNaN(diff)) {\n      throw Errors.createFatalError(`Automatic timezone setting fails. wrong Server timezone '${tz}' conversion to +/-HH:00 conversion.`, Errors.ER_WRONG_AUTO_TIMEZONE, conn.info);\n    }\n    return (negate ? '-' : '+') + (diff >= 10 ? diff : '0' + diff) + ':00';\n  }\n  return tz;\n};\nconst redirectUrlFormat = /(mariadb|mysql):\\/\\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)(\\/([^?]+)(\\?(.*))?)?$/;\n\n/**\n * New Connection instance.\n *\n * @param options    connection options\n * @returns Connection instance\n * @constructor\n * @fires Connection#connect\n * @fires Connection#end\n * @fires Connection#error\n *\n */\nclass Connection extends EventEmitter {\n  opts;\n  sendQueue = new Queue();\n  receiveQueue = new Queue();\n  waitingAuthenticationQueue = new Queue();\n  status = Status.NOT_CONNECTED;\n  socket = null;\n  timeout = null;\n  addCommand;\n  streamOut;\n  streamIn;\n  info;\n  prepareCache;\n  constructor(options) {\n    super();\n    this.opts = Object.assign(new EventEmitter(), options);\n    this.info = new ConnectionInformation(this.opts, this.redirect.bind(this));\n    this.prepareCache = this.opts.prepareCacheLength > 0 ? new LruPrepareCache(this.info, this.opts.prepareCacheLength) : null;\n    this.addCommand = this.addCommandQueue;\n    this.streamOut = new PacketOutputStream(this.opts, this.info);\n    this.streamIn = new PacketInputStream(this.unexpectedPacket.bind(this), this.receiveQueue, this.streamOut, this.opts, this.info);\n    this.on('close_prepare', this._closePrepare.bind(this));\n    this.escape = Utils.escape.bind(this, this.opts, this.info);\n    this.escapeId = Utils.escapeId.bind(this, this.opts, this.info);\n  }\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  /**\n   * Connect event\n   *\n   * @returns {Promise} promise\n   */\n  connect() {\n    const conn = this;\n    this.status = Status.CONNECTING;\n    const authenticationParam = new CommandParameter(null, null, this.opts, null);\n    return new Promise(function (resolve, reject) {\n      conn.connectRejectFct = reject;\n      conn.connectResolveFct = resolve;\n      // add a handshake to msg queue\n      const authentication = new Authentication(authenticationParam, conn.authSucceedHandler.bind(conn), conn.authFailHandler.bind(conn), conn.createSecureContext.bind(conn), conn.getSocket.bind(conn));\n      Error.captureStackTrace(authentication);\n      authentication.once('end', () => {\n        conn.receiveQueue.shift();\n        // conn.info.collation might not be initialized\n        // in case of handshake throwing error\n        if (!conn.opts.collation && conn.info.collation) {\n          conn.opts.emit('collation', conn.info.collation);\n        }\n        process.nextTick(conn.nextSendCmd.bind(conn));\n      });\n      conn.receiveQueue.push(authentication);\n      conn.streamInitSocket.call(conn);\n    });\n  }\n  executePromise(cmdParam, prepare, resolve, reject) {\n    const cmd = new Execute(resolve, this._logAndReject.bind(this, reject), this.opts, cmdParam, prepare);\n    this.addCommand(cmd);\n  }\n  batch(cmdParam) {\n    if (!cmdParam.sql) {\n      const err = Errors.createError('sql parameter is mandatory', Errors.ER_UNDEFINED_SQL, this.info, 'HY000', null, false, cmdParam.stack);\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      return Promise.reject(err);\n    }\n    if (!cmdParam.values) {\n      const err = Errors.createError('Batch must have values set', Errors.ER_BATCH_WITH_NO_VALUES, this.info, 'HY000', cmdParam.sql.length > this.opts.debugLen ? cmdParam.sql.substring(0, this.opts.debugLen) + '...' : cmdParam.sql, false, cmdParam.stack);\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      return Promise.reject(err);\n    }\n    return new Promise(this.prepare.bind(this, cmdParam)).then(prepare => {\n      const usePlaceHolder = cmdParam.opts && cmdParam.opts.namedPlaceholders || this.opts.namedPlaceholders;\n      let vals;\n      if (Array.isArray(cmdParam.values)) {\n        if (usePlaceHolder) {\n          vals = cmdParam.values;\n        } else if (Array.isArray(cmdParam.values[0])) {\n          vals = cmdParam.values;\n        } else if (prepare.parameterCount === 1) {\n          vals = [];\n          for (let i = 0; i < cmdParam.values.length; i++) {\n            vals.push([cmdParam.values[i]]);\n          }\n        } else {\n          vals = [cmdParam.values];\n        }\n      } else {\n        vals = [[cmdParam.values]];\n      }\n      cmdParam.values = vals;\n      let useBulk = this._canUseBulk(vals, cmdParam.opts);\n      if (useBulk) {\n        return new Promise(this.executeBulkPromise.bind(this, cmdParam, prepare, this.opts));\n      } else {\n        const executes = [];\n        const cmdOpt = Object.assign({}, this.opts, cmdParam.opts);\n        for (let i = 0; i < vals.length; i++) {\n          executes.push(prepare.execute(vals[i], cmdParam.opts, null, cmdParam.stack));\n        }\n        return Promise.all(executes).then(function (res) {\n          if (cmdParam.opts && cmdParam.opts.fullResult) {\n            return Promise.resolve(res);\n          } else {\n            // aggregate results\n            let firstResult = res[0];\n            if (cmdOpt.metaAsArray) firstResult = firstResult[0];\n            if (firstResult instanceof OkPacket) {\n              let affectedRows = 0;\n              const insertId = firstResult.insertId;\n              const warningStatus = firstResult.warningStatus;\n              if (cmdOpt.metaAsArray) {\n                for (let i = 0; i < res.length; i++) {\n                  affectedRows += res[i][0].affectedRows;\n                }\n                return Promise.resolve([new OkPacket(affectedRows, insertId, warningStatus), []]);\n              } else {\n                for (let i = 0; i < res.length; i++) {\n                  affectedRows += res[i].affectedRows;\n                }\n                return Promise.resolve(new OkPacket(affectedRows, insertId, warningStatus));\n              }\n            } else {\n              // results have result-set. example :'INSERT ... RETURNING'\n              // aggregate results\n              if (cmdOpt.metaAsArray) {\n                const rs = [];\n                res.forEach(row => {\n                  rs.push(...row[0]);\n                });\n                return Promise.resolve([rs, res[0][1]]);\n              } else {\n                const rs = [];\n                res.forEach(row => {\n                  rs.push(...row);\n                });\n                Object.defineProperty(rs, 'meta', {\n                  value: res[0].meta,\n                  writable: true,\n                  enumerable: this.opts.metaEnumerable\n                });\n                return Promise.resolve(rs);\n              }\n            }\n          }\n        }.bind(this)).finally(() => prepare.close());\n      }\n    });\n  }\n  executeBulkPromise(cmdParam, prepare, opts, resolve, reject) {\n    const cmd = new BatchBulk(res => {\n      prepare.close();\n      return resolve(res);\n    }, function (err) {\n      prepare.close();\n      if (opts.logger.error) opts.logger.error(err);\n      reject(err);\n    }, opts, prepare, cmdParam);\n    this.addCommand(cmd);\n  }\n\n  /**\n   * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout\n   * @param cmdParam command context\n   * @param resolve success function\n   * @param reject rejection function\n   */\n  ping(cmdParam, resolve, reject) {\n    if (cmdParam.opts && cmdParam.opts.timeout) {\n      if (cmdParam.opts.timeout < 0) {\n        const err = Errors.createError('Ping cannot have negative timeout value', Errors.ER_BAD_PARAMETER_VALUE, this.info, '0A000');\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        reject(err);\n        return;\n      }\n      let tOut = setTimeout(function () {\n        tOut = undefined;\n        const err = Errors.createFatalError('Ping timeout', Errors.ER_PING_TIMEOUT, this.info, '0A000');\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        // close connection\n        this.addCommand = this.addCommandDisabled;\n        clearTimeout(this.timeout);\n        if (this.status !== Status.CLOSING && this.status !== Status.CLOSED) {\n          this.sendQueue.clear();\n          this.status = Status.CLOSED;\n          this.socket.destroy();\n        }\n        this.clear();\n        reject(err);\n      }.bind(this), cmdParam.opts.timeout);\n      this.addCommand(new Ping(cmdParam, () => {\n        if (tOut) {\n          clearTimeout(tOut);\n          resolve();\n        }\n      }, err => {\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        clearTimeout(tOut);\n        reject(err);\n      }));\n      return;\n    }\n    this.addCommand(new Ping(cmdParam, resolve, reject));\n  }\n\n  /**\n   * Send a reset command that will\n   * - rollback any open transaction\n   * - reset transaction isolation level\n   * - reset session variables\n   * - delete user variables\n   * - remove temporary tables\n   * - remove all PREPARE statement\n   */\n  reset(cmdParam, resolve, reject) {\n    if (this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4) || !this.info.isMariaDB() && this.info.hasMinVersion(5, 7, 3)) {\n      const conn = this;\n      const resetCmd = new Reset(cmdParam, () => {\n        conn.prepareCache.reset();\n        let prom = Promise.resolve();\n        // re-execute init query / session query timeout\n        prom.then(conn.handleCharset.bind(conn)).then(conn.handleTimezone.bind(conn)).then(conn.executeInitQuery.bind(conn)).then(conn.executeSessionTimeout.bind(conn)).then(resolve).catch(reject);\n      }, reject);\n      this.addCommand(resetCmd);\n      return;\n    }\n    const err = new Error(`Reset command not permitted for server ${this.info.serverVersion.raw} (requires server MariaDB version 10.2.4+ or MySQL 5.7.3+)`);\n    err.stack = cmdParam.stack;\n    if (this.opts.logger.error) this.opts.logger.error(err);\n    reject(err);\n  }\n\n  /**\n   * Indicates the state of the connection as the driver knows it\n   * @returns {boolean}\n   */\n  isValid() {\n    return this.status === Status.CONNECTED;\n  }\n\n  /**\n   * Terminate connection gracefully.\n   */\n  end(cmdParam, resolve, reject) {\n    this.addCommand = this.addCommandDisabled;\n    clearTimeout(this.timeout);\n    if (this.status < Status.CLOSING && this.status !== Status.NOT_CONNECTED) {\n      this.status = Status.CLOSING;\n      const ended = () => {\n        this.status = Status.CLOSED;\n        this.socket.destroy();\n        this.socket.unref();\n        this.clear();\n        this.receiveQueue.clear();\n        resolve();\n      };\n      const quitCmd = new Quit(cmdParam, ended, ended);\n      this.sendQueue.push(quitCmd);\n      this.receiveQueue.push(quitCmd);\n      if (this.sendQueue.length === 1) {\n        process.nextTick(this.nextSendCmd.bind(this));\n      }\n    } else resolve();\n  }\n\n  /**\n   * Force connection termination by closing the underlying socket and killing server process if any.\n   */\n  destroy() {\n    this.addCommand = this.addCommandDisabled;\n    clearTimeout(this.timeout);\n    if (this.status < Status.CLOSING) {\n      this.status = Status.CLOSING;\n      this.sendQueue.clear();\n      if (this.receiveQueue.length > 0) {\n        //socket is closed, but server may still be processing a huge select\n        //only possibility is to kill process by another thread\n        //TODO reuse a pool connection to avoid connection creation\n        const self = this;\n\n        // relying on IP in place of DNS to ensure using same server\n        const remoteAddress = this.socket.remoteAddress;\n        const connOption = remoteAddress ? Object.assign({}, this.opts, {\n          host: remoteAddress\n        }) : this.opts;\n        const killCon = new Connection(connOption);\n        killCon.connect().then(() => {\n          //*************************************************\n          //kill connection\n          //*************************************************\n          new Promise(killCon.query.bind(killCon, {\n            sql: `KILL ${self.info.threadId}`\n          })).finally(err => {\n            const destroyError = Errors.createFatalError('Connection destroyed, command was killed', Errors.ER_CMD_NOT_EXECUTED_DESTROYED, self.info);\n            if (self.opts.logger.error) self.opts.logger.error(destroyError);\n            self.socketErrorDispatchToQueries(destroyError);\n            if (self.socket) {\n              const sok = self.socket;\n              process.nextTick(() => {\n                sok.destroy();\n              });\n            }\n            self.status = Status.CLOSED;\n            self.clear();\n            new Promise(killCon.end.bind(killCon)).catch(() => {});\n          });\n        }).catch(() => {\n          //*************************************************\n          //failing to create a kill connection, end normally\n          //*************************************************\n          const ended = () => {\n            let sock = self.socket;\n            self.clear();\n            self.status = Status.CLOSED;\n            sock.destroy();\n            self.receiveQueue.clear();\n          };\n          const quitCmd = new Quit(ended, ended);\n          self.sendQueue.push(quitCmd);\n          self.receiveQueue.push(quitCmd);\n          if (self.sendQueue.length === 1) {\n            process.nextTick(self.nextSendCmd.bind(self));\n          }\n        });\n      } else {\n        this.status = Status.CLOSED;\n        this.socket.destroy();\n        this.clear();\n      }\n    }\n  }\n  pause() {\n    this.socket.pause();\n  }\n  resume() {\n    this.socket.resume();\n  }\n  format(sql, values) {\n    const err = Errors.createError('\"Connection.format intentionally not implemented. please use Connection.query(sql, values), it will be more secure and faster', Errors.ER_NOT_IMPLEMENTED_FORMAT, this.info, '0A000');\n    if (this.opts.logger.error) this.opts.logger.error(err);\n    throw err;\n  }\n\n  //*****************************************************************\n  // additional public methods\n  //*****************************************************************\n\n  /**\n   * return current connected server version information.\n   *\n   * @returns {*}\n   */\n  serverVersion() {\n    if (!this.info.serverVersion) {\n      const err = new Error('cannot know if server information until connection is established');\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      throw err;\n    }\n    return this.info.serverVersion.raw;\n  }\n\n  /**\n   * Change option \"debug\" during connection.\n   * @param val   debug value\n   */\n  debug(val) {\n    if (typeof val === 'boolean') {\n      if (val && !this.opts.logger.network) this.opts.logger.network = console.log;\n    } else if (typeof val === 'function') {\n      this.opts.logger.network = val;\n    }\n    this.opts.emit('debug', val);\n  }\n  debugCompress(val) {\n    if (val) {\n      if (typeof val === 'boolean') {\n        this.opts.debugCompress = val;\n        if (val && !this.opts.logger.network) this.opts.logger.network = console.log;\n      } else if (typeof val === 'function') {\n        this.opts.debugCompress = true;\n        this.opts.logger.network = val;\n      }\n    } else this.opts.debugCompress = false;\n  }\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  get __tests() {\n    return new TestMethods(this.info.collation, this.socket);\n  }\n\n  //*****************************************************************\n  // internal methods\n  //*****************************************************************\n\n  /**\n   * Use multiple COM_STMT_EXECUTE or COM_STMT_BULK_EXECUTE\n   *\n   * @param values current batch values\n   * @param _options batch option\n   * @return {boolean} indicating if can use bulk command\n   */\n  _canUseBulk(values, _options) {\n    if (_options && _options.fullResult) return false;\n    // not using info.isMariaDB() directly in case of callback use,\n    // without connection being completely finished.\n    const bulkEnable = _options === undefined || _options === null ? this.opts.bulk : _options.bulk !== undefined && _options.bulk !== null ? _options.bulk : this.opts.bulk;\n    if (this.info.serverVersion && this.info.serverVersion.mariaDb && this.info.hasMinVersion(10, 2, 7) && bulkEnable && (this.info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) > 0n) {\n      //ensure that there is no stream object\n      if (values !== undefined) {\n        if (!this.opts.namedPlaceholders) {\n          //ensure that all parameters have same length\n          //single array is considered as an array of single element.\n          const paramLen = Array.isArray(values[0]) ? values[0].length : values[0] ? 1 : 0;\n          if (paramLen === 0) return false;\n          for (let r = 0; r < values.length; r++) {\n            let row = values[r];\n            if (!Array.isArray(row)) row = [row];\n            if (paramLen !== row.length) {\n              return false;\n            }\n            // streaming data not permitted\n            for (let j = 0; j < paramLen; j++) {\n              const val = row[j];\n              if (val != null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val.read === 'function') {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let r = 0; r < values.length; r++) {\n            let row = values[r];\n            const keys = Object.keys(row);\n            for (let j = 0; j < keys.length; j++) {\n              const val = row[keys[j]];\n              if (val != null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val.read === 'function') {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  executeSessionVariableQuery() {\n    if (this.opts.sessionVariables) {\n      const values = [];\n      let sessionQuery = 'set ';\n      let keys = Object.keys(this.opts.sessionVariables);\n      if (keys.length > 0) {\n        for (let k = 0; k < keys.length; ++k) {\n          sessionQuery += (k !== 0 ? ',' : '') + '@@' + keys[k].replace(/[^a-z0-9_]/gi, '') + '=?';\n          values.push(this.opts.sessionVariables[keys[k]]);\n        }\n        return new Promise(this.query.bind(this, new CommandParameter(sessionQuery, values))).catch(initialErr => {\n          const err = Errors.createFatalError(`Error setting session variable (value ${JSON.stringify(this.opts.sessionVariables)}). Error: ${initialErr.message}`, Errors.ER_SETTING_SESSION_ERROR, this.info, '08S01', sessionQuery);\n          if (this.opts.logger.error) this.opts.logger.error(err);\n          return Promise.reject(err);\n        });\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * set charset to charset/collation if set or utf8mb4 if not.\n   * @returns {Promise<void>}\n   * @private\n   */\n  handleCharset() {\n    if (this.opts.collation) {\n      // if index <= 255, skip command, since collation has already been set during handshake response.\n      if (this.opts.collation.index <= 255) return Promise.resolve();\n      const charset = this.opts.collation.charset === 'utf8' && this.opts.collation.maxLength === 4 ? 'utf8mb4' : this.opts.collation.charset;\n      return new Promise(this.query.bind(this, new CommandParameter(`SET NAMES ${charset} COLLATE ${this.opts.collation.name}`)));\n    }\n\n    // MXS-4635: server can some information directly on first Ok_Packet, like not truncated collation\n    // in this case, avoid useless SET NAMES utf8mb4 command\n    if (!this.opts.charset && this.info.collation && this.info.collation.charset === 'utf8' && this.info.collation.maxLength === 4) {\n      this.info.collation = Collations.fromCharset('utf8mb4');\n      return Promise.resolve();\n    }\n    const connCharset = this.opts.charset ? this.opts.charset : 'utf8mb4';\n    this.info.collation = Collations.fromCharset(connCharset);\n    return new Promise(this.query.bind(this, new CommandParameter(`SET NAMES ${connCharset}`)));\n  }\n\n  /**\n   * Asking server timezone if not set in case of 'auto'\n   * @returns {Promise<void>}\n   * @private\n   */\n  handleTimezone() {\n    const conn = this;\n    if (this.opts.timezone === 'local') this.opts.timezone = undefined;\n    if (this.opts.timezone === 'auto') {\n      return new Promise(this.query.bind(this, new CommandParameter('SELECT @@system_time_zone stz, @@time_zone tz'))).then(res => {\n        const serverTimezone = res[0].tz === 'SYSTEM' ? res[0].stz : res[0].tz;\n        const localTz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        if (serverTimezone === localTz || convertFixedTime(serverTimezone, conn) === convertFixedTime(localTz, conn)) {\n          //server timezone is identical to client tz, skipping setting\n          this.opts.timezone = localTz;\n          return Promise.resolve();\n        }\n        return this._setSessionTimezone(convertFixedTime(localTz, conn));\n      });\n    }\n    if (this.opts.timezone) {\n      return this._setSessionTimezone(convertFixedTime(this.opts.timezone, conn));\n    }\n    return Promise.resolve();\n  }\n  _setSessionTimezone(tz) {\n    return new Promise(this.query.bind(this, new CommandParameter('SET time_zone=?', [tz]))).catch(err => {\n      const er = Errors.createFatalError(`setting timezone '${tz}' fails on server.\\n look at https://mariadb.com/kb/en/mysql_tzinfo_to_sql/ to load IANA timezone. `, Errors.ER_WRONG_IANA_TIMEZONE, this.info);\n      if (this.opts.logger.error) this.opts.logger.error(er);\n      return Promise.reject(er);\n    });\n  }\n  checkServerVersion() {\n    if (!this.opts.forceVersionCheck) {\n      return Promise.resolve();\n    }\n    return new Promise(this.query.bind(this, new CommandParameter('SELECT @@VERSION AS v'))).then(function (res) {\n      this.info.serverVersion.raw = res[0].v;\n      this.info.serverVersion.mariaDb = this.info.serverVersion.raw.includes('MariaDB');\n      ConnectionInformation.parseVersionString(this.info);\n      return Promise.resolve();\n    }.bind(this));\n  }\n  executeInitQuery() {\n    if (this.opts.initSql) {\n      const initialArr = Array.isArray(this.opts.initSql) ? this.opts.initSql : [this.opts.initSql];\n      const initialPromises = [];\n      initialArr.forEach(sql => {\n        initialPromises.push(new Promise(this.query.bind(this, new CommandParameter(sql))));\n      });\n      return Promise.all(initialPromises).catch(initialErr => {\n        const err = Errors.createFatalError(`Error executing initial sql command: ${initialErr.message}`, Errors.ER_INITIAL_SQL_ERROR, this.info);\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        return Promise.reject(err);\n      });\n    }\n    return Promise.resolve();\n  }\n  executeSessionTimeout() {\n    if (this.opts.queryTimeout) {\n      if (this.info.isMariaDB() && this.info.hasMinVersion(10, 1, 2)) {\n        const query = `SET max_statement_time=${this.opts.queryTimeout / 1000}`;\n        new Promise(this.query.bind(this, new CommandParameter(query))).catch(function (initialErr) {\n          const err = Errors.createFatalError(`Error setting session queryTimeout: ${initialErr.message}`, Errors.ER_INITIAL_TIMEOUT_ERROR, this.info, '08S01', query);\n          if (this.opts.logger.error) this.opts.logger.error(err);\n          return Promise.reject(err);\n        }.bind(this));\n      } else {\n        const err = Errors.createError(`Can only use queryTimeout for MariaDB server after 10.1.1. queryTimeout value: ${this.opts.queryTimeout}`, Errors.ER_TIMEOUT_NOT_SUPPORTED, this.info, 'HY000', this.opts.queryTimeout);\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        return Promise.reject(err);\n      }\n    }\n    return Promise.resolve();\n  }\n  getSocket() {\n    return this.socket;\n  }\n\n  /**\n   * Initialize socket and associate events.\n   * @private\n   */\n  streamInitSocket() {\n    if (this.opts.connectTimeout) {\n      this.timeout = setTimeout(this.connectTimeoutReached.bind(this), this.opts.connectTimeout, Date.now());\n    }\n    if (this.opts.socketPath) {\n      this.socket = Net.connect(this.opts.socketPath);\n    } else if (this.opts.stream) {\n      if (typeof this.opts.stream === 'function') {\n        const tmpSocket = this.opts.stream(function (err, stream) {\n          if (err) {\n            this.authFailHandler(err);\n            return;\n          }\n          this.socket = stream ? stream : Net.connect(this.opts.port, this.opts.host);\n          this.socketInit();\n        }.bind(this));\n        if (tmpSocket) {\n          this.socket = tmpSocket;\n          this.socketInit();\n        }\n      } else {\n        this.authFailHandler(Errors.createError('stream option is not a function. stream must be a function with (error, callback) parameter', Errors.ER_BAD_PARAMETER_VALUE, this.info));\n      }\n      return;\n    } else {\n      this.socket = Net.connect(this.opts.port, this.opts.host);\n      this.socket.setNoDelay(true);\n    }\n    this.socketInit();\n  }\n  socketInit() {\n    this.socket.on('data', this.streamIn.onData.bind(this.streamIn));\n    this.socket.on('error', this.socketErrorHandler.bind(this));\n    this.socket.on('end', this.socketErrorHandler.bind(this));\n    this.socket.on('connect', function () {\n      if (this.status === Status.CONNECTING) {\n        this.status = Status.AUTHENTICATING;\n        this.socket.setTimeout(this.opts.socketTimeout, this.socketTimeoutReached.bind(this));\n        this.socket.setNoDelay(true);\n\n        // keep alive for socket. This won't reset server wait_timeout use pool option idleTimeout for that\n        if (this.opts.keepAliveDelay) {\n          this.socket.setKeepAlive(true, this.opts.keepAliveDelay);\n        }\n      }\n    }.bind(this));\n    this.socket.writeBuf = buf => this.socket.write(buf);\n    this.socket.flush = () => {};\n    this.streamOut.setStream(this.socket);\n  }\n\n  /**\n   * Authentication success result handler.\n   *\n   * @private\n   */\n  authSucceedHandler() {\n    //enable packet compression according to option\n    if (this.opts.compress) {\n      if (this.info.serverCapabilities & Capabilities.COMPRESS) {\n        this.streamOut.setStream(new CompressionOutputStream(this.socket, this.opts, this.info));\n        this.streamIn = new CompressionInputStream(this.streamIn, this.receiveQueue, this.opts, this.info);\n        this.socket.removeAllListeners('data');\n        this.socket.on('data', this.streamIn.onData.bind(this.streamIn));\n      } else if (this.opts.logger.error) {\n        this.opts.logger.error(Errors.createError(\"connection is configured to use packet compression, but the server doesn't have this capability\", Errors.ER_COMPRESSION_NOT_SUPPORTED, this.info));\n      }\n    }\n    this.addCommand = this.opts.pipelining ? this.addCommandEnablePipeline : this.addCommandEnable;\n    const conn = this;\n    this.status = Status.INIT_CMD;\n    this.executeSessionVariableQuery().then(conn.handleCharset.bind(conn)).then(this.handleTimezone.bind(this)).then(this.checkServerVersion.bind(this)).then(this.executeInitQuery.bind(this)).then(this.executeSessionTimeout.bind(this)).then(() => {\n      clearTimeout(this.timeout);\n      conn.status = Status.CONNECTED;\n      process.nextTick(conn.connectResolveFct, conn);\n      const commands = conn.waitingAuthenticationQueue.toArray();\n      commands.forEach(cmd => {\n        conn.addCommand(cmd);\n      });\n      conn.waitingAuthenticationQueue = null;\n      conn.connectRejectFct = null;\n      conn.connectResolveFct = null;\n    }).catch(err => {\n      if (!err.fatal) {\n        const res = () => {\n          conn.authFailHandler.call(conn, err);\n        };\n        conn.end(res, res);\n      } else {\n        conn.authFailHandler.call(conn, err);\n      }\n      return Promise.reject(err);\n    });\n  }\n\n  /**\n   * Authentication failed result handler.\n   *\n   * @private\n   */\n  authFailHandler(err) {\n    clearTimeout(this.timeout);\n    if (this.connectRejectFct) {\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      //remove handshake command\n      this.receiveQueue.shift();\n      this.fatalError(err, true);\n      process.nextTick(this.connectRejectFct, err);\n      this.connectRejectFct = null;\n    }\n  }\n\n  /**\n   * Create TLS socket and associate events.\n   *\n   * @param info current connection information\n   * @param callback  callback function when done\n   * @private\n   */\n  createSecureContext(info, callback) {\n    info.requireValidCert = this.opts.ssl === true || this.opts.ssl.rejectUnauthorized === undefined || this.opts.ssl.rejectUnauthorized === true;\n    const baseConf = {\n      servername: this.opts.host,\n      socket: this.socket,\n      rejectUnauthorized: false\n    };\n    const sslOption = this.opts.ssl === true ? baseConf : Object.assign({}, this.opts.ssl, baseConf);\n    try {\n      const secureSocket = tls.connect(sslOption, callback);\n      secureSocket.on('data', this.streamIn.onData.bind(this.streamIn));\n      secureSocket.on('error', this.socketErrorHandler.bind(this));\n      secureSocket.on('end', this.socketErrorHandler.bind(this));\n      secureSocket.writeBuf = buf => secureSocket.write(buf);\n      secureSocket.flush = () => {};\n      this.socket.removeAllListeners('data');\n      this.socket = secureSocket;\n      this.streamOut.setStream(secureSocket);\n    } catch (err) {\n      this.socketErrorHandler(err);\n    }\n  }\n\n  /**\n   * Handle packet when no packet is expected.\n   * (there can be an ERROR packet send by server/proxy to inform that connection is ending).\n   *\n   * @param packet  packet\n   * @private\n   */\n  unexpectedPacket(packet) {\n    if (packet && packet.peek() === 0xff) {\n      //can receive unexpected error packet from server/proxy\n      //to inform that connection is closed (usually by timeout)\n      let err = packet.readError(this.info);\n      if (err.fatal && this.status < Status.CLOSING) {\n        this.emit('error', err);\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        this.end(() => {}, () => {});\n      }\n    } else if (this.status < Status.CLOSING) {\n      const err = Errors.createFatalError(`receiving packet from server without active commands\\nconn:${this.info.threadId ? this.info.threadId : -1}(${packet.pos},${packet.end})\\n${Utils.log(this.opts, packet.buf, packet.pos, packet.end)}`, Errors.ER_UNEXPECTED_PACKET, this.info);\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      this.emit('error', err);\n      this.destroy();\n    }\n  }\n\n  /**\n   * Handle connection timeout.\n   *\n   * @private\n   */\n  connectTimeoutReached(initialConnectionTime) {\n    this.timeout = null;\n    const handshake = this.receiveQueue.peekFront();\n    const err = Errors.createFatalError(`Connection timeout: failed to create socket after ${Date.now() - initialConnectionTime}ms`, Errors.ER_CONNECTION_TIMEOUT, this.info, '08S01', null, handshake ? handshake.stack : null);\n    if (this.opts.logger.error) this.opts.logger.error(err);\n    this.authFailHandler(err);\n  }\n\n  /**\n   * Handle socket timeout.\n   *\n   * @private\n   */\n  socketTimeoutReached() {\n    const err = Errors.createFatalError('socket timeout', Errors.ER_SOCKET_TIMEOUT, this.info);\n    if (this.opts.logger.error) this.opts.logger.error(err);\n    this.fatalError(err, true);\n  }\n\n  /**\n   * Add command to waiting queue until authentication.\n   *\n   * @param cmd         command\n   * @private\n   */\n  addCommandQueue(cmd) {\n    this.waitingAuthenticationQueue.push(cmd);\n  }\n\n  /**\n   * Add command to command sending and receiving queue.\n   *\n   * @param cmd         command\n   * @private\n   */\n  addCommandEnable(cmd) {\n    cmd.once('end', this._sendNextCmdImmediate.bind(this));\n\n    //send immediately only if no current active receiver\n    if (this.sendQueue.isEmpty() && this.receiveQueue.isEmpty()) {\n      this.receiveQueue.push(cmd);\n      cmd.start(this.streamOut, this.opts, this.info);\n    } else {\n      this.receiveQueue.push(cmd);\n      this.sendQueue.push(cmd);\n    }\n  }\n\n  /**\n   * Add command to command sending and receiving queue using pipelining\n   *\n   * @param cmd         command\n   * @private\n   */\n  addCommandEnablePipeline(cmd) {\n    cmd.once('send_end', this._sendNextCmdImmediate.bind(this));\n    this.receiveQueue.push(cmd);\n    if (this.sendQueue.isEmpty()) {\n      cmd.start(this.streamOut, this.opts, this.info);\n      if (cmd.sending) {\n        this.sendQueue.push(cmd);\n        cmd.prependOnceListener('send_end', this.sendQueue.shift.bind(this.sendQueue));\n      }\n    } else {\n      this.sendQueue.push(cmd);\n    }\n  }\n\n  /**\n   * Replacing command when connection is closing or closed to send a proper error message.\n   *\n   * @param cmd         command\n   * @private\n   */\n  addCommandDisabled(cmd) {\n    const err = cmd.throwNewError('Cannot execute new commands: connection closed', true, this.info, '08S01', Errors.ER_CMD_CONNECTION_CLOSED);\n    if (this.opts.logger.error) this.opts.logger.error(err);\n  }\n\n  /**\n   * Handle socket error.\n   *\n   * @param err               socket error\n   * @private\n   */\n  socketErrorHandler(err) {\n    if (this.status >= Status.CLOSING) return;\n    if (this.socket) {\n      this.socket.writeBuf = () => {};\n      this.socket.flush = () => {};\n    }\n\n    //socket has been ended without error\n    if (!err) {\n      err = Errors.createFatalError('socket has unexpectedly been closed', Errors.ER_SOCKET_UNEXPECTED_CLOSE, this.info);\n    } else {\n      err.fatal = true;\n      err.sqlState = 'HY000';\n    }\n    switch (this.status) {\n      case Status.CONNECTING:\n      case Status.AUTHENTICATING:\n        const currentCmd = this.receiveQueue.peekFront();\n        if (currentCmd && currentCmd.stack && err) {\n          err.stack += '\\n From event:\\n' + currentCmd.stack.substring(currentCmd.stack.indexOf('\\n') + 1);\n        }\n        this.authFailHandler(err);\n        break;\n      default:\n        this.fatalError(err, false);\n    }\n  }\n\n  /**\n   * Fatal unexpected error : closing connection, and throw exception.\n   */\n  fatalError(err, avoidThrowError) {\n    if (this.status >= Status.CLOSING) {\n      this.socketErrorDispatchToQueries(err);\n      return;\n    }\n    const mustThrowError = this.status !== Status.CONNECTING;\n    this.status = Status.CLOSING;\n\n    //prevent executing new commands\n    this.addCommand = this.addCommandDisabled;\n    if (this.socket) {\n      this.socket.removeAllListeners('error');\n      this.socket.removeAllListeners('timeout');\n      this.socket.removeAllListeners('close');\n      this.socket.removeAllListeners('data');\n      if (!this.socket.destroyed) this.socket.destroy();\n      this.socket = undefined;\n    }\n    this.status = Status.CLOSED;\n    const errorThrownByCmd = this.socketErrorDispatchToQueries(err);\n    if (mustThrowError) {\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      if (this.listenerCount('error') > 0) {\n        this.emit('error', err);\n        this.emit('end');\n        this.clear();\n      } else {\n        this.emit('end');\n        this.clear();\n        //error will be thrown if no error listener and no command did throw the exception\n        if (!avoidThrowError && !errorThrownByCmd) throw err;\n      }\n    } else {\n      this.clear();\n    }\n  }\n\n  /**\n   * Dispatch fatal error to current running queries.\n   *\n   * @param err        the fatal error\n   * @return {boolean} return if error has been relayed to queries\n   */\n  socketErrorDispatchToQueries(err) {\n    let receiveCmd;\n    let errorThrownByCmd = false;\n    while (receiveCmd = this.receiveQueue.shift()) {\n      if (receiveCmd && receiveCmd.onPacketReceive) {\n        errorThrownByCmd = true;\n        setImmediate(receiveCmd.throwError.bind(receiveCmd, err, this.info));\n      }\n    }\n    return errorThrownByCmd;\n  }\n\n  /**\n   * Will send next command in queue if any.\n   *\n   * @private\n   */\n  nextSendCmd() {\n    let sendCmd;\n    if (sendCmd = this.sendQueue.shift()) {\n      if (sendCmd.sending) {\n        this.sendQueue.unshift(sendCmd);\n      } else {\n        sendCmd.start(this.streamOut, this.opts, this.info);\n        if (sendCmd.sending) {\n          this.sendQueue.unshift(sendCmd);\n          sendCmd.prependOnceListener('send_end', this.sendQueue.shift.bind(this.sendQueue));\n        }\n      }\n    }\n  }\n\n  /**\n   * Change transaction state.\n   *\n   * @param cmdParam command parameter\n   * @param resolve success function to call\n   * @param reject error function to call\n   * @private\n   */\n  changeTransaction(cmdParam, resolve, reject) {\n    //if command in progress, driver cannot rely on status and must execute query\n    if (this.status >= Status.CLOSING) {\n      const err = Errors.createFatalError('Cannot execute new commands: connection closed', Errors.ER_CMD_CONNECTION_CLOSED, this.info, '08S01', cmdParam.sql);\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      reject(err);\n      return;\n    }\n\n    //Command in progress => must execute query\n    //or if no command in progress, can rely on status to know if query is needed\n    if (this.receiveQueue.peekFront() || this.info.status & ServerStatus.STATUS_IN_TRANS) {\n      const cmd = new Query(resolve, err => {\n        if (this.opts.logger.error) this.opts.logger.error(err);\n        reject(err);\n      }, this.opts, cmdParam);\n      this.addCommand(cmd);\n    } else resolve();\n  }\n  changeUser(cmdParam, resolve, reject) {\n    if (!this.info.isMariaDB()) {\n      const err = Errors.createError('method changeUser not available for MySQL server due to Bug #83472', Errors.ER_MYSQL_CHANGE_USER_BUG, this.info, '0A000');\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      reject(err);\n      return;\n    }\n    if (this.status < Status.CLOSING) {\n      this.addCommand = this.addCommandEnable;\n    }\n    let conn = this;\n    if (cmdParam.opts && cmdParam.opts.collation && typeof cmdParam.opts.collation === 'string') {\n      const val = cmdParam.opts.collation.toUpperCase();\n      cmdParam.opts.collation = Collations.fromName(cmdParam.opts.collation.toUpperCase());\n      if (cmdParam.opts.collation === undefined) return reject(new RangeError(`Unknown collation '${val}'`));\n    }\n    this.addCommand(new ChangeUser(cmdParam, this.opts, res => {\n      if (conn.status < Status.CLOSING && conn.opts.pipelining) conn.addCommand = conn.addCommandEnablePipeline;\n      if (cmdParam.opts && cmdParam.opts.collation) conn.opts.collation = cmdParam.opts.collation;\n      conn.handleCharset().then(() => {\n        if (cmdParam.opts && cmdParam.opts.collation) {\n          conn.info.collation = cmdParam.opts.collation;\n          conn.opts.emit('collation', cmdParam.opts.collation);\n        }\n        resolve(res);\n      }).catch(err => {\n        const res = () => conn.authFailHandler.call(conn, err);\n        if (!err.fatal) {\n          conn.end(res, res);\n        } else {\n          res();\n        }\n        reject(err);\n      });\n    }, this.authFailHandler.bind(this, reject), this.getSocket.bind(this)));\n  }\n  query(cmdParam, resolve, reject) {\n    if (!cmdParam.sql) return reject(Errors.createError('sql parameter is mandatory', Errors.ER_UNDEFINED_SQL, this.info, 'HY000', null, false, cmdParam.stack));\n    const cmd = new Query(resolve, err => {\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      reject(err);\n    }, this.opts, cmdParam);\n    this.addCommand(cmd);\n  }\n  prepare(cmdParam, resolve, reject) {\n    if (!cmdParam.sql) return reject(Errors.createError('sql parameter is mandatory', Errors.ER_UNDEFINED_SQL, this.info, 'HY000'));\n    if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {\n      // no command in queue, database is then considered ok, and cache can be search right now\n      const cachedPrepare = this.prepareCache.get(cmdParam.sql);\n      if (cachedPrepare) {\n        return resolve(cachedPrepare);\n      }\n    }\n    const cmd = new Prepare(resolve, err => {\n      if (this.opts.logger.error) this.opts.logger.error(err);\n      reject(err);\n    }, this.opts, cmdParam, this);\n    this.addCommand(cmd);\n  }\n  prepareExecute(cmdParam) {\n    if (!cmdParam.sql) {\n      return Promise.reject(Errors.createError('sql parameter is mandatory', Errors.ER_UNDEFINED_SQL, this.info, 'HY000'));\n    }\n    if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {\n      // no command in queue, current database is known, so cache can be search right now\n      const cachedPrepare = this.prepareCache.get(cmdParam.sql);\n      if (cachedPrepare) {\n        return new Promise(this.executePromise.bind(this, cmdParam, cachedPrepare)).finally(() => cachedPrepare.close());\n      }\n    }\n\n    // permit pipelining PREPARE and EXECUTE if mariadb 10.2.4+ and has no streaming\n    const conn = this;\n    if (this.opts.pipelining && this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4)) {\n      let hasStreamingValue = false;\n      const vals = cmdParam.values ? Array.isArray(cmdParam.values) ? cmdParam.values : [cmdParam.values] : [];\n      for (let i = 0; i < vals.length; i++) {\n        const val = vals[i];\n        if (val != null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val.read === 'function') {\n          hasStreamingValue = true;\n        }\n      }\n      if (!hasStreamingValue) {\n        return new Promise((resolve, reject) => {\n          let nbExecute = 0;\n          const executeCommand = new Execute(res => {\n            if (nbExecute++ === 0) {\n              executeCommand.prepare.close();\n              resolve(res);\n            }\n          }, err => {\n            if (nbExecute++ === 0) {\n              if (conn.opts.logger.error) conn.opts.logger.error(err);\n              reject(err);\n              if (executeCommand.prepare) {\n                executeCommand.prepare.close();\n              }\n            }\n          }, conn.opts, cmdParam, null);\n          cmdParam.executeCommand = executeCommand;\n          const cmd = new Prepare(prep => {\n            if (nbExecute > 0) prep.close();\n          }, err => {\n            if (nbExecute++ === 0) {\n              if (conn.opts.logger.error) conn.opts.logger.error(err);\n              reject(err);\n            }\n          }, conn.opts, cmdParam, conn);\n          conn.addCommand(cmd);\n          conn.addCommand(executeCommand);\n        });\n      }\n    }\n    // execute PREPARE, then EXECUTE\n    return new Promise((resolve, reject) => {\n      const cmd = new Prepare(resolve, reject, this.opts, cmdParam, conn);\n      conn.addCommand(cmd);\n    }).then(prepare => {\n      return new Promise(function (resolve, reject) {\n        conn.executePromise.call(conn, cmdParam, prepare, resolve, reject);\n      }).finally(() => prepare.close());\n    }).catch(err => {\n      if (conn.opts.logger.error) conn.opts.logger.error(err);\n      throw err;\n    });\n  }\n  importFile(cmdParam, resolve, reject) {\n    const conn = this;\n    if (!cmdParam || !cmdParam.file) {\n      return reject(Errors.createError('SQL file parameter is mandatory', Errors.ER_MISSING_SQL_PARAMETER, conn.info, 'HY000', null, false, cmdParam.stack));\n    }\n    const prevAddCommand = this.addCommand.bind(conn);\n    this.waitingAuthenticationQueue = new Queue();\n    this.addCommand = this.addCommandQueue;\n    const tmpQuery = function (sql, resolve, reject) {\n      const cmd = new Query(resolve, err => {\n        if (conn.opts.logger.error) conn.opts.logger.error(err);\n        reject(err);\n      }, conn.opts, new CommandParameter(sql, null, {}));\n      prevAddCommand(cmd);\n    };\n    let prevDatabase = null;\n    return (cmdParam.skipDbCheck ? Promise.resolve() : new Promise(tmpQuery.bind(conn, 'SELECT DATABASE() as db'))).then(res => {\n      prevDatabase = res ? res[0].db : null;\n      if (cmdParam.skipDbCheck && !conn.opts.database || !cmdParam.skipDbCheck && !cmdParam.database && !prevDatabase) {\n        return reject(Errors.createError('Database parameter is not set and no database is selected', Errors.ER_MISSING_DATABASE_PARAMETER, conn.info, 'HY000', null, false, cmdParam.stack));\n      }\n      const searchDbPromise = cmdParam.database ? new Promise(tmpQuery.bind(conn, `USE \\`${cmdParam.database.replace(/`/gi, '``')}\\``)) : Promise.resolve();\n      return searchDbPromise.then(() => {\n        const endingFunction = () => {\n          if (conn.status < Status.CLOSING) {\n            conn.addCommand = conn.addCommandEnable.bind(conn);\n            if (conn.status < Status.CLOSING && conn.opts.pipelining) {\n              conn.addCommand = conn.addCommandEnablePipeline.bind(conn);\n            }\n            const commands = conn.waitingAuthenticationQueue.toArray();\n            commands.forEach(cmd => conn.addCommand(cmd));\n            conn.waitingAuthenticationQueue = null;\n          }\n        };\n        return fsPromises.open(cmdParam.file, 'r').then(async fd => {\n          const buf = {\n            buffer: Buffer.allocUnsafe(16384),\n            offset: 0,\n            end: 0\n          };\n          const queryPromises = [];\n          let cmdError = null;\n          while (!cmdError) {\n            try {\n              const res = await fd.read(buf.buffer, buf.end, buf.buffer.length - buf.end, null);\n              if (res.bytesRead === 0) {\n                // end of file reached.\n                fd.close().catch(() => {});\n                if (cmdError) {\n                  endingFunction();\n                  reject(cmdError);\n                  return;\n                }\n                await Promise.allSettled(queryPromises).then(() => {\n                  // reset connection to initial database if was set\n                  if (!cmdParam.skipDbCheck && prevDatabase && cmdParam.database && cmdParam.database !== prevDatabase) {\n                    return new Promise(tmpQuery.bind(conn, `USE \\`${prevDatabase.replace(/`/gi, '``')}\\``));\n                  }\n                  return Promise.resolve();\n                }).then(() => {\n                  endingFunction();\n                  if (cmdError) {\n                    reject(cmdError);\n                  }\n                  resolve();\n                }).catch(err => {\n                  endingFunction();\n                  reject(err);\n                });\n                return;\n              } else {\n                buf.end += res.bytesRead;\n                const queries = Parse.parseQueries(buf);\n                const queryIntermediatePromise = queries.flatMap(element => {\n                  return new Promise(tmpQuery.bind(conn, element)).catch(err => {\n                    cmdError = err;\n                  });\n                });\n                queryPromises.push(...queryIntermediatePromise);\n                if (buf.offset === buf.end) {\n                  buf.offset = 0;\n                  buf.end = 0;\n                } else {\n                  // ensure that buffer can at least read 8k bytes,\n                  // either by copying remaining data on used part or growing buffer\n                  if (buf.offset > 8192) {\n                    // reuse buffer, copying remaining data begin of buffer\n                    buf.buffer.copy(buf.buffer, 0, buf.offset, buf.end);\n                    buf.end -= buf.offset;\n                    buf.offset = 0;\n                  } else if (buf.buffer.length - buf.end < 8192) {\n                    // grow buffer\n                    const tmpBuf = Buffer.allocUnsafe(buf.buffer.length << 1);\n                    buf.buffer.copy(tmpBuf, 0, buf.offset, buf.end);\n                    buf.buffer = tmpBuf;\n                    buf.end -= buf.offset;\n                    buf.offset = 0;\n                  }\n                }\n              }\n            } catch (e) {\n              fd.close().catch(() => {});\n              endingFunction();\n              Promise.allSettled(queryPromises).catch(() => {});\n              return reject(Errors.createError(e.message, Errors.ER_SQL_FILE_ERROR, conn.info, 'HY000', null, false, cmdParam.stack));\n            }\n          }\n          if (cmdError) {\n            endingFunction();\n            reject(cmdError);\n          }\n        }).catch(err => {\n          endingFunction();\n          if (err.code === 'ENOENT') {\n            return reject(Errors.createError(`SQL file parameter '${cmdParam.file}' doesn't exists`, Errors.ER_MISSING_SQL_FILE, conn.info, 'HY000', null, false, cmdParam.stack));\n          }\n          return reject(Errors.createError(err.message, Errors.ER_SQL_FILE_ERROR, conn.info, 'HY000', null, false, cmdParam.stack));\n        });\n      });\n    });\n  }\n\n  /**\n   * Clearing connection variables when ending.\n   *\n   * @private\n   */\n  clear() {\n    this.sendQueue.clear();\n    this.opts.removeAllListeners();\n    this.streamOut = undefined;\n    this.socket = undefined;\n  }\n\n  /**\n   * Redirecting connection to server indicated value.\n   * @param value server host string\n   * @param resolve promise result when done\n   */\n  redirect(value, resolve) {\n    if (this.opts.permitRedirect && value) {\n      // redirect only if :\n      // * when pipelining, having received all waiting responses.\n      // * not in a transaction\n      if (this.receiveQueue.length <= 1 && (this.info.status & ServerStatus.STATUS_IN_TRANS) === 0) {\n        this.info.redirectRequest = null;\n        const matchResults = value.match(redirectUrlFormat);\n        if (!matchResults) {\n          if (this.opts.logger.error) this.opts.logger.error(new Error(`error parsing redirection string '${value}'. format must be 'mariadb/mysql://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`));\n          return resolve();\n        }\n        const options = {\n          host: matchResults[7] ? decodeURIComponent(matchResults[7]) : matchResults[6],\n          port: matchResults[9] ? parseInt(matchResults[9]) : 3306\n        };\n        if (options.host === this.opts.host && options.port === this.opts.port) {\n          // redirection to the same host, skip loop redirection\n          return resolve();\n        }\n\n        // actually only options accepted are user and password\n        // there might be additional possible options in the future\n        if (matchResults[3]) options.user = matchResults[3];\n        if (matchResults[5]) options.password = matchResults[5];\n        const redirectOpts = ConnectionOptions.parseOptionDataType(options);\n        const finalRedirectOptions = new ConnOptions(Object.assign({}, this.opts, redirectOpts));\n        const conn = new Connection(finalRedirectOptions);\n        conn.connect().then(async function () {\n          const cmdParam = new CommandParameter();\n          await new Promise(this.end.bind(this, cmdParam));\n          this.status = Status.CONNECTED;\n          this.info = conn.info;\n          this.opts = conn.opts;\n          this.socket = conn.socket;\n          if (this.prepareCache) this.prepareCache.reset();\n          this.streamOut = conn.streamOut;\n          this.streamIn = conn.streamIn;\n          resolve();\n        }.bind(this)).catch(function (e) {\n          if (this.opts.logger.error) {\n            const err = new Error(`fail to redirect to '${value}'`);\n            err.cause = e;\n            this.opts.logger.error(err);\n          }\n          resolve();\n        }.bind(this));\n      } else {\n        this.info.redirectRequest = value;\n        resolve();\n      }\n    } else {\n      this.info.redirectRequest = null;\n      resolve();\n    }\n  }\n  get threadId() {\n    return this.info ? this.info.threadId : null;\n  }\n  _sendNextCmdImmediate() {\n    if (!this.sendQueue.isEmpty()) {\n      setImmediate(this.nextSendCmd.bind(this));\n    }\n  }\n  _closePrepare(prepareResultPacket) {\n    this.addCommand(new ClosePrepare(new CommandParameter(null, null, null, null), () => {}, () => {}, prepareResultPacket));\n  }\n  _logAndReject(reject, err) {\n    if (this.opts.logger.error) this.opts.logger.error(err);\n    reject(err);\n  }\n}\nclass TestMethods {\n  #collation;\n  #socket;\n  constructor(collation, socket) {\n    this.#collation = collation;\n    this.#socket = socket;\n  }\n  getCollation() {\n    return this.#collation;\n  }\n  getSocket() {\n    return this.#socket;\n  }\n}\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}
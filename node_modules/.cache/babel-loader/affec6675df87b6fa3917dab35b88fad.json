{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Stream = require('./cmd/stream');\nconst CommandParameter = require('./command-parameter');\nconst Errors = require('./misc/errors');\n\n/**\n * New Connection instance.\n *\n * @param options    connection options\n * @returns Connection instance\n * @constructor\n * @fires Connection#connect\n * @fires Connection#end\n * @fires Connection#error\n *\n */\nclass ConnectionPromise {\n  conn;\n  constructor(conn) {\n    this.conn = conn;\n  }\n  get threadId() {\n    return this.conn.threadId;\n  }\n  get info() {\n    return this.conn.info;\n  }\n  get prepareCache() {\n    return this.conn.prepareCache;\n  }\n\n  /**\n   * Permit to change user during connection.\n   * All user variables will be reset, Prepare commands will be released.\n   * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!\n   *\n   * @param options   connection options\n   * @returns {Promise} promise\n   */\n  changeUser(options) {\n    const cmdParam = new CommandParameter(null, null, options);\n    if (this.conn.opts.trace) Error.captureStackTrace(cmdParam);\n    return new Promise(this.conn.changeUser.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Start transaction\n   *\n   * @returns {Promise} promise\n   */\n  beginTransaction() {\n    return this.query('START TRANSACTION');\n  }\n\n  /**\n   * Commit a transaction.\n   *\n   * @returns {Promise} command if commit was needed only\n   */\n  commit() {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, 'COMMIT');\n    return new Promise(this.conn.changeTransaction.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Roll back a transaction.\n   *\n   * @returns {Promise} promise\n   */\n  rollback() {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, 'ROLLBACK');\n    return new Promise(this.conn.changeTransaction.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Execute query using text protocol.\n   *\n   * @param sql     sql parameter Object can be used to supersede default option.\n   *                Object must then have sql property.\n   * @param values  object / array of placeholder values (not mandatory)\n   * @returns {Promise} promise\n   */\n  query(sql, values) {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, sql, values);\n    return new Promise(this.conn.query.bind(this.conn, cmdParam));\n  }\n  static _PARAM(options, sql, values) {\n    let _cmdOpt,\n      _sql = sql,\n      _values = values;\n    if (typeof sql === 'object') {\n      _cmdOpt = sql;\n      _sql = _cmdOpt.sql;\n      if (_cmdOpt.values) _values = _cmdOpt.values;\n    }\n    const cmdParam = new CommandParameter(_sql, _values, _cmdOpt);\n    if (options.trace) Error.captureStackTrace(cmdParam, ConnectionPromise._PARAM);\n    return cmdParam;\n  }\n  execute(sql, values) {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, sql, values);\n    return this.conn.prepareExecute(cmdParam);\n  }\n  static _EXECUTE_CMD(conn, cmdParam) {\n    return conn.prepareExecute(cmdParam);\n  }\n  prepare(sql) {\n    let _cmdOpt, _sql;\n    if (typeof sql === 'object') {\n      _cmdOpt = sql;\n      _sql = _cmdOpt.sql;\n    } else {\n      _sql = sql;\n    }\n    const cmdParam = new CommandParameter(_sql, null, _cmdOpt);\n    if (this.conn.opts.trace) Error.captureStackTrace(cmdParam);\n    return new Promise(this.conn.prepare.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Execute batch using text protocol.\n   *\n   * @param sql     sql parameter Object can be used to supersede default option.\n   *                Object must then have sql property.\n   * @param values  object / array of placeholder values\n   * @returns {Promise} promise\n   */\n  batch(sql, values) {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, sql, values);\n    return this.conn.batch(cmdParam);\n  }\n  static _BATCH_CMD(conn, cmdParam) {\n    return conn.batch(cmdParam);\n  }\n\n  /**\n   * Import sql file.\n   *\n   * @param opts JSON array with 2 possible fields: file and database\n   */\n  importFile(opts) {\n    if (!opts || !opts.file) {\n      return Promise.reject(Errors.createError('SQL file parameter is mandatory', Errors.ER_MISSING_SQL_PARAMETER, this.conn.info, 'HY000', null, false, null));\n    }\n    return new Promise(this.conn.importFile.bind(this.conn, {\n      file: opts.file,\n      database: opts.database\n    }));\n  }\n\n  /**\n   * Execute query returning a Readable Object that will emit columns/data/end/error events\n   * to permit streaming big result-set\n   *\n   * @param sql     sql parameter Object can be used to supersede default option.\n   *                Object must then have sql property.\n   * @param values  object / array of placeholder values (not mandatory)\n   * @returns {Readable}\n   */\n  queryStream(sql, values) {\n    const cmdParam = ConnectionPromise._PARAM(this.conn.opts, sql, values);\n    const cmd = new Stream(cmdParam, this.conn.opts, this.conn.socket);\n    if (this.conn.opts.logger.error) cmd.on('error', this.conn.opts.logger.error);\n    this.conn.addCommand(cmd);\n    return cmd.inStream;\n  }\n\n  /**\n   * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout\n   * @param timeout (optional) timeout value in ms. If reached, throw error and close connection\n   * @returns {Promise} promise\n   */\n  ping(timeout) {\n    const cmdParam = new CommandParameter(null, null, {\n      timeout: timeout\n    });\n    if (this.conn.opts.trace) Error.captureStackTrace(cmdParam);\n    return new Promise(this.conn.ping.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Send a reset command that will\n   * - rollback any open transaction\n   * - reset transaction isolation level\n   * - reset session variables\n   * - delete user variables\n   * - remove temporary tables\n   * - remove all PREPARE statement\n   *\n   * @returns {Promise} promise\n   */\n  reset() {\n    const cmdParam = new CommandParameter();\n    if (this.conn.opts.trace) Error.captureStackTrace(cmdParam);\n    return new Promise(this.conn.reset.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Indicates the state of the connection as the driver knows it\n   * @returns {boolean}\n   */\n  isValid() {\n    return this.conn.isValid();\n  }\n\n  /**\n   * Terminate connection gracefully.\n   *\n   * @returns {Promise} promise\n   */\n  end() {\n    const cmdParam = new CommandParameter();\n    if (this.conn.opts.trace) Error.captureStackTrace(cmdParam);\n    return new Promise(this.conn.end.bind(this.conn, cmdParam));\n  }\n\n  /**\n   * Alias for destroy.\n   */\n  close() {\n    this.destroy();\n  }\n\n  /**\n   * Force connection termination by closing the underlying socket and killing server process if any.\n   */\n  destroy() {\n    this.conn.destroy();\n  }\n  pause() {\n    this.conn.pause();\n  }\n  resume() {\n    this.conn.resume();\n  }\n  format(sql, values) {\n    this.conn.format(sql, values);\n  }\n\n  /**\n   * return current connected server version information.\n   *\n   * @returns {*}\n   */\n  serverVersion() {\n    return this.conn.serverVersion();\n  }\n\n  /**\n   * Change option \"debug\" during connection.\n   * @param val   debug value\n   */\n  debug(val) {\n    return this.conn.debug(val);\n  }\n  debugCompress(val) {\n    return this.conn.debugCompress(val);\n  }\n  escape(val) {\n    return this.conn.escape(val);\n  }\n  escapeId(val) {\n    return this.conn.escapeId(val);\n  }\n\n  //*****************************************************************\n  // EventEmitter proxy methods\n  //*****************************************************************\n\n  on(eventName, listener) {\n    this.conn.on.call(this.conn, eventName, listener);\n    return this;\n  }\n  off(eventName, listener) {\n    this.conn.off.call(this.conn, eventName, listener);\n    return this;\n  }\n  once(eventName, listener) {\n    this.conn.once.call(this.conn, eventName, listener);\n    return this;\n  }\n  listeners(eventName) {\n    return this.conn.listeners.call(this.conn, eventName);\n  }\n  addListener(eventName, listener) {\n    this.conn.addListener.call(this.conn, eventName, listener);\n    return this;\n  }\n  eventNames() {\n    return this.conn.eventNames.call(this.conn);\n  }\n  getMaxListeners() {\n    return this.conn.getMaxListeners.call(this.conn);\n  }\n  listenerCount(eventName, listener) {\n    return this.conn.listenerCount.call(this.conn, eventName, listener);\n  }\n  prependListener(eventName, listener) {\n    this.conn.prependListener.call(this.conn, eventName, listener);\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    this.conn.prependOnceListener.call(this.conn, eventName, listener);\n    return this;\n  }\n  removeAllListeners(eventName, listener) {\n    this.conn.removeAllListeners.call(this.conn, eventName, listener);\n    return this;\n  }\n  removeListener(eventName, listener) {\n    this.conn.removeListener.call(this.conn, eventName, listener);\n    return this;\n  }\n  setMaxListeners(n) {\n    this.conn.setMaxListeners.call(this.conn, n);\n    return this;\n  }\n  rawListeners(eventName) {\n    return this.conn.rawListeners.call(this.conn, eventName);\n  }\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  get __tests() {\n    return this.conn.__tests;\n  }\n}\nmodule.exports = ConnectionPromise;","map":null,"metadata":{},"sourceType":"script"}
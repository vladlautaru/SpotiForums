{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Iconv = require('iconv-lite');\nconst Utils = require('../misc/utils');\nconst Errors = require('../misc/errors');\nconst Collations = require('../const/collations');\nconst QUOTE = 0x27;\nconst DBL_QUOTE = 0x22;\nconst ZERO_BYTE = 0x00;\nconst SLASH = 0x5c;\n\n//increase by level to avoid buffer copy.\nconst SMALL_BUFFER_SIZE = 256;\nconst MEDIUM_BUFFER_SIZE = 16384; //16k\nconst LARGE_BUFFER_SIZE = 131072; //128k\nconst BIG_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777219; //16M + 4\nconst CHARS_GLOBAL_REGEXP = /[\\000\\032\"'\\\\\\n\\r\\t]/g;\n\n/**\n * MySQL packet builder.\n *\n * @param opts    options\n * @param info    connection info\n * @constructor\n */\nclass PacketOutputStream {\n  constructor(opts, info) {\n    this.opts = opts;\n    this.info = info;\n    this.pos = 4;\n    this.markPos = -1;\n    this.bufContainDataAfterMark = false;\n    this.cmdLength = 0;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.maxAllowedPacket = opts.maxAllowedPacket || 4194304;\n    this.maxPacketLength = Math.min(MAX_BUFFER_SIZE, this.maxAllowedPacket + 4);\n    this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));\n    this.changeDebug(this.opts.debug);\n    this.opts.on('collation', this.changeEncoding.bind(this));\n    this.opts.on('debug', this.changeDebug.bind(this));\n  }\n  changeEncoding(collation) {\n    this.encoding = collation.charset;\n    if (this.encoding === 'utf8') {\n      this.writeString = this.writeDefaultBufferString;\n      this.encodeString = this.encodeNodeString;\n      this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeString = this.writeDefaultBufferString;\n      this.encodeString = this.encodeNodeString;\n      this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    } else {\n      this.writeString = this.writeDefaultIconvString;\n      this.encodeString = this.encodeIconvString;\n      this.writeLengthEncodedString = this.writeDefaultIconvLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    }\n  }\n  changeDebug(debug) {\n    this.debug = debug;\n    this.flushBuffer = debug ? this.flushBufferDebug : this.flushBufferBasic;\n    this.fastFlush = debug ? this.fastFlushDebug : this.fastFlushBasic;\n  }\n  setStream(stream) {\n    this.stream = stream;\n  }\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (len + this.pos < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else {\n      newCapacity = MAX_BUFFER_SIZE;\n    }\n    if (len + this.pos > newCapacity) {\n      if (this.markPos !== -1) {\n        // buf is > 16M with mark.\n        // flush until mark, reset pos at beginning\n        this.flushBufferStopAtMark();\n        if (len + this.pos <= this.buf.length) {\n          return;\n        }\n        this.growBuffer(len);\n      }\n    }\n    let newBuf = Buffer.allocUnsafe(newCapacity);\n    this.buf.copy(newBuf, 0, 0, this.pos);\n    this.buf = newBuf;\n  }\n  mark() {\n    this.markPos = this.pos;\n  }\n  isMarked() {\n    return this.markPos !== -1;\n  }\n  hasFlushed() {\n    return this.cmd.sequenceNo !== -1;\n  }\n  bufIsDataAfterMark() {\n    return this.bufContainDataAfterMark;\n  }\n  bufIsAfterMaxPacketLength() {\n    return this.pos > this.maxPacketLength;\n  }\n\n  /**\n   * Reset mark flag and send bytes after mark flag.\n   *\n   * @return buffer after mark flag\n   */\n  resetMark() {\n    this.pos = this.markPos;\n    this.markPos = -1;\n    if (this.bufContainDataAfterMark) {\n      const data = Buffer.allocUnsafe(this.pos - 4);\n      this.buf.copy(data, 0, 4, this.pos);\n      this.cmd.sequenceNo = -1;\n      this.cmd.compressSequenceNo = -1;\n      this.bufContainDataAfterMark = false;\n      return data;\n    }\n    return null;\n  }\n\n  /**\n   * Send packet to socket.\n   *\n   * @throws IOException if socket error occur.\n   */\n  flush() {\n    this.flushBuffer(true, 0);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.cmd.sequenceNo = -1;\n    this.cmd.compressSequenceNo = -1;\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n  flushPacket() {\n    this.flushBuffer(false, 0);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n  startPacket(cmd) {\n    this.cmd = cmd;\n    this.pos = 4;\n  }\n  writeInt8(value) {\n    if (this.pos + 1 >= this.buf.length) {\n      if (this.pos >= MAX_BUFFER_SIZE && !this.bufContainDataAfterMark) {\n        //buffer is more than a Packet, must flushBuffer()\n        this.flushBuffer(false, 1);\n      } else this.growBuffer(1);\n    }\n    this.buf[this.pos++] = value;\n  }\n  writeInt16(value) {\n    if (this.pos + 2 >= this.buf.length) {\n      let b = Buffer.allocUnsafe(2);\n      b[0] = value;\n      b[1] = value >>> 8;\n      this.writeBuffer(b, 0, 2);\n      return;\n    }\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.pos += 2;\n  }\n  writeInt16AtPos(initPos) {\n    this.buf[initPos] = this.pos - initPos - 2;\n    this.buf[initPos + 1] = this.pos - initPos - 2 >> 8;\n  }\n  writeInt24(value) {\n    if (this.pos + 3 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(3);\n      arr[0] = value;\n      arr[1] = value >> 8;\n      arr[2] = value >> 16;\n      this.writeBuffer(arr, 0, 3);\n      return;\n    }\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.buf[this.pos + 2] = value >> 16;\n    this.pos += 3;\n  }\n  writeInt32(value) {\n    if (this.pos + 4 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(4);\n      arr.writeInt32LE(value, 0);\n      this.writeBuffer(arr, 0, 4);\n      return;\n    }\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.buf[this.pos + 2] = value >> 16;\n    this.buf[this.pos + 3] = value >> 24;\n    this.pos += 4;\n  }\n  writeBigInt(value) {\n    if (this.pos + 8 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(8);\n      arr.writeBigInt64LE(value, 0);\n      this.writeBuffer(arr, 0, 8);\n      return;\n    }\n    this.buf.writeBigInt64LE(value, this.pos);\n    this.pos += 8;\n  }\n  writeDouble(value) {\n    if (this.pos + 8 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(8);\n      arr.writeDoubleLE(value, 0);\n      this.writeBuffer(arr, 0, 8);\n      return;\n    }\n    this.buf.writeDoubleLE(value, this.pos);\n    this.pos += 8;\n  }\n  writeLengthCoded(len) {\n    if (len < 0xfb) {\n      this.writeInt8(len);\n      return;\n    }\n    if (len < 65536) {\n      //max length is len < 0xffff\n      this.writeInt8(0xfc);\n      this.writeInt16(len);\n    } else if (len < 16777216) {\n      this.writeInt8(0xfd);\n      this.writeInt24(len);\n    } else {\n      this.writeInt8(0xfe);\n      this.writeBigInt(BigInt(len));\n    }\n  }\n  writeBuffer(arr, off, len) {\n    if (len > this.buf.length - this.pos) {\n      if (this.buf.length !== MAX_BUFFER_SIZE) {\n        this.growBuffer(len);\n      }\n\n      //max buffer size\n      if (len > this.buf.length - this.pos) {\n        if (this.markPos !== -1) {\n          this.growBuffer(len);\n          if (this.markPos !== -1) {\n            this.flushBufferStopAtMark();\n          }\n        }\n        if (len > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          // fill buffer and flush until all data are snd\n          let remainingLen = len;\n          while (true) {\n            //filling buffer\n            let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n            remainingLen -= lenToFillBuffer;\n            off += lenToFillBuffer;\n            this.pos += lenToFillBuffer;\n            if (remainingLen === 0) return;\n            this.flushBuffer(false, remainingLen);\n          }\n        }\n      }\n    }\n\n    // node.js copy is fast only when copying big buffer.\n    // quick array copy is multiple time faster for small copy\n    if (len > 50) {\n      arr.copy(this.buf, this.pos, off, off + len);\n      this.pos += len;\n    } else {\n      for (let i = 0; i < len; i++) {\n        this.buf[this.pos++] = arr[off + i];\n      }\n    }\n  }\n\n  /**\n   * Write ascii string to socket (no escaping)\n   *\n   * @param str                string\n   */\n  writeStringAscii(str) {\n    let len = str.length;\n\n    //not enough space remaining\n    if (len >= this.buf.length - this.pos) {\n      let strBuf = Buffer.from(str, 'ascii');\n      this.writeBuffer(strBuf, 0, strBuf.length);\n      return;\n    }\n    for (let off = 0; off < len;) {\n      this.buf[this.pos++] = str.charCodeAt(off++);\n    }\n  }\n  writeLengthEncodedBuffer(buffer) {\n    const len = buffer.length;\n    this.writeLengthCoded(len);\n    this.writeBuffer(buffer, 0, len);\n  }\n  writeUtf8StringEscapeQuote(str) {\n    const charsLength = str.length;\n\n    //not enough space remaining\n    if (charsLength * 3 + 2 >= this.buf.length - this.pos) {\n      const arr = Buffer.from(str, 'utf8');\n      this.writeInt8(QUOTE);\n      this.writeBufferEscape(arr);\n      this.writeInt8(QUOTE);\n      return;\n    }\n\n    //create UTF-8 byte array\n    //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n    //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n    //so max size is 3 * charLength\n    //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n    // + 2 for the quotes for text protocol\n    let charsOffset = 0;\n    let currChar;\n    this.buf[this.pos++] = QUOTE;\n    //quick loop if only ASCII chars for faster escape\n    for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80; charsOffset++) {\n      if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n        this.buf[this.pos++] = SLASH;\n      }\n      this.buf[this.pos++] = currChar;\n    }\n\n    //if quick loop not finished\n    while (charsOffset < charsLength) {\n      currChar = str.charCodeAt(charsOffset++);\n      if (currChar < 0x80) {\n        if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n          this.buf[this.pos++] = SLASH;\n        }\n        this.buf[this.pos++] = currChar;\n      } else if (currChar < 0x800) {\n        this.buf[this.pos++] = 0xc0 | currChar >> 6;\n        this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n      } else if (currChar >= 0xd800 && currChar < 0xe000) {\n        //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n        if (currChar < 0xdc00) {\n          //is high surrogate\n          if (charsOffset + 1 > charsLength) {\n            this.buf[this.pos++] = 0x3f;\n          } else {\n            const nextChar = str.charCodeAt(charsOffset);\n            if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n              //is low surrogate\n              const surrogatePairs = (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n              this.buf[this.pos++] = 0xf0 | surrogatePairs >> 18;\n              this.buf[this.pos++] = 0x80 | surrogatePairs >> 12 & 0x3f;\n              this.buf[this.pos++] = 0x80 | surrogatePairs >> 6 & 0x3f;\n              this.buf[this.pos++] = 0x80 | surrogatePairs & 0x3f;\n              charsOffset++;\n            } else {\n              //must have low surrogate\n              this.buf[this.pos++] = 0x3f;\n            }\n          }\n        } else {\n          //low surrogate without high surrogate before\n          this.buf[this.pos++] = 0x3f;\n        }\n      } else {\n        this.buf[this.pos++] = 0xe0 | currChar >> 12;\n        this.buf[this.pos++] = 0x80 | currChar >> 6 & 0x3f;\n        this.buf[this.pos++] = 0x80 | currChar & 0x3f;\n      }\n    }\n    this.buf[this.pos++] = QUOTE;\n  }\n  encodeIconvString(str) {\n    return Iconv.encode(str, this.encoding);\n  }\n  encodeNodeString(str) {\n    return Buffer.from(str, this.encoding);\n  }\n  writeDefaultBufferString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    if (str.length * 3 < this.buf.length - this.pos) {\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return;\n    }\n\n    //checking real length\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    if (byteLength > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n  }\n  writeDefaultBufferLengthEncodedString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    //checking real length\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    this.writeLengthCoded(byteLength);\n    if (byteLength > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n  }\n  writeDefaultIconvString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    this.writeBuffer(buf, 0, buf.length);\n  }\n  writeDefaultIconvLengthEncodedString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    this.writeLengthCoded(buf.length);\n    this.writeBuffer(buf, 0, buf.length);\n  }\n\n  /**\n   * Parameters need to be properly escaped :\n   * following characters are to be escaped by \"\\\" :\n   * - \\0\n   * - \\\\\n   * - \\'\n   * - \\\"\n   * - \\032\n   * regex split part of string writing part, and escaping special char.\n   * Those chars are <= 7f meaning that this will work even with multibyte encoding\n   *\n   * @param str string to escape.\n   */\n  writeDefaultStringEscapeQuote(str) {\n    this.writeInt8(QUOTE);\n    let match;\n    let lastIndex = 0;\n    while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n      this.writeString(str.slice(lastIndex, match.index));\n      this.writeInt8(SLASH);\n      this.writeInt8(match[0].charCodeAt(0));\n      lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n    }\n    if (lastIndex === 0) {\n      // Nothing was escaped\n      this.writeString(str);\n      this.writeInt8(QUOTE);\n      return;\n    }\n    if (lastIndex < str.length) {\n      this.writeString(str.slice(lastIndex));\n    }\n    this.writeInt8(QUOTE);\n  }\n  writeBinaryDate(date) {\n    const year = date.getFullYear();\n    const mon = date.getMonth() + 1;\n    const day = date.getDate();\n    const hour = date.getHours();\n    const min = date.getMinutes();\n    const sec = date.getSeconds();\n    const ms = date.getMilliseconds();\n    let len = ms === 0 ? 7 : 11;\n    //not enough space remaining\n    if (len + 1 > this.buf.length - this.pos) {\n      let tmpBuf = Buffer.allocUnsafe(len + 1);\n      tmpBuf[0] = len;\n      tmpBuf[1] = year;\n      tmpBuf[2] = year >>> 8;\n      tmpBuf[3] = mon;\n      tmpBuf[4] = day;\n      tmpBuf[5] = hour;\n      tmpBuf[6] = min;\n      tmpBuf[7] = sec;\n      if (ms !== 0) {\n        const micro = ms * 1000;\n        tmpBuf[8] = micro;\n        tmpBuf[9] = micro >>> 8;\n        tmpBuf[10] = micro >>> 16;\n        tmpBuf[11] = micro >>> 24;\n      }\n      this.writeBuffer(tmpBuf, 0, len + 1);\n      return;\n    }\n    this.buf[this.pos] = len;\n    this.buf[this.pos + 1] = year;\n    this.buf[this.pos + 2] = year >>> 8;\n    this.buf[this.pos + 3] = mon;\n    this.buf[this.pos + 4] = day;\n    this.buf[this.pos + 5] = hour;\n    this.buf[this.pos + 6] = min;\n    this.buf[this.pos + 7] = sec;\n    if (ms !== 0) {\n      const micro = ms * 1000;\n      this.buf[this.pos + 8] = micro;\n      this.buf[this.pos + 9] = micro >>> 8;\n      this.buf[this.pos + 10] = micro >>> 16;\n      this.buf[this.pos + 11] = micro >>> 24;\n    }\n    this.pos += len + 1;\n  }\n  writeBufferEscape(val) {\n    let valLen = val.length;\n    if (valLen * 2 > this.buf.length - this.pos) {\n      //makes buffer bigger (up to 16M)\n      if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);\n\n      //data may still be bigger than buffer.\n      //must flush buffer when full (and reset position to 4)\n      if (valLen * 2 > this.buf.length - this.pos) {\n        //not enough space in buffer, will fill buffer\n        for (let i = 0; i < valLen; i++) {\n          switch (val[i]) {\n            case QUOTE:\n            case SLASH:\n            case DBL_QUOTE:\n            case ZERO_BYTE:\n              if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n              this.buf[this.pos++] = SLASH;\n            //add escape slash\n          }\n          if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n          this.buf[this.pos++] = val[i];\n        }\n        return;\n      }\n    }\n\n    //sure to have enough place to use buffer directly\n    for (let i = 0; i < valLen; i++) {\n      switch (val[i]) {\n        case QUOTE:\n        case SLASH:\n        case DBL_QUOTE:\n        case ZERO_BYTE:\n          this.buf[this.pos++] = SLASH;\n        //add escape slash\n      }\n      this.buf[this.pos++] = val[i];\n    }\n  }\n\n  /**\n   * Count query size. If query size is greater than max_allowed_packet and nothing has been already\n   * send, throw an exception to avoid having the connection closed.\n   *\n   * @param length additional length to query size\n   * @param info current connection information\n   * @throws Error if query has not to be sent.\n   */\n  checkMaxAllowedLength(length, info) {\n    if (this.cmdLength + length >= this.maxAllowedPacket) {\n      // launch exception only if no packet has been sent.\n      return Errors.createFatalError(`query size (${this.cmdLength + length}) is >= to max_allowed_packet (${this.maxAllowedPacket})`, Errors.ER_MAX_ALLOWED_PACKET, info);\n    }\n    return null;\n  }\n\n  /**\n   * Indicate if buffer contain any data.\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.pos <= 4;\n  }\n\n  /**\n   * Flush the internal buffer.\n   */\n  flushBufferDebug(commandEnd, remainingLen) {\n    if (this.pos > 4) {\n      this.buf[0] = this.pos - 4;\n      this.buf[1] = this.pos - 4 >>> 8;\n      this.buf[2] = this.pos - 4 >>> 16;\n      this.buf[3] = ++this.cmd.sequenceNo;\n      this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);\n      this.stream.flush(true, this.cmd);\n      this.cmdLength += this.pos - 4;\n      this.opts.logger.network(`==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name + '(0,' + this.pos + ')'}\\n${Utils.log(this.opts, this.buf, 0, this.pos)}`);\n      if (commandEnd && this.pos === MAX_BUFFER_SIZE) {\n        //if last packet fill the max size, must send an empty com to indicate that command end.\n        this.writeEmptyPacket();\n      }\n      this.buf = this.createBufferWithMinSize(remainingLen);\n      this.pos = 4;\n    }\n  }\n\n  /**\n   * Flush to last mark.\n   */\n  flushBufferStopAtMark() {\n    const end = this.pos;\n    this.pos = this.markPos;\n    const tmpBuf = Buffer.allocUnsafe(Math.max(SMALL_BUFFER_SIZE, end + 4 - this.pos));\n    this.buf.copy(tmpBuf, 4, this.markPos, end);\n    this.flushBuffer(true, end - this.pos);\n    this.cmdLength = 0;\n    this.buf = tmpBuf;\n    this.pos = 4 + end - this.markPos;\n    this.markPos = -1;\n    this.bufContainDataAfterMark = true;\n  }\n  flushBufferBasic(commandEnd, remainingLen) {\n    this.buf[0] = this.pos - 4;\n    this.buf[1] = this.pos - 4 >>> 8;\n    this.buf[2] = this.pos - 4 >>> 16;\n    this.buf[3] = ++this.cmd.sequenceNo;\n    this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);\n    this.stream.flush(true, this.cmd);\n    this.cmdLength += this.pos - 4;\n    if (commandEnd && this.pos === MAX_BUFFER_SIZE) {\n      //if last packet fill the max size, must send an empty com to indicate that command end.\n      this.writeEmptyPacket();\n    }\n    this.buf = this.createBufferWithMinSize(remainingLen);\n    this.pos = 4;\n  }\n  createBufferWithMinSize(remainingLen) {\n    let newCapacity;\n    if (remainingLen + 4 < SMALL_BUFFER_SIZE) {\n      newCapacity = SMALL_BUFFER_SIZE;\n    } else if (remainingLen + 4 < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (remainingLen + 4 < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (remainingLen + 4 < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else {\n      newCapacity = MAX_BUFFER_SIZE;\n    }\n    return Buffer.allocUnsafe(newCapacity);\n  }\n  fastFlushDebug(cmd, packet) {\n    this.stream.writeBuf(packet, cmd);\n    this.stream.flush(true, cmd);\n    this.cmdLength += packet.length;\n    this.opts.logger.network(`==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd.constructor.name + '(0,' + packet.length + ')'}\\n${Utils.log(this.opts, packet, 0, packet.length)}`);\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n  fastFlushBasic(cmd, packet) {\n    this.stream.writeBuf(packet, cmd);\n    this.stream.flush(true, cmd);\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n  writeEmptyPacket() {\n    const emptyBuf = Buffer.from([0x00, 0x00, 0x00, ++this.cmd.sequenceNo]);\n    if (this.debug) {\n      this.opts.logger.network(`==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name}(0,4)\\n${Utils.log(this.opts, emptyBuf, 0, 4)}`);\n    }\n    this.stream.writeBuf(emptyBuf, this.cmd);\n    this.stream.flush(true, this.cmd);\n    this.cmdLength = 0;\n  }\n}\nmodule.exports = PacketOutputStream;","map":{"version":3,"names":["Iconv","require","Utils","Errors","Collations","QUOTE","DBL_QUOTE","ZERO_BYTE","SLASH","SMALL_BUFFER_SIZE","MEDIUM_BUFFER_SIZE","LARGE_BUFFER_SIZE","BIG_BUFFER_SIZE","MAX_BUFFER_SIZE","CHARS_GLOBAL_REGEXP","PacketOutputStream","constructor","opts","info","pos","markPos","bufContainDataAfterMark","cmdLength","buf","Buffer","allocUnsafe","maxAllowedPacket","maxPacketLength","Math","min","changeEncoding","collation","fromIndex","changeDebug","debug","on","bind","encoding","charset","writeString","writeDefaultBufferString","encodeString","encodeNodeString","writeLengthEncodedString","writeDefaultBufferLengthEncodedString","writeStringEscapeQuote","writeUtf8StringEscapeQuote","isEncoding","writeDefaultStringEscapeQuote","writeDefaultIconvString","encodeIconvString","writeDefaultIconvLengthEncodedString","flushBuffer","flushBufferDebug","flushBufferBasic","fastFlush","fastFlushDebug","fastFlushBasic","setStream","stream","growBuffer","len","newCapacity","flushBufferStopAtMark","length","newBuf","copy","mark","isMarked","hasFlushed","cmd","sequenceNo","bufIsDataAfterMark","bufIsAfterMaxPacketLength","resetMark","data","compressSequenceNo","flush","flushPacket","startPacket","writeInt8","value","writeInt16","b","writeBuffer","writeInt16AtPos","initPos","writeInt24","arr","writeInt32","writeInt32LE","writeBigInt","writeBigInt64LE","writeDouble","writeDoubleLE","writeLengthCoded","BigInt","off","remainingLen","lenToFillBuffer","i","writeStringAscii","str","strBuf","from","charCodeAt","writeLengthEncodedBuffer","buffer","charsLength","writeBufferEscape","charsOffset","currChar","nextChar","surrogatePairs","encode","write","byteLength","match","lastIndex","exec","slice","index","writeBinaryDate","date","year","getFullYear","mon","getMonth","day","getDate","hour","getHours","getMinutes","sec","getSeconds","ms","getMilliseconds","tmpBuf","micro","val","valLen","checkMaxAllowedLength","createFatalError","ER_MAX_ALLOWED_PACKET","isEmpty","commandEnd","writeBuf","subarray","logger","network","threadId","name","log","writeEmptyPacket","createBufferWithMinSize","end","max","packet","emptyBuf","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/io/packet-output-stream.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Iconv = require('iconv-lite');\nconst Utils = require('../misc/utils');\nconst Errors = require('../misc/errors');\nconst Collations = require('../const/collations');\n\nconst QUOTE = 0x27;\nconst DBL_QUOTE = 0x22;\nconst ZERO_BYTE = 0x00;\nconst SLASH = 0x5c;\n\n//increase by level to avoid buffer copy.\nconst SMALL_BUFFER_SIZE = 256;\nconst MEDIUM_BUFFER_SIZE = 16384; //16k\nconst LARGE_BUFFER_SIZE = 131072; //128k\nconst BIG_BUFFER_SIZE = 1048576; //1M\nconst MAX_BUFFER_SIZE = 16777219; //16M + 4\nconst CHARS_GLOBAL_REGEXP = /[\\000\\032\"'\\\\\\n\\r\\t]/g;\n\n/**\n * MySQL packet builder.\n *\n * @param opts    options\n * @param info    connection info\n * @constructor\n */\nclass PacketOutputStream {\n  constructor(opts, info) {\n    this.opts = opts;\n    this.info = info;\n    this.pos = 4;\n    this.markPos = -1;\n    this.bufContainDataAfterMark = false;\n    this.cmdLength = 0;\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.maxAllowedPacket = opts.maxAllowedPacket || 4194304;\n    this.maxPacketLength = Math.min(MAX_BUFFER_SIZE, this.maxAllowedPacket + 4);\n\n    this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));\n    this.changeDebug(this.opts.debug);\n\n    this.opts.on('collation', this.changeEncoding.bind(this));\n    this.opts.on('debug', this.changeDebug.bind(this));\n  }\n\n  changeEncoding(collation) {\n    this.encoding = collation.charset;\n    if (this.encoding === 'utf8') {\n      this.writeString = this.writeDefaultBufferString;\n      this.encodeString = this.encodeNodeString;\n      this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;\n    } else if (Buffer.isEncoding(this.encoding)) {\n      this.writeString = this.writeDefaultBufferString;\n      this.encodeString = this.encodeNodeString;\n      this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    } else {\n      this.writeString = this.writeDefaultIconvString;\n      this.encodeString = this.encodeIconvString;\n      this.writeLengthEncodedString = this.writeDefaultIconvLengthEncodedString;\n      this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;\n    }\n  }\n\n  changeDebug(debug) {\n    this.debug = debug;\n    this.flushBuffer = debug ? this.flushBufferDebug : this.flushBufferBasic;\n    this.fastFlush = debug ? this.fastFlushDebug : this.fastFlushBasic;\n  }\n\n  setStream(stream) {\n    this.stream = stream;\n  }\n\n  growBuffer(len) {\n    let newCapacity;\n    if (len + this.pos < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (len + this.pos < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (len + this.pos < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else {\n      newCapacity = MAX_BUFFER_SIZE;\n    }\n\n    if (len + this.pos > newCapacity) {\n      if (this.markPos !== -1) {\n        // buf is > 16M with mark.\n        // flush until mark, reset pos at beginning\n        this.flushBufferStopAtMark();\n\n        if (len + this.pos <= this.buf.length) {\n          return;\n        }\n        this.growBuffer(len);\n      }\n    }\n\n    let newBuf = Buffer.allocUnsafe(newCapacity);\n    this.buf.copy(newBuf, 0, 0, this.pos);\n    this.buf = newBuf;\n  }\n\n  mark() {\n    this.markPos = this.pos;\n  }\n\n  isMarked() {\n    return this.markPos !== -1;\n  }\n\n  hasFlushed() {\n    return this.cmd.sequenceNo !== -1;\n  }\n\n  bufIsDataAfterMark() {\n    return this.bufContainDataAfterMark;\n  }\n\n  bufIsAfterMaxPacketLength() {\n    return this.pos > this.maxPacketLength;\n  }\n\n  /**\n   * Reset mark flag and send bytes after mark flag.\n   *\n   * @return buffer after mark flag\n   */\n  resetMark() {\n    this.pos = this.markPos;\n    this.markPos = -1;\n    if (this.bufContainDataAfterMark) {\n      const data = Buffer.allocUnsafe(this.pos - 4);\n      this.buf.copy(data, 0, 4, this.pos);\n      this.cmd.sequenceNo = -1;\n      this.cmd.compressSequenceNo = -1;\n      this.bufContainDataAfterMark = false;\n      return data;\n    }\n    return null;\n  }\n\n  /**\n   * Send packet to socket.\n   *\n   * @throws IOException if socket error occur.\n   */\n  flush() {\n    this.flushBuffer(true, 0);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.cmd.sequenceNo = -1;\n    this.cmd.compressSequenceNo = -1;\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n\n  flushPacket() {\n    this.flushBuffer(false, 0);\n    this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n\n  startPacket(cmd) {\n    this.cmd = cmd;\n    this.pos = 4;\n  }\n\n  writeInt8(value) {\n    if (this.pos + 1 >= this.buf.length) {\n      if (this.pos >= MAX_BUFFER_SIZE && !this.bufContainDataAfterMark) {\n        //buffer is more than a Packet, must flushBuffer()\n        this.flushBuffer(false, 1);\n      } else this.growBuffer(1);\n    }\n    this.buf[this.pos++] = value;\n  }\n\n  writeInt16(value) {\n    if (this.pos + 2 >= this.buf.length) {\n      let b = Buffer.allocUnsafe(2);\n      b[0] = value;\n      b[1] = value >>> 8;\n      this.writeBuffer(b, 0, 2);\n      return;\n    }\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.pos += 2;\n  }\n\n  writeInt16AtPos(initPos) {\n    this.buf[initPos] = this.pos - initPos - 2;\n    this.buf[initPos + 1] = (this.pos - initPos - 2) >> 8;\n  }\n\n  writeInt24(value) {\n    if (this.pos + 3 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(3);\n      arr[0] = value;\n      arr[1] = value >> 8;\n      arr[2] = value >> 16;\n      this.writeBuffer(arr, 0, 3);\n      return;\n    }\n\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.buf[this.pos + 2] = value >> 16;\n    this.pos += 3;\n  }\n\n  writeInt32(value) {\n    if (this.pos + 4 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(4);\n      arr.writeInt32LE(value, 0);\n      this.writeBuffer(arr, 0, 4);\n      return;\n    }\n\n    this.buf[this.pos] = value;\n    this.buf[this.pos + 1] = value >> 8;\n    this.buf[this.pos + 2] = value >> 16;\n    this.buf[this.pos + 3] = value >> 24;\n    this.pos += 4;\n  }\n\n  writeBigInt(value) {\n    if (this.pos + 8 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(8);\n      arr.writeBigInt64LE(value, 0);\n      this.writeBuffer(arr, 0, 8);\n      return;\n    }\n    this.buf.writeBigInt64LE(value, this.pos);\n    this.pos += 8;\n  }\n\n  writeDouble(value) {\n    if (this.pos + 8 >= this.buf.length) {\n      //not enough space remaining\n      let arr = Buffer.allocUnsafe(8);\n      arr.writeDoubleLE(value, 0);\n      this.writeBuffer(arr, 0, 8);\n      return;\n    }\n    this.buf.writeDoubleLE(value, this.pos);\n    this.pos += 8;\n  }\n\n  writeLengthCoded(len) {\n    if (len < 0xfb) {\n      this.writeInt8(len);\n      return;\n    }\n\n    if (len < 65536) {\n      //max length is len < 0xffff\n      this.writeInt8(0xfc);\n      this.writeInt16(len);\n    } else if (len < 16777216) {\n      this.writeInt8(0xfd);\n      this.writeInt24(len);\n    } else {\n      this.writeInt8(0xfe);\n      this.writeBigInt(BigInt(len));\n    }\n  }\n\n  writeBuffer(arr, off, len) {\n    if (len > this.buf.length - this.pos) {\n      if (this.buf.length !== MAX_BUFFER_SIZE) {\n        this.growBuffer(len);\n      }\n\n      //max buffer size\n      if (len > this.buf.length - this.pos) {\n        if (this.markPos !== -1) {\n          this.growBuffer(len);\n          if (this.markPos !== -1) {\n            this.flushBufferStopAtMark();\n          }\n        }\n\n        if (len > this.buf.length - this.pos) {\n          //not enough space in buffer, will stream :\n          // fill buffer and flush until all data are snd\n          let remainingLen = len;\n\n          while (true) {\n            //filling buffer\n            let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);\n            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);\n            remainingLen -= lenToFillBuffer;\n            off += lenToFillBuffer;\n            this.pos += lenToFillBuffer;\n\n            if (remainingLen === 0) return;\n            this.flushBuffer(false, remainingLen);\n          }\n        }\n      }\n    }\n\n    // node.js copy is fast only when copying big buffer.\n    // quick array copy is multiple time faster for small copy\n    if (len > 50) {\n      arr.copy(this.buf, this.pos, off, off + len);\n      this.pos += len;\n    } else {\n      for (let i = 0; i < len; i++) {\n        this.buf[this.pos++] = arr[off + i];\n      }\n    }\n  }\n\n  /**\n   * Write ascii string to socket (no escaping)\n   *\n   * @param str                string\n   */\n  writeStringAscii(str) {\n    let len = str.length;\n\n    //not enough space remaining\n    if (len >= this.buf.length - this.pos) {\n      let strBuf = Buffer.from(str, 'ascii');\n      this.writeBuffer(strBuf, 0, strBuf.length);\n      return;\n    }\n\n    for (let off = 0; off < len; ) {\n      this.buf[this.pos++] = str.charCodeAt(off++);\n    }\n  }\n\n  writeLengthEncodedBuffer(buffer) {\n    const len = buffer.length;\n    this.writeLengthCoded(len);\n    this.writeBuffer(buffer, 0, len);\n  }\n\n  writeUtf8StringEscapeQuote(str) {\n    const charsLength = str.length;\n\n    //not enough space remaining\n    if (charsLength * 3 + 2 >= this.buf.length - this.pos) {\n      const arr = Buffer.from(str, 'utf8');\n      this.writeInt8(QUOTE);\n      this.writeBufferEscape(arr);\n      this.writeInt8(QUOTE);\n      return;\n    }\n\n    //create UTF-8 byte array\n    //since javascript char are internally using UTF-16 using surrogate's pattern, 4 bytes unicode characters will\n    //represent 2 characters : example \"\\uD83C\\uDFA4\" = ðŸŽ¤ unicode 8 \"no microphones\"\n    //so max size is 3 * charLength\n    //(escape characters are 1 byte encoded, so length might only be 2 when escaped)\n    // + 2 for the quotes for text protocol\n    let charsOffset = 0;\n    let currChar;\n    this.buf[this.pos++] = QUOTE;\n    //quick loop if only ASCII chars for faster escape\n    for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 0x80; charsOffset++) {\n      if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n        this.buf[this.pos++] = SLASH;\n      }\n      this.buf[this.pos++] = currChar;\n    }\n\n    //if quick loop not finished\n    while (charsOffset < charsLength) {\n      currChar = str.charCodeAt(charsOffset++);\n      if (currChar < 0x80) {\n        if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {\n          this.buf[this.pos++] = SLASH;\n        }\n        this.buf[this.pos++] = currChar;\n      } else if (currChar < 0x800) {\n        this.buf[this.pos++] = 0xc0 | (currChar >> 6);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      } else if (currChar >= 0xd800 && currChar < 0xe000) {\n        //reserved for surrogate - see https://en.wikipedia.org/wiki/UTF-16\n        if (currChar < 0xdc00) {\n          //is high surrogate\n          if (charsOffset + 1 > charsLength) {\n            this.buf[this.pos++] = 0x3f;\n          } else {\n            const nextChar = str.charCodeAt(charsOffset);\n            if (nextChar >= 0xdc00 && nextChar < 0xe000) {\n              //is low surrogate\n              const surrogatePairs = (currChar << 10) + nextChar + (0x010000 - (0xd800 << 10) - 0xdc00);\n              this.buf[this.pos++] = 0xf0 | (surrogatePairs >> 18);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 12) & 0x3f);\n              this.buf[this.pos++] = 0x80 | ((surrogatePairs >> 6) & 0x3f);\n              this.buf[this.pos++] = 0x80 | (surrogatePairs & 0x3f);\n              charsOffset++;\n            } else {\n              //must have low surrogate\n              this.buf[this.pos++] = 0x3f;\n            }\n          }\n        } else {\n          //low surrogate without high surrogate before\n          this.buf[this.pos++] = 0x3f;\n        }\n      } else {\n        this.buf[this.pos++] = 0xe0 | (currChar >> 12);\n        this.buf[this.pos++] = 0x80 | ((currChar >> 6) & 0x3f);\n        this.buf[this.pos++] = 0x80 | (currChar & 0x3f);\n      }\n    }\n    this.buf[this.pos++] = QUOTE;\n  }\n\n  encodeIconvString(str) {\n    return Iconv.encode(str, this.encoding);\n  }\n\n  encodeNodeString(str) {\n    return Buffer.from(str, this.encoding);\n  }\n\n  writeDefaultBufferString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    if (str.length * 3 < this.buf.length - this.pos) {\n      this.pos += this.buf.write(str, this.pos, this.encoding);\n      return;\n    }\n\n    //checking real length\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    if (byteLength > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n  }\n\n  writeDefaultBufferLengthEncodedString(str) {\n    //javascript use UCS-2 or UTF-16 string internal representation\n    //that means that string to byte will be a maximum of * 3\n    // (4 bytes utf-8 are represented on 2 UTF-16 characters)\n    //checking real length\n    let byteLength = Buffer.byteLength(str, this.encoding);\n    this.writeLengthCoded(byteLength);\n\n    if (byteLength > this.buf.length - this.pos) {\n      if (this.buf.length < MAX_BUFFER_SIZE) {\n        this.growBuffer(byteLength);\n      }\n      if (byteLength > this.buf.length - this.pos) {\n        //not enough space in buffer, will stream :\n        let strBuf = Buffer.from(str, this.encoding);\n        this.writeBuffer(strBuf, 0, strBuf.length);\n        return;\n      }\n    }\n    this.pos += this.buf.write(str, this.pos, this.encoding);\n  }\n\n  writeDefaultIconvString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    this.writeBuffer(buf, 0, buf.length);\n  }\n\n  writeDefaultIconvLengthEncodedString(str) {\n    let buf = Iconv.encode(str, this.encoding);\n    this.writeLengthCoded(buf.length);\n    this.writeBuffer(buf, 0, buf.length);\n  }\n\n  /**\n   * Parameters need to be properly escaped :\n   * following characters are to be escaped by \"\\\" :\n   * - \\0\n   * - \\\\\n   * - \\'\n   * - \\\"\n   * - \\032\n   * regex split part of string writing part, and escaping special char.\n   * Those chars are <= 7f meaning that this will work even with multibyte encoding\n   *\n   * @param str string to escape.\n   */\n  writeDefaultStringEscapeQuote(str) {\n    this.writeInt8(QUOTE);\n    let match;\n    let lastIndex = 0;\n    while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {\n      this.writeString(str.slice(lastIndex, match.index));\n      this.writeInt8(SLASH);\n      this.writeInt8(match[0].charCodeAt(0));\n      lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;\n    }\n\n    if (lastIndex === 0) {\n      // Nothing was escaped\n      this.writeString(str);\n      this.writeInt8(QUOTE);\n      return;\n    }\n\n    if (lastIndex < str.length) {\n      this.writeString(str.slice(lastIndex));\n    }\n    this.writeInt8(QUOTE);\n  }\n\n  writeBinaryDate(date) {\n    const year = date.getFullYear();\n    const mon = date.getMonth() + 1;\n    const day = date.getDate();\n    const hour = date.getHours();\n    const min = date.getMinutes();\n    const sec = date.getSeconds();\n    const ms = date.getMilliseconds();\n\n    let len = ms === 0 ? 7 : 11;\n    //not enough space remaining\n    if (len + 1 > this.buf.length - this.pos) {\n      let tmpBuf = Buffer.allocUnsafe(len + 1);\n\n      tmpBuf[0] = len;\n      tmpBuf[1] = year;\n      tmpBuf[2] = year >>> 8;\n      tmpBuf[3] = mon;\n      tmpBuf[4] = day;\n      tmpBuf[5] = hour;\n      tmpBuf[6] = min;\n      tmpBuf[7] = sec;\n      if (ms !== 0) {\n        const micro = ms * 1000;\n        tmpBuf[8] = micro;\n        tmpBuf[9] = micro >>> 8;\n        tmpBuf[10] = micro >>> 16;\n        tmpBuf[11] = micro >>> 24;\n      }\n\n      this.writeBuffer(tmpBuf, 0, len + 1);\n      return;\n    }\n\n    this.buf[this.pos] = len;\n    this.buf[this.pos + 1] = year;\n    this.buf[this.pos + 2] = year >>> 8;\n    this.buf[this.pos + 3] = mon;\n    this.buf[this.pos + 4] = day;\n    this.buf[this.pos + 5] = hour;\n    this.buf[this.pos + 6] = min;\n    this.buf[this.pos + 7] = sec;\n\n    if (ms !== 0) {\n      const micro = ms * 1000;\n      this.buf[this.pos + 8] = micro;\n      this.buf[this.pos + 9] = micro >>> 8;\n      this.buf[this.pos + 10] = micro >>> 16;\n      this.buf[this.pos + 11] = micro >>> 24;\n    }\n    this.pos += len + 1;\n  }\n\n  writeBufferEscape(val) {\n    let valLen = val.length;\n    if (valLen * 2 > this.buf.length - this.pos) {\n      //makes buffer bigger (up to 16M)\n      if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);\n\n      //data may still be bigger than buffer.\n      //must flush buffer when full (and reset position to 4)\n      if (valLen * 2 > this.buf.length - this.pos) {\n        //not enough space in buffer, will fill buffer\n        for (let i = 0; i < valLen; i++) {\n          switch (val[i]) {\n            case QUOTE:\n            case SLASH:\n            case DBL_QUOTE:\n            case ZERO_BYTE:\n              if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n              this.buf[this.pos++] = SLASH; //add escape slash\n          }\n          if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);\n          this.buf[this.pos++] = val[i];\n        }\n        return;\n      }\n    }\n\n    //sure to have enough place to use buffer directly\n    for (let i = 0; i < valLen; i++) {\n      switch (val[i]) {\n        case QUOTE:\n        case SLASH:\n        case DBL_QUOTE:\n        case ZERO_BYTE:\n          this.buf[this.pos++] = SLASH; //add escape slash\n      }\n      this.buf[this.pos++] = val[i];\n    }\n  }\n\n  /**\n   * Count query size. If query size is greater than max_allowed_packet and nothing has been already\n   * send, throw an exception to avoid having the connection closed.\n   *\n   * @param length additional length to query size\n   * @param info current connection information\n   * @throws Error if query has not to be sent.\n   */\n  checkMaxAllowedLength(length, info) {\n    if (this.cmdLength + length >= this.maxAllowedPacket) {\n      // launch exception only if no packet has been sent.\n      return Errors.createFatalError(\n        `query size (${this.cmdLength + length}) is >= to max_allowed_packet (${this.maxAllowedPacket})`,\n        Errors.ER_MAX_ALLOWED_PACKET,\n        info\n      );\n    }\n    return null;\n  }\n\n  /**\n   * Indicate if buffer contain any data.\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.pos <= 4;\n  }\n\n  /**\n   * Flush the internal buffer.\n   */\n  flushBufferDebug(commandEnd, remainingLen) {\n    if (this.pos > 4) {\n      this.buf[0] = this.pos - 4;\n      this.buf[1] = (this.pos - 4) >>> 8;\n      this.buf[2] = (this.pos - 4) >>> 16;\n      this.buf[3] = ++this.cmd.sequenceNo;\n      this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);\n      this.stream.flush(true, this.cmd);\n      this.cmdLength += this.pos - 4;\n\n      this.opts.logger.network(\n        `==> conn:${this.info.threadId ? this.info.threadId : -1} ${\n          this.cmd.constructor.name + '(0,' + this.pos + ')'\n        }\\n${Utils.log(this.opts, this.buf, 0, this.pos)}`\n      );\n\n      if (commandEnd && this.pos === MAX_BUFFER_SIZE) {\n        //if last packet fill the max size, must send an empty com to indicate that command end.\n        this.writeEmptyPacket();\n      }\n      this.buf = this.createBufferWithMinSize(remainingLen);\n      this.pos = 4;\n    }\n  }\n\n  /**\n   * Flush to last mark.\n   */\n  flushBufferStopAtMark() {\n    const end = this.pos;\n    this.pos = this.markPos;\n    const tmpBuf = Buffer.allocUnsafe(Math.max(SMALL_BUFFER_SIZE, end + 4 - this.pos));\n    this.buf.copy(tmpBuf, 4, this.markPos, end);\n    this.flushBuffer(true, end - this.pos);\n    this.cmdLength = 0;\n    this.buf = tmpBuf;\n    this.pos = 4 + end - this.markPos;\n    this.markPos = -1;\n    this.bufContainDataAfterMark = true;\n  }\n\n  flushBufferBasic(commandEnd, remainingLen) {\n    this.buf[0] = this.pos - 4;\n    this.buf[1] = (this.pos - 4) >>> 8;\n    this.buf[2] = (this.pos - 4) >>> 16;\n    this.buf[3] = ++this.cmd.sequenceNo;\n    this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);\n    this.stream.flush(true, this.cmd);\n    this.cmdLength += this.pos - 4;\n    if (commandEnd && this.pos === MAX_BUFFER_SIZE) {\n      //if last packet fill the max size, must send an empty com to indicate that command end.\n      this.writeEmptyPacket();\n    }\n    this.buf = this.createBufferWithMinSize(remainingLen);\n    this.pos = 4;\n  }\n\n  createBufferWithMinSize(remainingLen) {\n    let newCapacity;\n    if (remainingLen + 4 < SMALL_BUFFER_SIZE) {\n      newCapacity = SMALL_BUFFER_SIZE;\n    } else if (remainingLen + 4 < MEDIUM_BUFFER_SIZE) {\n      newCapacity = MEDIUM_BUFFER_SIZE;\n    } else if (remainingLen + 4 < LARGE_BUFFER_SIZE) {\n      newCapacity = LARGE_BUFFER_SIZE;\n    } else if (remainingLen + 4 < BIG_BUFFER_SIZE) {\n      newCapacity = BIG_BUFFER_SIZE;\n    } else {\n      newCapacity = MAX_BUFFER_SIZE;\n    }\n    return Buffer.allocUnsafe(newCapacity);\n  }\n\n  fastFlushDebug(cmd, packet) {\n    this.stream.writeBuf(packet, cmd);\n    this.stream.flush(true, cmd);\n    this.cmdLength += packet.length;\n\n    this.opts.logger.network(\n      `==> conn:${this.info.threadId ? this.info.threadId : -1} ${\n        cmd.constructor.name + '(0,' + packet.length + ')'\n      }\\n${Utils.log(this.opts, packet, 0, packet.length)}`\n    );\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n\n  fastFlushBasic(cmd, packet) {\n    this.stream.writeBuf(packet, cmd);\n    this.stream.flush(true, cmd);\n    this.cmdLength = 0;\n    this.markPos = -1;\n  }\n\n  writeEmptyPacket() {\n    const emptyBuf = Buffer.from([0x00, 0x00, 0x00, ++this.cmd.sequenceNo]);\n\n    if (this.debug) {\n      this.opts.logger.network(\n        `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name}(0,4)\\n${Utils.log(\n          this.opts,\n          emptyBuf,\n          0,\n          4\n        )}`\n      );\n    }\n\n    this.stream.writeBuf(emptyBuf, this.cmd);\n    this.stream.flush(true, this.cmd);\n    this.cmdLength = 0;\n  }\n}\n\nmodule.exports = PacketOutputStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
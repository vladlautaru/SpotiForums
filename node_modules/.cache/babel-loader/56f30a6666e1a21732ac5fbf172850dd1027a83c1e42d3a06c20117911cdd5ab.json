{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\nconst PluginAuth = require('./plugin-auth');\nconst fs = require('fs');\nconst Errors = require('../../../misc/errors');\nconst Sha256PasswordAuth = require('./sha256-password-auth');\nconst State = {\n  INIT: 'INIT',\n  FAST_AUTH_RESULT: 'FAST_AUTH_RESULT',\n  REQUEST_SERVER_KEY: 'REQUEST_SERVER_KEY',\n  SEND_AUTH: 'SEND_AUTH'\n};\n\n/**\n * Use caching Sha2 password authentication\n */\nclass CachingSha2PasswordAuth extends PluginAuth {\n  constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {\n    super(cmdParam, multiAuthResolver, reject);\n    this.multiAuthResolver = multiAuthResolver;\n    this.pluginData = pluginData;\n    this.sequenceNo = packSeq;\n    this.compressSequenceNo = compressPackSeq;\n    this.counter = 0;\n    this.state = State.INIT;\n  }\n  start(out, opts, info) {\n    this.exchange(this.pluginData, out, opts, info);\n    this.onPacketReceive = this.response;\n  }\n  exchange(packet, out, opts, info) {\n    switch (this.state) {\n      case State.INIT:\n        const truncatedSeed = this.pluginData.slice(0, this.pluginData.length - 1);\n        const encPwd = Sha256PasswordAuth.encryptSha256Password(opts.password, truncatedSeed);\n        out.startPacket(this);\n        if (encPwd.length > 0) {\n          out.writeBuffer(encPwd, 0, encPwd.length);\n          out.flushPacket();\n        } else {\n          out.writeEmptyPacket(true);\n        }\n        this.state = State.FAST_AUTH_RESULT;\n        return;\n      case State.FAST_AUTH_RESULT:\n        // length encoded numeric : 0x01 0x03/0x04\n        const fastAuthResult = packet[1];\n        switch (fastAuthResult) {\n          case 0x03:\n            // success authentication\n            // an OK_Packet will follow\n            return;\n          case 0x04:\n            if (opts.ssl) {\n              // using SSL, so sending password in clear\n              out.startPacket(this);\n              out.writeString(opts.password);\n              out.writeInt8(0);\n              out.flushPacket();\n              return;\n            }\n\n            // retrieve public key from configuration or from server\n            if (opts.cachingRsaPublicKey) {\n              try {\n                let key = opts.cachingRsaPublicKey;\n                if (!key.includes('-----BEGIN')) {\n                  // rsaPublicKey contain path\n                  key = fs.readFileSync(key, 'utf8');\n                }\n                this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);\n              } catch (err) {\n                return this.throwError(err, info);\n              }\n              // send Sha256Password Packet\n              Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n            } else {\n              if (!opts.allowPublicKeyRetrieval) {\n                return this.throwError(Errors.createFatalError('RSA public key is not available client side. Either set option `cachingRsaPublicKey` to indicate' + ' public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`', Errors.ER_CANNOT_RETRIEVE_RSA_KEY, info), info);\n              }\n              this.state = State.REQUEST_SERVER_KEY;\n              // ask caching public Key Retrieval\n              out.startPacket(this);\n              out.writeInt8(0x02);\n              out.flushPacket();\n            }\n        }\n        return;\n      case State.REQUEST_SERVER_KEY:\n        this.publicKey = Sha256PasswordAuth.retrievePublicKey(packet.toString(undefined, 1));\n        this.state = State.SEND_AUTH;\n        Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n        return;\n    }\n  }\n  response(packet, out, opts, info) {\n    const marker = packet.peek();\n    switch (marker) {\n      //*********************************************************************************************************\n      //* OK_Packet and Err_Packet ending packet\n      //*********************************************************************************************************\n      case 0x00:\n      case 0xff:\n        this.emit('send_end');\n        return this.multiAuthResolver(packet, out, opts, info);\n      default:\n        let promptData = packet.readBufferRemaining();\n        this.exchange(promptData, out, opts, info);\n        this.onPacketReceive = this.response;\n    }\n  }\n}\nmodule.exports = CachingSha2PasswordAuth;","map":{"version":3,"names":["PluginAuth","require","fs","Errors","Sha256PasswordAuth","State","INIT","FAST_AUTH_RESULT","REQUEST_SERVER_KEY","SEND_AUTH","CachingSha2PasswordAuth","constructor","packSeq","compressPackSeq","pluginData","cmdParam","reject","multiAuthResolver","sequenceNo","compressSequenceNo","counter","state","start","out","opts","info","exchange","onPacketReceive","response","packet","truncatedSeed","slice","length","encPwd","encryptSha256Password","password","startPacket","writeBuffer","flushPacket","writeEmptyPacket","fastAuthResult","ssl","writeString","writeInt8","cachingRsaPublicKey","key","includes","readFileSync","publicKey","retrievePublicKey","err","throwError","sendSha256PwdPacket","allowPublicKeyRetrieval","createFatalError","ER_CANNOT_RETRIEVE_RSA_KEY","toString","undefined","marker","peek","emit","promptData","readBufferRemaining","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cmd/handshake/auth/caching-sha2-password-auth.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\nconst PluginAuth = require('./plugin-auth');\nconst fs = require('fs');\nconst Errors = require('../../../misc/errors');\nconst Sha256PasswordAuth = require('./sha256-password-auth');\n\nconst State = {\n  INIT: 'INIT',\n  FAST_AUTH_RESULT: 'FAST_AUTH_RESULT',\n  REQUEST_SERVER_KEY: 'REQUEST_SERVER_KEY',\n  SEND_AUTH: 'SEND_AUTH'\n};\n\n/**\n * Use caching Sha2 password authentication\n */\nclass CachingSha2PasswordAuth extends PluginAuth {\n  constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {\n    super(cmdParam, multiAuthResolver, reject);\n    this.multiAuthResolver = multiAuthResolver;\n    this.pluginData = pluginData;\n    this.sequenceNo = packSeq;\n    this.compressSequenceNo = compressPackSeq;\n    this.counter = 0;\n    this.state = State.INIT;\n  }\n\n  start(out, opts, info) {\n    this.exchange(this.pluginData, out, opts, info);\n    this.onPacketReceive = this.response;\n  }\n\n  exchange(packet, out, opts, info) {\n    switch (this.state) {\n      case State.INIT:\n        const truncatedSeed = this.pluginData.slice(0, this.pluginData.length - 1);\n        const encPwd = Sha256PasswordAuth.encryptSha256Password(opts.password, truncatedSeed);\n        out.startPacket(this);\n        if (encPwd.length > 0) {\n          out.writeBuffer(encPwd, 0, encPwd.length);\n          out.flushPacket();\n        } else {\n          out.writeEmptyPacket(true);\n        }\n        this.state = State.FAST_AUTH_RESULT;\n        return;\n\n      case State.FAST_AUTH_RESULT:\n        // length encoded numeric : 0x01 0x03/0x04\n        const fastAuthResult = packet[1];\n        switch (fastAuthResult) {\n          case 0x03:\n            // success authentication\n            // an OK_Packet will follow\n            return;\n\n          case 0x04:\n            if (opts.ssl) {\n              // using SSL, so sending password in clear\n              out.startPacket(this);\n              out.writeString(opts.password);\n              out.writeInt8(0);\n              out.flushPacket();\n              return;\n            }\n\n            // retrieve public key from configuration or from server\n            if (opts.cachingRsaPublicKey) {\n              try {\n                let key = opts.cachingRsaPublicKey;\n                if (!key.includes('-----BEGIN')) {\n                  // rsaPublicKey contain path\n                  key = fs.readFileSync(key, 'utf8');\n                }\n                this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);\n              } catch (err) {\n                return this.throwError(err, info);\n              }\n              // send Sha256Password Packet\n              Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n            } else {\n              if (!opts.allowPublicKeyRetrieval) {\n                return this.throwError(\n                  Errors.createFatalError(\n                    'RSA public key is not available client side. Either set option `cachingRsaPublicKey` to indicate' +\n                      ' public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`',\n                    Errors.ER_CANNOT_RETRIEVE_RSA_KEY,\n                    info\n                  ),\n                  info\n                );\n              }\n              this.state = State.REQUEST_SERVER_KEY;\n              // ask caching public Key Retrieval\n              out.startPacket(this);\n              out.writeInt8(0x02);\n              out.flushPacket();\n            }\n        }\n        return;\n\n      case State.REQUEST_SERVER_KEY:\n        this.publicKey = Sha256PasswordAuth.retrievePublicKey(packet.toString(undefined, 1));\n        this.state = State.SEND_AUTH;\n        Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n        return;\n    }\n  }\n\n  response(packet, out, opts, info) {\n    const marker = packet.peek();\n    switch (marker) {\n      //*********************************************************************************************************\n      //* OK_Packet and Err_Packet ending packet\n      //*********************************************************************************************************\n      case 0x00:\n      case 0xff:\n        this.emit('send_end');\n        return this.multiAuthResolver(packet, out, opts, info);\n\n      default:\n        let promptData = packet.readBufferRemaining();\n        this.exchange(promptData, out, opts, info);\n        this.onPacketReceive = this.response;\n    }\n  }\n}\n\nmodule.exports = CachingSha2PasswordAuth;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
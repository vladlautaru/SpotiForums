{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\nconst Queue = require('denque');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\nconst Connection = require('./connection');\nconst CommandParameter = require('./command-parameter');\nclass Pool extends EventEmitter {\n  opts;\n  #closed = false;\n  #connectionInCreation = false;\n  #errorCreatingConnection = null;\n  #idleConnections = new Queue();\n  #activeConnections = {};\n  #requests = new Queue();\n  #unusedConnectionRemoverId;\n  #requestTimeoutId;\n  #connErrorNumber = 0;\n  #initialized = false;\n  _sizeHandlerTimeout;\n  constructor(options) {\n    super();\n    this.opts = options;\n    this.on('_idle', this._requestsHandler);\n    this.on('validateSize', this._sizeHandler);\n    this._sizeHandler();\n  }\n\n  //*****************************************************************\n  // pool automatic handlers\n  //*****************************************************************\n\n  _doCreateConnection(resolve, reject, timeoutEnd) {\n    this._createConnection().then(conn => {\n      if (this.#closed) {\n        conn.forceEnd(null, () => {}, () => {});\n        reject(new Errors.createFatalError('Cannot create new connection to pool, pool closed', Errors.ER_ADD_CONNECTION_CLOSED_POOL));\n        return;\n      }\n      conn.lastUse = Date.now();\n      const nativeDestroy = conn.destroy.bind(conn);\n      const pool = this;\n      conn.destroy = function () {\n        pool._endLeak(conn);\n        delete pool.#activeConnections[conn.threadId];\n        nativeDestroy();\n        pool.emit('validateSize');\n      };\n      conn.once('error', function () {\n        let idx = 0;\n        let currConn;\n        pool._endLeak(conn);\n        delete pool.#activeConnections[conn.threadId];\n        while (currConn = pool.#idleConnections.peekAt(idx)) {\n          if (currConn === conn) {\n            pool.#idleConnections.removeOne(idx);\n            continue;\n          }\n          //since connection did have an error, other waiting connection might too\n          //force validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n          currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool.opts.minDelayValidation);\n          idx++;\n        }\n        setTimeout(() => {\n          if (!pool.#requests.isEmpty()) {\n            pool._sizeHandler();\n          }\n        }, 0);\n      });\n      this.#idleConnections.push(conn);\n      this.#connectionInCreation = false;\n      this.emit('_idle');\n      this.emit('connection', conn);\n      resolve(conn);\n    }).catch(err => {\n      //if timeout is reached or authentication fail return error\n      if (err instanceof AggregateError) {\n        err = err.errors[0];\n      }\n      if (this.#closed || err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698) || timeoutEnd < Date.now()) {\n        err.message = err.message + this._errorMsgAddon();\n        reject(err);\n        return;\n      }\n      setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);\n    });\n  }\n  _destroy(conn) {\n    this._endLeak(conn);\n    delete this.#activeConnections[conn.threadId];\n    conn.lastUse = Date.now();\n    conn.forceEnd(null, () => {}, () => {});\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n  release(conn) {\n    // ensure releasing only once\n    if (this.#activeConnections[conn.threadId]) {\n      this._endLeak(conn);\n      this.#activeConnections[conn.threadId] = null;\n      conn.lastUse = Date.now();\n      if (this.#closed) {\n        conn.forceEnd(null, () => {}, () => {});\n      } else if (conn.isValid()) {\n        this.emit('release', conn);\n        this.#idleConnections.push(conn);\n        process.nextTick(this.emit.bind(this, '_idle'));\n      } else {\n        this.emit('validateSize');\n      }\n    }\n  }\n  _checkLeak(conn) {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(conn => {\n      conn.leaked = true;\n      conn.opts.logger.warning(`A possible connection leak on the thread ${conn.info.threadId} (the connection not returned to the pool since ${Date.now() - conn.lastUse} ms). Has the connection.release() been called ?` + this._errorMsgAddon());\n    }, this.opts.leakDetectionTimeout, conn);\n  }\n  _endLeak(conn) {\n    if (conn.leakProcess) {\n      clearTimeout(conn.leakProcess);\n      conn.leakProcess = null;\n      if (conn.leaked) {\n        conn.opts.logger.warning(`Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`);\n      }\n    }\n  }\n\n  /**\n   * Permit to remove idle connection if unused for some time.\n   */\n  _startReaping() {\n    if (!this.#unusedConnectionRemoverId && this.opts.idleTimeout > 0) {\n      this.#unusedConnectionRemoverId = setInterval(this._reaper.bind(this), 500);\n    }\n  }\n  _stopReaping() {\n    if (this.#unusedConnectionRemoverId && this.totalConnections() === 0) {\n      clearInterval(this.#unusedConnectionRemoverId);\n    }\n  }\n  _reaper() {\n    const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1000;\n    let maxRemoval = Math.max(0, this.#idleConnections.length - this.opts.minimumIdle);\n    while (maxRemoval > 0) {\n      const conn = this.#idleConnections.peek();\n      maxRemoval--;\n      if (conn && conn.lastUse < idleTimeRemoval) {\n        this.#idleConnections.shift();\n        conn.forceEnd(null, () => {}, () => {});\n        continue;\n      }\n      break;\n    }\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n  _shouldCreateMoreConnections() {\n    return !this.#connectionInCreation && this.#idleConnections.length < this.opts.minimumIdle && this.totalConnections() < this.opts.connectionLimit && !this.#closed;\n  }\n\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n  _sizeHandler() {\n    if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {\n      this.#connectionInCreation = true;\n      setImmediate(function () {\n        const timeoutEnd = Date.now() + this.opts.initializationTimeout;\n        new Promise((resolve, reject) => {\n          this._doCreateConnection(resolve, reject, timeoutEnd);\n        }).then(() => {\n          this.#initialized = true;\n          this.#errorCreatingConnection = null;\n          this.#connErrorNumber = 0;\n          if (this._shouldCreateMoreConnections()) {\n            this.emit('validateSize');\n          }\n          this._startReaping();\n        }).catch(err => {\n          this.#connectionInCreation = false;\n          if (!this.#closed) {\n            if (!this.#initialized) {\n              err.message = 'Error during pool initialization: ' + err.message;\n            } else {\n              err.message = 'Pool fails to create connection: ' + err.message;\n            }\n            this.#errorCreatingConnection = err;\n            this.emit('error', err);\n\n            //delay next try\n            this._sizeHandlerTimeout = setTimeout(function () {\n              this._sizeHandlerTimeout = null;\n              if (!this.#requests.isEmpty()) {\n                this._sizeHandler();\n              }\n            }.bind(this), Math.min(++this.#connErrorNumber * 500, 10000));\n          }\n        });\n      }.bind(this));\n    }\n  }\n\n  /**\n   * Launch next waiting task request if available connections.\n   */\n  _requestsHandler() {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    const request = this.#requests.shift();\n    if (request) {\n      const conn = this.#idleConnections.shift();\n      if (conn) {\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        this.emit('acquire', conn);\n        this.#activeConnections[conn.threadId] = conn;\n        request.resolver(conn);\n      } else {\n        this.#requests.unshift(request);\n      }\n      this._requestTimeoutHandler();\n    }\n  }\n  _hasIdleConnection() {\n    return !this.#idleConnections.isEmpty();\n  }\n\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @returns {Promise<Connection>} connection of null of no valid idle connection.\n   */\n  async _doAcquire() {\n    if (!this._hasIdleConnection() || this.#closed) return Promise.reject();\n    let conn;\n    let mustRecheckSize = false;\n    while ((conn = this.#idleConnections.shift()) != null) {\n      //just check connection state first\n      if (conn.isValid()) {\n        this.#activeConnections[conn.threadId] = conn;\n        //if not used for some time, validate connection with a COM_PING\n        if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {\n          try {\n            const cmdParam = new CommandParameter(null, null, {\n              timeout: this.opts.pingTimeout\n            });\n            await new Promise(conn.ping.bind(conn, cmdParam));\n          } catch (e) {\n            delete this.#activeConnections[conn.threadId];\n            continue;\n          }\n        }\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        if (mustRecheckSize) setImmediate(this.emit.bind(this, 'validateSize'));\n        return Promise.resolve(conn);\n      }\n      mustRecheckSize = true;\n    }\n    setImmediate(this.emit.bind(this, 'validateSize'));\n    return Promise.reject();\n  }\n  _requestTimeoutHandler() {\n    //handle next Timer\n    this.#requestTimeoutId = null;\n    const currTime = Date.now();\n    let request;\n    while (request = this.#requests.peekFront()) {\n      if (request.timeout <= currTime) {\n        this.#requests.shift();\n        let cause = this.activeConnections() === 0 ? this.#errorCreatingConnection : null;\n        let err = Errors.createError(`retrieve connection from pool timeout after ${Math.abs(Date.now() - (request.timeout - this.opts.acquireTimeout))}ms${this._errorMsgAddon()}`, Errors.ER_GET_CONNECTION_TIMEOUT, null, 'HY000', null, false, request.stack, null, cause);\n        request.reject(err);\n      } else {\n        this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n  _searchInfo() {\n    let info = null;\n    let conn = this.#idleConnections.get(0);\n    if (!conn) {\n      for (const threadId in Object.keys(this.#activeConnections)) {\n        conn = this.#activeConnections[threadId];\n        if (!conn) {\n          break;\n        }\n      }\n    }\n    if (conn) {\n      info = conn.info;\n    }\n    return info;\n  }\n  async _createConnection() {\n    const conn = new Connection(this.opts.connOptions);\n    await conn.connect();\n    const pool = this;\n    conn.forceEnd = conn.end;\n    conn.release = function (resolve) {\n      if (pool.#closed || !conn.isValid()) {\n        pool._destroy(conn);\n        resolve();\n        return;\n      }\n      if (pool.opts.noControlAfterUse) {\n        pool.release(conn);\n        resolve();\n        return;\n      }\n      //if server permit it, reset the connection, or rollback only if not\n      // COM_RESET_CONNECTION exist since mysql 5.7.3 and mariadb 10.2.4\n      // but not possible to use it with mysql waiting for https://bugs.mysql.com/bug.php?id=97633 correction.\n      // and mariadb only since https://jira.mariadb.org/browse/MDEV-18281\n      let revertFunction;\n      if (pool.opts.resetAfterUse && conn.info.isMariaDB() && (conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22) || conn.info.hasMinVersion(10, 3, 13))) {\n        revertFunction = conn.reset.bind(conn, new CommandParameter());\n      } else revertFunction = conn.changeTransaction.bind(conn, new CommandParameter('ROLLBACK'));\n      new Promise(revertFunction).then(pool.release.bind(pool, conn), pool._destroy.bind(pool, conn)).finally(resolve);\n    };\n    conn.end = conn.release;\n    return conn;\n  }\n  _leakedConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection && connection.leaked) counter++;\n    }\n    return counter;\n  }\n  _errorMsgAddon() {\n    if (this.opts.leakDetectionTimeout > 0) {\n      return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${this.opts.connectionLimit})`;\n    }\n    return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit})`;\n  }\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  get closed() {\n    return this.#closed;\n  }\n\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n  totalConnections() {\n    return this.activeConnections() + this.idleConnections();\n  }\n\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n  activeConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection) counter++;\n    }\n    return counter;\n  }\n\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n  idleConnections() {\n    return this.#idleConnections.length;\n  }\n\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n  taskQueueSize() {\n    return this.#requests.length;\n  }\n  escape(value) {\n    return Utils.escape(this.opts.connOptions, this._searchInfo(), value);\n  }\n  escapeId(value) {\n    return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  //*****************************************************************\n  // promise methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   * @param cmdParam for stackTrace error\n   * @return {Promise}\n   */\n  getConnection(cmdParam) {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is closed', Errors.ER_POOL_ALREADY_CLOSED, null, 'HY000', cmdParam === null ? null : cmdParam.sql, false, cmdParam.stack));\n    }\n    return this._doAcquire().then(conn => {\n      // connection is available. process task\n      this.emit('acquire', conn);\n      return conn;\n    }, () => {\n      if (this.#closed) {\n        throw Errors.createError('Cannot add request to pool, pool is closed', Errors.ER_POOL_ALREADY_CLOSED, null, 'HY000', cmdParam === null ? null : cmdParam.sql, false, cmdParam.stack);\n      }\n      // no idle connection available\n      // create a new connection if limit is not reached\n      setImmediate(this.emit.bind(this, 'validateSize'));\n      return new Promise(function (resolver, rejecter) {\n        // stack request\n        setImmediate(this.emit.bind(this, 'enqueue'));\n        const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);\n        this.#requests.push(request);\n        if (!this.#requestTimeoutId) {\n          this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout);\n        }\n      }.bind(this));\n    });\n  }\n\n  /**\n   * Close all connection in pool\n   * Ends in multiple step :\n   * - close idle connections\n   * - ensure that no new request is possible\n   *   (active connection release are automatically closed on release)\n   * - if remaining, after 10 seconds, close remaining active connections\n   *\n   * @return Promise\n   */\n  end() {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is already closed', Errors.ER_POOL_ALREADY_CLOSED));\n    }\n    this.#closed = true;\n    clearInterval(this.#unusedConnectionRemoverId);\n    clearInterval(this._sizeHandlerTimeout);\n    const cmdParam = new CommandParameter();\n    if (this.opts.trace) Error.captureStackTrace(cmdParam);\n    //close unused connections\n    const idleConnectionsEndings = [];\n    let conn;\n    while (conn = this.#idleConnections.shift()) {\n      idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));\n    }\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n\n    //reject all waiting task\n    if (!this.#requests.isEmpty()) {\n      const err = Errors.createError('pool is ending, connection request aborted', Errors.ER_CLOSING_POOL, null, 'HY000', null, false, cmdParam.stack);\n      let task;\n      while (task = this.#requests.shift()) {\n        task.reject(err);\n      }\n    }\n    const pool = this;\n    return Promise.all(idleConnectionsEndings).then(async () => {\n      if (pool.activeConnections() > 0) {\n        // wait up to 10 seconds, that active connection are released\n        let remaining = 100;\n        while (remaining-- > 0) {\n          if (pool.activeConnections() > 0) {\n            await new Promise(res => setTimeout(() => res(), 100));\n          }\n        }\n\n        // force close any remaining active connections\n        for (const connection of Object.values(pool.#activeConnections)) {\n          if (connection) connection.destroy();\n        }\n      }\n      return Promise.resolve();\n    });\n  }\n}\nclass Request {\n  constructor(timeout, stack, resolver, rejecter) {\n    this.timeout = timeout;\n    this.stack = stack;\n    this.resolver = resolver;\n    this.rejecter = rejecter;\n  }\n  reject(err) {\n    process.nextTick(this.rejecter, err);\n  }\n}\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","Queue","Errors","Utils","Connection","CommandParameter","Pool","opts","closed","connectionInCreation","errorCreatingConnection","idleConnections","activeConnections","requests","unusedConnectionRemoverId","requestTimeoutId","connErrorNumber","initialized","_sizeHandlerTimeout","constructor","options","on","_requestsHandler","_sizeHandler","_doCreateConnection","resolve","reject","timeoutEnd","_createConnection","then","conn","forceEnd","createFatalError","ER_ADD_CONNECTION_CLOSED_POOL","lastUse","Date","now","nativeDestroy","destroy","bind","pool","_endLeak","threadId","emit","once","idx","currConn","peekAt","removeOne","Math","min","minDelayValidation","setTimeout","isEmpty","push","catch","err","AggregateError","errors","errno","message","_errorMsgAddon","_destroy","totalConnections","_stopReaping","release","isValid","process","nextTick","_checkLeak","leaked","leakProcess","logger","warning","info","leakDetectionTimeout","clearTimeout","_startReaping","idleTimeout","setInterval","_reaper","clearInterval","idleTimeRemoval","maxRemoval","max","length","minimumIdle","peek","shift","_shouldCreateMoreConnections","connectionLimit","setImmediate","initializationTimeout","Promise","request","resolver","unshift","_requestTimeoutHandler","_hasIdleConnection","_doAcquire","mustRecheckSize","cmdParam","timeout","pingTimeout","ping","e","currTime","peekFront","cause","createError","abs","acquireTimeout","ER_GET_CONNECTION_TIMEOUT","stack","_searchInfo","get","Object","keys","connOptions","connect","end","noControlAfterUse","revertFunction","resetAfterUse","isMariaDB","serverVersion","minor","hasMinVersion","reset","changeTransaction","finally","_leakedConnections","counter","connection","values","taskQueueSize","escape","value","escapeId","getConnection","ER_POOL_ALREADY_CLOSED","sql","rejecter","Request","trace","Error","captureStackTrace","idleConnectionsEndings","ER_CLOSING_POOL","task","all","remaining","res","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/pool.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst { EventEmitter } = require('events');\n\nconst Queue = require('denque');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\nconst Connection = require('./connection');\nconst CommandParameter = require('./command-parameter');\n\nclass Pool extends EventEmitter {\n  opts;\n  #closed = false;\n  #connectionInCreation = false;\n  #errorCreatingConnection = null;\n  #idleConnections = new Queue();\n  #activeConnections = {};\n  #requests = new Queue();\n  #unusedConnectionRemoverId;\n  #requestTimeoutId;\n  #connErrorNumber = 0;\n  #initialized = false;\n  _sizeHandlerTimeout;\n\n  constructor(options) {\n    super();\n    this.opts = options;\n\n    this.on('_idle', this._requestsHandler);\n    this.on('validateSize', this._sizeHandler);\n    this._sizeHandler();\n  }\n\n  //*****************************************************************\n  // pool automatic handlers\n  //*****************************************************************\n\n  _doCreateConnection(resolve, reject, timeoutEnd) {\n    this._createConnection()\n      .then((conn) => {\n        if (this.#closed) {\n          conn.forceEnd(\n            null,\n            () => {},\n            () => {}\n          );\n          reject(\n            new Errors.createFatalError(\n              'Cannot create new connection to pool, pool closed',\n              Errors.ER_ADD_CONNECTION_CLOSED_POOL\n            )\n          );\n          return;\n        }\n\n        conn.lastUse = Date.now();\n        const nativeDestroy = conn.destroy.bind(conn);\n        const pool = this;\n\n        conn.destroy = function () {\n          pool._endLeak(conn);\n          delete pool.#activeConnections[conn.threadId];\n          nativeDestroy();\n          pool.emit('validateSize');\n        };\n\n        conn.once('error', function () {\n          let idx = 0;\n          let currConn;\n          pool._endLeak(conn);\n          delete pool.#activeConnections[conn.threadId];\n          while ((currConn = pool.#idleConnections.peekAt(idx))) {\n            if (currConn === conn) {\n              pool.#idleConnections.removeOne(idx);\n              continue;\n            }\n            //since connection did have an error, other waiting connection might too\n            //force validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n            currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool.opts.minDelayValidation);\n            idx++;\n          }\n          setTimeout(() => {\n            if (!pool.#requests.isEmpty()) {\n              pool._sizeHandler();\n            }\n          }, 0);\n        });\n\n        this.#idleConnections.push(conn);\n        this.#connectionInCreation = false;\n        this.emit('_idle');\n        this.emit('connection', conn);\n        resolve(conn);\n      })\n      .catch((err) => {\n        //if timeout is reached or authentication fail return error\n        if (err instanceof AggregateError) {\n          err = err.errors[0];\n        }\n        if (\n          this.#closed ||\n          (err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698)) ||\n          timeoutEnd < Date.now()\n        ) {\n          err.message = err.message + this._errorMsgAddon();\n          reject(err);\n          return;\n        }\n        setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);\n      });\n  }\n\n  _destroy(conn) {\n    this._endLeak(conn);\n    delete this.#activeConnections[conn.threadId];\n    conn.lastUse = Date.now();\n    conn.forceEnd(\n      null,\n      () => {},\n      () => {}\n    );\n\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n\n    this.emit('validateSize');\n  }\n\n  release(conn) {\n    // ensure releasing only once\n    if (this.#activeConnections[conn.threadId]) {\n      this._endLeak(conn);\n      this.#activeConnections[conn.threadId] = null;\n      conn.lastUse = Date.now();\n\n      if (this.#closed) {\n        conn.forceEnd(\n          null,\n          () => {},\n          () => {}\n        );\n      } else if (conn.isValid()) {\n        this.emit('release', conn);\n        this.#idleConnections.push(conn);\n        process.nextTick(this.emit.bind(this, '_idle'));\n      } else {\n        this.emit('validateSize');\n      }\n    }\n  }\n\n  _checkLeak(conn) {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(\n      (conn) => {\n        conn.leaked = true;\n        conn.opts.logger.warning(\n          `A possible connection leak on the thread ${\n            conn.info.threadId\n          } (the connection not returned to the pool since ${\n            Date.now() - conn.lastUse\n          } ms). Has the connection.release() been called ?` + this._errorMsgAddon()\n        );\n      },\n      this.opts.leakDetectionTimeout,\n      conn\n    );\n  }\n\n  _endLeak(conn) {\n    if (conn.leakProcess) {\n      clearTimeout(conn.leakProcess);\n      conn.leakProcess = null;\n      if (conn.leaked) {\n        conn.opts.logger.warning(\n          `Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`\n        );\n      }\n    }\n  }\n\n  /**\n   * Permit to remove idle connection if unused for some time.\n   */\n  _startReaping() {\n    if (!this.#unusedConnectionRemoverId && this.opts.idleTimeout > 0) {\n      this.#unusedConnectionRemoverId = setInterval(this._reaper.bind(this), 500);\n    }\n  }\n\n  _stopReaping() {\n    if (this.#unusedConnectionRemoverId && this.totalConnections() === 0) {\n      clearInterval(this.#unusedConnectionRemoverId);\n    }\n  }\n\n  _reaper() {\n    const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1000;\n    let maxRemoval = Math.max(0, this.#idleConnections.length - this.opts.minimumIdle);\n    while (maxRemoval > 0) {\n      const conn = this.#idleConnections.peek();\n      maxRemoval--;\n      if (conn && conn.lastUse < idleTimeRemoval) {\n        this.#idleConnections.shift();\n        conn.forceEnd(\n          null,\n          () => {},\n          () => {}\n        );\n        continue;\n      }\n      break;\n    }\n\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n\n  _shouldCreateMoreConnections() {\n    return (\n      !this.#connectionInCreation &&\n      this.#idleConnections.length < this.opts.minimumIdle &&\n      this.totalConnections() < this.opts.connectionLimit &&\n      !this.#closed\n    );\n  }\n\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n  _sizeHandler() {\n    if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {\n      this.#connectionInCreation = true;\n      setImmediate(\n        function () {\n          const timeoutEnd = Date.now() + this.opts.initializationTimeout;\n          new Promise((resolve, reject) => {\n            this._doCreateConnection(resolve, reject, timeoutEnd);\n          })\n            .then(() => {\n              this.#initialized = true;\n              this.#errorCreatingConnection = null;\n              this.#connErrorNumber = 0;\n              if (this._shouldCreateMoreConnections()) {\n                this.emit('validateSize');\n              }\n              this._startReaping();\n            })\n            .catch((err) => {\n              this.#connectionInCreation = false;\n              if (!this.#closed) {\n                if (!this.#initialized) {\n                  err.message = 'Error during pool initialization: ' + err.message;\n                } else {\n                  err.message = 'Pool fails to create connection: ' + err.message;\n                }\n                this.#errorCreatingConnection = err;\n                this.emit('error', err);\n\n                //delay next try\n                this._sizeHandlerTimeout = setTimeout(\n                  function () {\n                    this._sizeHandlerTimeout = null;\n                    if (!this.#requests.isEmpty()) {\n                      this._sizeHandler();\n                    }\n                  }.bind(this),\n                  Math.min(++this.#connErrorNumber * 500, 10000)\n                );\n              }\n            });\n        }.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Launch next waiting task request if available connections.\n   */\n  _requestsHandler() {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    const request = this.#requests.shift();\n    if (request) {\n      const conn = this.#idleConnections.shift();\n      if (conn) {\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        this.emit('acquire', conn);\n        this.#activeConnections[conn.threadId] = conn;\n        request.resolver(conn);\n      } else {\n        this.#requests.unshift(request);\n      }\n      this._requestTimeoutHandler();\n    }\n  }\n\n  _hasIdleConnection() {\n    return !this.#idleConnections.isEmpty();\n  }\n\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @returns {Promise<Connection>} connection of null of no valid idle connection.\n   */\n  async _doAcquire() {\n    if (!this._hasIdleConnection() || this.#closed) return Promise.reject();\n    let conn;\n    let mustRecheckSize = false;\n    while ((conn = this.#idleConnections.shift()) != null) {\n      //just check connection state first\n      if (conn.isValid()) {\n        this.#activeConnections[conn.threadId] = conn;\n        //if not used for some time, validate connection with a COM_PING\n        if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {\n          try {\n            const cmdParam = new CommandParameter(null, null, { timeout: this.opts.pingTimeout });\n            await new Promise(conn.ping.bind(conn, cmdParam));\n          } catch (e) {\n            delete this.#activeConnections[conn.threadId];\n            continue;\n          }\n        }\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        if (mustRecheckSize) setImmediate(this.emit.bind(this, 'validateSize'));\n        return Promise.resolve(conn);\n      }\n      mustRecheckSize = true;\n    }\n    setImmediate(this.emit.bind(this, 'validateSize'));\n    return Promise.reject();\n  }\n\n  _requestTimeoutHandler() {\n    //handle next Timer\n    this.#requestTimeoutId = null;\n    const currTime = Date.now();\n    let request;\n    while ((request = this.#requests.peekFront())) {\n      if (request.timeout <= currTime) {\n        this.#requests.shift();\n\n        let cause = this.activeConnections() === 0 ? this.#errorCreatingConnection : null;\n        let err = Errors.createError(\n          `retrieve connection from pool timeout after ${Math.abs(\n            Date.now() - (request.timeout - this.opts.acquireTimeout)\n          )}ms${this._errorMsgAddon()}`,\n          Errors.ER_GET_CONNECTION_TIMEOUT,\n          null,\n          'HY000',\n          null,\n          false,\n          request.stack,\n          null,\n          cause\n        );\n\n        request.reject(err);\n      } else {\n        this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n  _searchInfo() {\n    let info = null;\n    let conn = this.#idleConnections.get(0);\n\n    if (!conn) {\n      for (const threadId in Object.keys(this.#activeConnections)) {\n        conn = this.#activeConnections[threadId];\n        if (!conn) {\n          break;\n        }\n      }\n    }\n\n    if (conn) {\n      info = conn.info;\n    }\n    return info;\n  }\n\n  async _createConnection() {\n    const conn = new Connection(this.opts.connOptions);\n    await conn.connect();\n    const pool = this;\n    conn.forceEnd = conn.end;\n    conn.release = function (resolve) {\n      if (pool.#closed || !conn.isValid()) {\n        pool._destroy(conn);\n        resolve();\n        return;\n      }\n      if (pool.opts.noControlAfterUse) {\n        pool.release(conn);\n        resolve();\n        return;\n      }\n      //if server permit it, reset the connection, or rollback only if not\n      // COM_RESET_CONNECTION exist since mysql 5.7.3 and mariadb 10.2.4\n      // but not possible to use it with mysql waiting for https://bugs.mysql.com/bug.php?id=97633 correction.\n      // and mariadb only since https://jira.mariadb.org/browse/MDEV-18281\n      let revertFunction;\n      if (\n        pool.opts.resetAfterUse &&\n        conn.info.isMariaDB() &&\n        ((conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22)) ||\n          conn.info.hasMinVersion(10, 3, 13))\n      ) {\n        revertFunction = conn.reset.bind(conn, new CommandParameter());\n      } else revertFunction = conn.changeTransaction.bind(conn, new CommandParameter('ROLLBACK'));\n\n      new Promise(revertFunction).then(pool.release.bind(pool, conn), pool._destroy.bind(pool, conn)).finally(resolve);\n    };\n    conn.end = conn.release;\n    return conn;\n  }\n\n  _leakedConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection && connection.leaked) counter++;\n    }\n    return counter;\n  }\n\n  _errorMsgAddon() {\n    if (this.opts.leakDetectionTimeout > 0) {\n      return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${\n        this.opts.connectionLimit\n      })`;\n    }\n    return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${\n      this.opts.connectionLimit\n    })`;\n  }\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  get closed() {\n    return this.#closed;\n  }\n\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n  totalConnections() {\n    return this.activeConnections() + this.idleConnections();\n  }\n\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n  activeConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection) counter++;\n    }\n    return counter;\n  }\n\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n  idleConnections() {\n    return this.#idleConnections.length;\n  }\n\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n  taskQueueSize() {\n    return this.#requests.length;\n  }\n\n  escape(value) {\n    return Utils.escape(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  escapeId(value) {\n    return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  //*****************************************************************\n  // promise methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   * @param cmdParam for stackTrace error\n   * @return {Promise}\n   */\n  getConnection(cmdParam) {\n    if (this.#closed) {\n      return Promise.reject(\n        Errors.createError(\n          'pool is closed',\n          Errors.ER_POOL_ALREADY_CLOSED,\n          null,\n          'HY000',\n          cmdParam === null ? null : cmdParam.sql,\n          false,\n          cmdParam.stack\n        )\n      );\n    }\n    return this._doAcquire().then(\n      (conn) => {\n        // connection is available. process task\n        this.emit('acquire', conn);\n        return conn;\n      },\n      () => {\n        if (this.#closed) {\n          throw Errors.createError(\n            'Cannot add request to pool, pool is closed',\n            Errors.ER_POOL_ALREADY_CLOSED,\n            null,\n            'HY000',\n            cmdParam === null ? null : cmdParam.sql,\n            false,\n            cmdParam.stack\n          );\n        }\n        // no idle connection available\n        // create a new connection if limit is not reached\n        setImmediate(this.emit.bind(this, 'validateSize'));\n        return new Promise(\n          function (resolver, rejecter) {\n            // stack request\n            setImmediate(this.emit.bind(this, 'enqueue'));\n            const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);\n            this.#requests.push(request);\n            if (!this.#requestTimeoutId) {\n              this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout);\n            }\n          }.bind(this)\n        );\n      }\n    );\n  }\n\n  /**\n   * Close all connection in pool\n   * Ends in multiple step :\n   * - close idle connections\n   * - ensure that no new request is possible\n   *   (active connection release are automatically closed on release)\n   * - if remaining, after 10 seconds, close remaining active connections\n   *\n   * @return Promise\n   */\n  end() {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is already closed', Errors.ER_POOL_ALREADY_CLOSED));\n    }\n    this.#closed = true;\n    clearInterval(this.#unusedConnectionRemoverId);\n    clearInterval(this._sizeHandlerTimeout);\n    const cmdParam = new CommandParameter();\n    if (this.opts.trace) Error.captureStackTrace(cmdParam);\n    //close unused connections\n    const idleConnectionsEndings = [];\n    let conn;\n    while ((conn = this.#idleConnections.shift())) {\n      idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));\n    }\n\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n\n    //reject all waiting task\n    if (!this.#requests.isEmpty()) {\n      const err = Errors.createError(\n        'pool is ending, connection request aborted',\n        Errors.ER_CLOSING_POOL,\n        null,\n        'HY000',\n        null,\n        false,\n        cmdParam.stack\n      );\n      let task;\n      while ((task = this.#requests.shift())) {\n        task.reject(err);\n      }\n    }\n    const pool = this;\n    return Promise.all(idleConnectionsEndings).then(async () => {\n      if (pool.activeConnections() > 0) {\n        // wait up to 10 seconds, that active connection are released\n        let remaining = 100;\n        while (remaining-- > 0) {\n          if (pool.activeConnections() > 0) {\n            await new Promise((res) => setTimeout(() => res(), 100));\n          }\n        }\n\n        // force close any remaining active connections\n        for (const connection of Object.values(pool.#activeConnections)) {\n          if (connection) connection.destroy();\n        }\n      }\n      return Promise.resolve();\n    });\n  }\n}\n\nclass Request {\n  constructor(timeout, stack, resolver, rejecter) {\n    this.timeout = timeout;\n    this.stack = stack;\n    this.resolver = resolver;\n    this.rejecter = rejecter;\n  }\n\n  reject(err) {\n    process.nextTick(this.rejecter, err);\n  }\n}\n\nmodule.exports = Pool;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Parser = require('./parser');\nconst Errors = require('../misc/errors');\nconst BinaryEncoder = require('./encoder/binary-encoder');\nconst FieldType = require('../const/field-type');\nconst OkPacket = require('./class/ok-packet');\n\n/**\n * Protocol COM_STMT_BULK_EXECUTE\n * see : https://mariadb.com/kb/en/library/com_stmt_bulk_execute/\n */\nclass BatchBulk extends Parser {\n  constructor(resolve, reject, connOpts, prepare, cmdParam) {\n    super(resolve, reject, connOpts, cmdParam);\n    this.writeParam = BinaryEncoder.writeParam;\n    this.cmdOpts = cmdParam.opts;\n    this.binary = true;\n    this.prepare = prepare;\n    this.canSkipMeta = true;\n  }\n\n  /**\n   * Send COM_STMT_BULK_EXECUTE\n   *\n   * @param out   output writer\n   * @param opts  connection options\n   * @param info  connection information\n   */\n  start(out, opts, info) {\n    this.info = info;\n    this.values = this.initialValues;\n    if (this.cmdOpts && this.cmdOpts.timeout) {\n      this.bulkPacketNo = 1;\n      this.sending = false;\n      return this.sendCancelled('Cannot use timeout for Batch statement', Errors.ER_TIMEOUT_NOT_SUPPORTED);\n    }\n    this.onPacketReceive = this.readResponsePacket;\n    if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {\n      // using named placeholders, so change values accordingly\n      this.values = [];\n      if (this.initialValues) {\n        for (let r = 0; r < this.initialValues.length; r++) {\n          let val = this.initialValues[r];\n          this.values[r] = new Array(this.prepare.parameterCount);\n          for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {\n            this.values[r][i] = val[this.prepare._placeHolderIndex[i]];\n          }\n        }\n      }\n    } else {\n      this.values = this.initialValues;\n    }\n    if (!this.validateParameters(info)) return;\n    this.sendComStmtBulkExecute(out, opts, info);\n  }\n\n  /**\n   * Set header type\n   * @param value current value\n   * @param parameterCount parameter number\n   * @returns {*[]} header type array\n   */\n  parameterHeaderFromValue(value, parameterCount) {\n    const parameterHeaderType = new Array(parameterCount);\n\n    // set header type\n    for (let i = 0; i < parameterCount; i++) {\n      const val = value[i];\n      if (val != null) {\n        switch (typeof val) {\n          case 'boolean':\n            parameterHeaderType[i] = FieldType.TINY;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              parameterHeaderType[i] = FieldType.NEWDECIMAL;\n            } else {\n              parameterHeaderType[i] = FieldType.BIGINT;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              parameterHeaderType[i] = FieldType.INT;\n              break;\n            }\n            parameterHeaderType[i] = FieldType.DOUBLE;\n            break;\n          case 'string':\n            parameterHeaderType[i] = FieldType.VAR_STRING;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              parameterHeaderType[i] = FieldType.TIMESTAMP;\n            } else if (Buffer.isBuffer(val)) {\n              parameterHeaderType[i] = FieldType.BLOB;\n            } else if (typeof val.toSqlString === 'function') {\n              parameterHeaderType[i] = FieldType.VAR_STRING;\n            } else {\n              if (val.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(val.type)) {\n                parameterHeaderType[i] = FieldType.BLOB;\n              } else {\n                parameterHeaderType[i] = FieldType.VAR_STRING;\n              }\n            }\n            break;\n          default:\n            parameterHeaderType[i] = FieldType.BLOB;\n            break;\n        }\n      } else {\n        parameterHeaderType[i] = FieldType.VAR_STRING;\n      }\n    }\n    return parameterHeaderType;\n  }\n\n  /**\n   * Check current value has same header than set in initial BULK header\n   *\n   * @param parameterHeaderType current header\n   * @param value current value\n   * @param parameterCount number of parameter\n   * @returns {boolean} true if identical\n   */\n  checkSameHeader(parameterHeaderType, value, parameterCount) {\n    // set header type\n    let val;\n    for (let i = 0; i < parameterCount; i++) {\n      if ((val = value[i]) != null) {\n        switch (typeof val) {\n          case 'boolean':\n            if (parameterHeaderType[i] !== FieldType.TINY) return false;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (parameterHeaderType[i] !== FieldType.BIGINT) return false;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              if (parameterHeaderType[i] !== FieldType.INT) return false;\n              break;\n            }\n            if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;\n            break;\n          case 'string':\n            if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;\n            } else if (Buffer.isBuffer(val)) {\n              if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            } else if (typeof val.toSqlString === 'function') {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (val.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(val.type)) {\n                if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n              } else {\n                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n              }\n            }\n            break;\n          default:\n            if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            break;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Send a COM_STMT_BULK_EXECUTE\n   * @param out output packet writer\n   * @param opts options\n   * @param info information\n   */\n  sendComStmtBulkExecute(out, opts, info) {\n    if (opts.logger.query) opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logParam ? this.displaySql() : this.sql}`);\n    const parameterCount = this.prepare.parameterCount;\n    this.rowIdx = 0;\n    this.vals = this.values[this.rowIdx++];\n    let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n    let lastCmdData = null;\n    this.bulkPacketNo = 0;\n    this.sending = true;\n\n    /**\n     * Implementation After writing a bunch of parameter to buffer is marked. then : - when writing\n     * next bunch of parameter, if buffer grow more than max_allowed_packet, send buffer up to mark,\n     * then create a new packet with current bunch of data - if a bunch of parameter data type changes\n     * send buffer up to mark, then create a new packet with new data type.\n     *\n     * <p>Problem remains if a bunch of parameter is bigger than max_allowed_packet\n     */\n    main_loop: while (true) {\n      this.bulkPacketNo++;\n      out.startPacket(this);\n      out.writeInt8(0xfa); // COM_STMT_BULK_EXECUTE\n      out.writeInt32(this.prepare.id); // Statement id\n      out.writeInt16(128); // always SEND_TYPES_TO_SERVER\n\n      for (let i = 0; i < parameterCount; i++) {\n        out.writeInt16(parameterHeaderType[i]);\n      }\n      if (lastCmdData != null) {\n        const err = out.checkMaxAllowedLength(lastCmdData.length, info);\n        if (err) {\n          this.throwError(err, info);\n          return;\n        }\n        out.writeBuffer(lastCmdData, 0, lastCmdData.length);\n        out.mark();\n        lastCmdData = null;\n        if (this.rowIdx >= this.values.length) {\n          break;\n        }\n        this.vals = this.values[this.rowIdx++];\n      }\n      parameter_loop: while (true) {\n        for (let i = 0; i < parameterCount; i++) {\n          let param = this.vals[i];\n          if (param != null) {\n            // special check for GEOJSON that can be null even if object is not\n            if (param.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(param.type)) {\n              const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);\n              if (geoBuff == null) {\n                out.writeInt8(0x01); // value is null\n              } else {\n                out.writeInt8(0x00); // value follow\n                param = Buffer.concat([Buffer.from([0, 0, 0, 0]),\n                // SRID\n                geoBuff // WKB\n                ]);\n                this.writeParam(out, param, this.opts, info);\n              }\n            } else {\n              out.writeInt8(0x00); // value follow\n              this.writeParam(out, param, this.opts, info);\n            }\n          } else {\n            out.writeInt8(0x01); // value is null\n          }\n        }\n        if (!out.bufIsDataAfterMark() && !out.isMarked() && out.hasFlushed()) {\n          // parameter were too big to fit in a MySQL packet\n          // need to finish the packet separately\n          out.flush();\n          if (!this.rowIdx >= this.values.length) {\n            break main_loop;\n          }\n          this.vals = this.values[this.rowIdx++];\n\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n        if (out.isMarked() && out.bufIsAfterMaxPacketLength()) {\n          // for max_allowed_packet < 16Mb\n          // packet length was ok at last mark, but won't with new data\n          out.flushBufferStopAtMark();\n          out.mark();\n          lastCmdData = out.resetMark();\n          break;\n        }\n        out.mark();\n        if (out.bufIsDataAfterMark()) {\n          // flush has been done\n          lastCmdData = out.resetMark();\n          break;\n        }\n        if (this.rowIdx >= this.values.length) {\n          break main_loop;\n        }\n        this.vals = this.values[this.rowIdx++];\n\n        // ensure type has not changed\n        if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {\n          out.flush();\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n      }\n    }\n    out.flush();\n    this.sending = false;\n    this.emit('send_end');\n  }\n  displaySql() {\n    if (this.sql.length > this.opts.debugLen) {\n      return this.sql.substring(0, this.opts.debugLen) + '...';\n    }\n    let sqlMsg = this.sql + ' - parameters:[';\n    for (let i = 0; i < this.initialValues.length; i++) {\n      if (i !== 0) sqlMsg += ',';\n      let param = this.initialValues[i];\n      sqlMsg = Parser.logParameters(this.opts, sqlMsg, param);\n      if (sqlMsg.length > this.opts.debugLen) {\n        return sqlMsg.substring(0, this.opts.debugLen) + '...';\n      }\n    }\n    sqlMsg += ']';\n    return sqlMsg;\n  }\n  success(val) {\n    this.bulkPacketNo--;\n\n    // fast path doesn't push OkPacket if ony one results\n    if (this._responseIndex === 0) {\n      if (this.opts.metaAsArray) {\n        if (val[0] instanceof OkPacket) this._rows.push(val[0]);\n      } else if (val instanceof OkPacket) this._rows.push(val);\n    }\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.packet = null;\n      if (this.firstError) {\n        this.resolve = null;\n        this.onPacketReceive = null;\n        this._columns = null;\n        this._rows = null;\n        process.nextTick(this.reject, this.firstError);\n        this.reject = null;\n        this.emit('end', this.firstError);\n      } else {\n        if (this._rows[0].affectedRows !== undefined) {\n          // ok packets, reassemble them if needed\n          let totalAffectedRows = 0;\n          this._rows.forEach(row => {\n            totalAffectedRows += row.affectedRows;\n          });\n          const rs = new OkPacket(totalAffectedRows, this._rows[0].insertId, this._rows[this._rows.length - 1].warningStatus);\n          this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);\n        } else {\n          if (this._rows.length === 1) {\n            this.successEnd(this.opts.metaAsArray ? [this._rows[0], this._columns] : this._rows[0]);\n          }\n          if (this.opts.metaAsArray) {\n            if (this._rows.length === 1) {\n              this.successEnd([this._rows[0], this._columns]);\n            } else {\n              const rs = [];\n              this._rows.forEach(row => {\n                rs.push(...row);\n              });\n              this.successEnd([rs, this._columns]);\n            }\n          } else {\n            // insert with returning\n            if (this._rows.length === 1) {\n              this.successEnd(this._rows[0]);\n            } else {\n              const rs = [];\n              this._rows.forEach(row => {\n                rs.push(...row);\n              });\n              Object.defineProperty(rs, 'meta', {\n                value: this._columns,\n                writable: true,\n                enumerable: this.opts.metaEnumerable\n              });\n              this.successEnd(rs);\n            }\n          }\n        }\n        this._columns = null;\n        this._rows = null;\n      }\n      return;\n    }\n    if (!this.firstError) {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n  throwError(err, info) {\n    this.bulkPacketNo--;\n    if (!this.firstError) {\n      if (err.fatal) {\n        this.bulkPacketNo = 0;\n      }\n      if (this.cmdParam.stack) {\n        err = Errors.createError(err.message, err.errno, info, err.sqlState, this.sql, err.fatal, this.cmdParam.stack, false);\n      }\n      this.firstError = err;\n    }\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.resolve = null;\n      this.emit('send_end');\n      process.nextTick(this.reject, this.firstError);\n      this.reject = null;\n      this.onPacketReceive = null;\n      this.emit('end', this.firstError);\n    } else {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  /**\n   * Validate that parameters exists and are defined.\n   *\n   * @param info        connection info\n   * @returns {boolean} return false if any error occur.\n   */\n  validateParameters(info) {\n    //validate parameter size.\n    const nbParameter = this.prepare.parameterCount;\n    for (let r = 0; r < this.values.length; r++) {\n      if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];\n\n      //validate parameter is defined.\n      if (this.values[r].length < nbParameter) {\n        this.emit('send_end');\n        this.throwNewError(`Expect ${nbParameter} parameters, but at index ${r}, parameters only contains ${this.values[r].length}\\n ${this.opts.logParam ? this.displaySql() : this.sql}`, false, info, 'HY000', Errors.ER_PARAMETER_UNDEFINED);\n        return false;\n      }\n    }\n    return true;\n  }\n}\nmodule.exports = BatchBulk;","map":{"version":3,"names":["Parser","require","Errors","BinaryEncoder","FieldType","OkPacket","BatchBulk","constructor","resolve","reject","connOpts","prepare","cmdParam","writeParam","cmdOpts","opts","binary","canSkipMeta","start","out","info","values","initialValues","timeout","bulkPacketNo","sending","sendCancelled","ER_TIMEOUT_NOT_SUPPORTED","onPacketReceive","readResponsePacket","namedPlaceholders","_placeHolderIndex","r","length","val","Array","parameterCount","i","validateParameters","sendComStmtBulkExecute","parameterHeaderFromValue","value","parameterHeaderType","TINY","NEWDECIMAL","BIGINT","Number","isSafeInteger","INT","DOUBLE","VAR_STRING","Date","TIMESTAMP","Buffer","isBuffer","BLOB","toSqlString","type","includes","checkSameHeader","logger","query","id","logParam","displaySql","sql","rowIdx","vals","lastCmdData","main_loop","startPacket","writeInt8","writeInt32","writeInt16","err","checkMaxAllowedLength","throwError","writeBuffer","mark","parameter_loop","param","geoBuff","getBufferFromGeometryValue","concat","from","bufIsDataAfterMark","isMarked","hasFlushed","flush","bufIsAfterMaxPacketLength","flushBufferStopAtMark","resetMark","emit","debugLen","substring","sqlMsg","logParameters","success","_responseIndex","metaAsArray","_rows","push","packet","firstError","_columns","process","nextTick","affectedRows","undefined","totalAffectedRows","forEach","row","rs","insertId","warningStatus","successEnd","Object","defineProperty","writable","enumerable","metaEnumerable","fatal","stack","createError","message","errno","sqlState","nbParameter","isArray","throwNewError","ER_PARAMETER_UNDEFINED","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cmd/batch-bulk.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Parser = require('./parser');\nconst Errors = require('../misc/errors');\nconst BinaryEncoder = require('./encoder/binary-encoder');\nconst FieldType = require('../const/field-type');\nconst OkPacket = require('./class/ok-packet');\n\n/**\n * Protocol COM_STMT_BULK_EXECUTE\n * see : https://mariadb.com/kb/en/library/com_stmt_bulk_execute/\n */\nclass BatchBulk extends Parser {\n  constructor(resolve, reject, connOpts, prepare, cmdParam) {\n    super(resolve, reject, connOpts, cmdParam);\n    this.writeParam = BinaryEncoder.writeParam;\n    this.cmdOpts = cmdParam.opts;\n    this.binary = true;\n    this.prepare = prepare;\n    this.canSkipMeta = true;\n  }\n\n  /**\n   * Send COM_STMT_BULK_EXECUTE\n   *\n   * @param out   output writer\n   * @param opts  connection options\n   * @param info  connection information\n   */\n  start(out, opts, info) {\n    this.info = info;\n    this.values = this.initialValues;\n\n    if (this.cmdOpts && this.cmdOpts.timeout) {\n      this.bulkPacketNo = 1;\n      this.sending = false;\n      return this.sendCancelled('Cannot use timeout for Batch statement', Errors.ER_TIMEOUT_NOT_SUPPORTED);\n    }\n    this.onPacketReceive = this.readResponsePacket;\n    if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {\n      // using named placeholders, so change values accordingly\n      this.values = [];\n      if (this.initialValues) {\n        for (let r = 0; r < this.initialValues.length; r++) {\n          let val = this.initialValues[r];\n          this.values[r] = new Array(this.prepare.parameterCount);\n          for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {\n            this.values[r][i] = val[this.prepare._placeHolderIndex[i]];\n          }\n        }\n      }\n    } else {\n      this.values = this.initialValues;\n    }\n\n    if (!this.validateParameters(info)) return;\n\n    this.sendComStmtBulkExecute(out, opts, info);\n  }\n\n  /**\n   * Set header type\n   * @param value current value\n   * @param parameterCount parameter number\n   * @returns {*[]} header type array\n   */\n  parameterHeaderFromValue(value, parameterCount) {\n    const parameterHeaderType = new Array(parameterCount);\n\n    // set header type\n    for (let i = 0; i < parameterCount; i++) {\n      const val = value[i];\n      if (val != null) {\n        switch (typeof val) {\n          case 'boolean':\n            parameterHeaderType[i] = FieldType.TINY;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              parameterHeaderType[i] = FieldType.NEWDECIMAL;\n            } else {\n              parameterHeaderType[i] = FieldType.BIGINT;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              parameterHeaderType[i] = FieldType.INT;\n              break;\n            }\n            parameterHeaderType[i] = FieldType.DOUBLE;\n            break;\n          case 'string':\n            parameterHeaderType[i] = FieldType.VAR_STRING;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              parameterHeaderType[i] = FieldType.TIMESTAMP;\n            } else if (Buffer.isBuffer(val)) {\n              parameterHeaderType[i] = FieldType.BLOB;\n            } else if (typeof val.toSqlString === 'function') {\n              parameterHeaderType[i] = FieldType.VAR_STRING;\n            } else {\n              if (\n                val.type != null &&\n                [\n                  'Point',\n                  'LineString',\n                  'Polygon',\n                  'MultiPoint',\n                  'MultiLineString',\n                  'MultiPolygon',\n                  'GeometryCollection'\n                ].includes(val.type)\n              ) {\n                parameterHeaderType[i] = FieldType.BLOB;\n              } else {\n                parameterHeaderType[i] = FieldType.VAR_STRING;\n              }\n            }\n            break;\n          default:\n            parameterHeaderType[i] = FieldType.BLOB;\n            break;\n        }\n      } else {\n        parameterHeaderType[i] = FieldType.VAR_STRING;\n      }\n    }\n    return parameterHeaderType;\n  }\n\n  /**\n   * Check current value has same header than set in initial BULK header\n   *\n   * @param parameterHeaderType current header\n   * @param value current value\n   * @param parameterCount number of parameter\n   * @returns {boolean} true if identical\n   */\n  checkSameHeader(parameterHeaderType, value, parameterCount) {\n    // set header type\n    let val;\n    for (let i = 0; i < parameterCount; i++) {\n      if ((val = value[i]) != null) {\n        switch (typeof val) {\n          case 'boolean':\n            if (parameterHeaderType[i] !== FieldType.TINY) return false;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (parameterHeaderType[i] !== FieldType.BIGINT) return false;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              if (parameterHeaderType[i] !== FieldType.INT) return false;\n              break;\n            }\n            if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;\n            break;\n          case 'string':\n            if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;\n            } else if (Buffer.isBuffer(val)) {\n              if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            } else if (typeof val.toSqlString === 'function') {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (\n                val.type != null &&\n                [\n                  'Point',\n                  'LineString',\n                  'Polygon',\n                  'MultiPoint',\n                  'MultiLineString',\n                  'MultiPolygon',\n                  'GeometryCollection'\n                ].includes(val.type)\n              ) {\n                if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n              } else {\n                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n              }\n            }\n            break;\n          default:\n            if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            break;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Send a COM_STMT_BULK_EXECUTE\n   * @param out output packet writer\n   * @param opts options\n   * @param info information\n   */\n  sendComStmtBulkExecute(out, opts, info) {\n    if (opts.logger.query)\n      opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logParam ? this.displaySql() : this.sql}`);\n    const parameterCount = this.prepare.parameterCount;\n    this.rowIdx = 0;\n    this.vals = this.values[this.rowIdx++];\n    let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n    let lastCmdData = null;\n    this.bulkPacketNo = 0;\n    this.sending = true;\n\n    /**\n     * Implementation After writing a bunch of parameter to buffer is marked. then : - when writing\n     * next bunch of parameter, if buffer grow more than max_allowed_packet, send buffer up to mark,\n     * then create a new packet with current bunch of data - if a bunch of parameter data type changes\n     * send buffer up to mark, then create a new packet with new data type.\n     *\n     * <p>Problem remains if a bunch of parameter is bigger than max_allowed_packet\n     */\n    main_loop: while (true) {\n      this.bulkPacketNo++;\n      out.startPacket(this);\n      out.writeInt8(0xfa); // COM_STMT_BULK_EXECUTE\n      out.writeInt32(this.prepare.id); // Statement id\n      out.writeInt16(128); // always SEND_TYPES_TO_SERVER\n\n      for (let i = 0; i < parameterCount; i++) {\n        out.writeInt16(parameterHeaderType[i]);\n      }\n\n      if (lastCmdData != null) {\n        const err = out.checkMaxAllowedLength(lastCmdData.length, info);\n        if (err) {\n          this.throwError(err, info);\n          return;\n        }\n        out.writeBuffer(lastCmdData, 0, lastCmdData.length);\n        out.mark();\n        lastCmdData = null;\n        if (this.rowIdx >= this.values.length) {\n          break;\n        }\n        this.vals = this.values[this.rowIdx++];\n      }\n\n      parameter_loop: while (true) {\n        for (let i = 0; i < parameterCount; i++) {\n          let param = this.vals[i];\n          if (param != null) {\n            // special check for GEOJSON that can be null even if object is not\n            if (\n              param.type != null &&\n              [\n                'Point',\n                'LineString',\n                'Polygon',\n                'MultiPoint',\n                'MultiLineString',\n                'MultiPolygon',\n                'GeometryCollection'\n              ].includes(param.type)\n            ) {\n              const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);\n              if (geoBuff == null) {\n                out.writeInt8(0x01); // value is null\n              } else {\n                out.writeInt8(0x00); // value follow\n                param = Buffer.concat([\n                  Buffer.from([0, 0, 0, 0]), // SRID\n                  geoBuff // WKB\n                ]);\n                this.writeParam(out, param, this.opts, info);\n              }\n            } else {\n              out.writeInt8(0x00); // value follow\n              this.writeParam(out, param, this.opts, info);\n            }\n          } else {\n            out.writeInt8(0x01); // value is null\n          }\n        }\n\n        if (!out.bufIsDataAfterMark() && !out.isMarked() && out.hasFlushed()) {\n          // parameter were too big to fit in a MySQL packet\n          // need to finish the packet separately\n          out.flush();\n          if (!this.rowIdx >= this.values.length) {\n            break main_loop;\n          }\n          this.vals = this.values[this.rowIdx++];\n\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n\n        if (out.isMarked() && out.bufIsAfterMaxPacketLength()) {\n          // for max_allowed_packet < 16Mb\n          // packet length was ok at last mark, but won't with new data\n          out.flushBufferStopAtMark();\n          out.mark();\n          lastCmdData = out.resetMark();\n          break;\n        }\n\n        out.mark();\n\n        if (out.bufIsDataAfterMark()) {\n          // flush has been done\n          lastCmdData = out.resetMark();\n          break;\n        }\n\n        if (this.rowIdx >= this.values.length) {\n          break main_loop;\n        }\n\n        this.vals = this.values[this.rowIdx++];\n\n        // ensure type has not changed\n        if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {\n          out.flush();\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n      }\n    }\n    out.flush();\n    this.sending = false;\n    this.emit('send_end');\n  }\n\n  displaySql() {\n    if (this.sql.length > this.opts.debugLen) {\n      return this.sql.substring(0, this.opts.debugLen) + '...';\n    }\n\n    let sqlMsg = this.sql + ' - parameters:[';\n    for (let i = 0; i < this.initialValues.length; i++) {\n      if (i !== 0) sqlMsg += ',';\n      let param = this.initialValues[i];\n      sqlMsg = Parser.logParameters(this.opts, sqlMsg, param);\n      if (sqlMsg.length > this.opts.debugLen) {\n        return sqlMsg.substring(0, this.opts.debugLen) + '...';\n      }\n    }\n    sqlMsg += ']';\n    return sqlMsg;\n  }\n\n  success(val) {\n    this.bulkPacketNo--;\n\n    // fast path doesn't push OkPacket if ony one results\n    if (this._responseIndex === 0) {\n      if (this.opts.metaAsArray) {\n        if (val[0] instanceof OkPacket) this._rows.push(val[0]);\n      } else if (val instanceof OkPacket) this._rows.push(val);\n    }\n\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.packet = null;\n      if (this.firstError) {\n        this.resolve = null;\n        this.onPacketReceive = null;\n        this._columns = null;\n        this._rows = null;\n        process.nextTick(this.reject, this.firstError);\n        this.reject = null;\n        this.emit('end', this.firstError);\n      } else {\n        if (this._rows[0].affectedRows !== undefined) {\n          // ok packets, reassemble them if needed\n          let totalAffectedRows = 0;\n          this._rows.forEach((row) => {\n            totalAffectedRows += row.affectedRows;\n          });\n\n          const rs = new OkPacket(\n            totalAffectedRows,\n            this._rows[0].insertId,\n            this._rows[this._rows.length - 1].warningStatus\n          );\n          this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);\n        } else {\n          if (this._rows.length === 1) {\n            this.successEnd(this.opts.metaAsArray ? [this._rows[0], this._columns] : this._rows[0]);\n          }\n          if (this.opts.metaAsArray) {\n            if (this._rows.length === 1) {\n              this.successEnd([this._rows[0], this._columns]);\n            } else {\n              const rs = [];\n              this._rows.forEach((row) => {\n                rs.push(...row);\n              });\n              this.successEnd([rs, this._columns]);\n            }\n          } else {\n            // insert with returning\n            if (this._rows.length === 1) {\n              this.successEnd(this._rows[0]);\n            } else {\n              const rs = [];\n              this._rows.forEach((row) => {\n                rs.push(...row);\n              });\n              Object.defineProperty(rs, 'meta', {\n                value: this._columns,\n                writable: true,\n                enumerable: this.opts.metaEnumerable\n              });\n              this.successEnd(rs);\n            }\n          }\n        }\n        this._columns = null;\n        this._rows = null;\n      }\n      return;\n    }\n\n    if (!this.firstError) {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  throwError(err, info) {\n    this.bulkPacketNo--;\n    if (!this.firstError) {\n      if (err.fatal) {\n        this.bulkPacketNo = 0;\n      }\n      if (this.cmdParam.stack) {\n        err = Errors.createError(\n          err.message,\n          err.errno,\n          info,\n          err.sqlState,\n          this.sql,\n          err.fatal,\n          this.cmdParam.stack,\n          false\n        );\n      }\n      this.firstError = err;\n    }\n\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.resolve = null;\n      this.emit('send_end');\n      process.nextTick(this.reject, this.firstError);\n      this.reject = null;\n      this.onPacketReceive = null;\n      this.emit('end', this.firstError);\n    } else {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  /**\n   * Validate that parameters exists and are defined.\n   *\n   * @param info        connection info\n   * @returns {boolean} return false if any error occur.\n   */\n  validateParameters(info) {\n    //validate parameter size.\n    const nbParameter = this.prepare.parameterCount;\n    for (let r = 0; r < this.values.length; r++) {\n      if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];\n\n      //validate parameter is defined.\n      if (this.values[r].length < nbParameter) {\n        this.emit('send_end');\n        this.throwNewError(\n          `Expect ${nbParameter} parameters, but at index ${r}, parameters only contains ${this.values[r].length}\\n ${\n            this.opts.logParam ? this.displaySql() : this.sql\n          }`,\n          false,\n          info,\n          'HY000',\n          Errors.ER_PARAMETER_UNDEFINED\n        );\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nmodule.exports = BatchBulk;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
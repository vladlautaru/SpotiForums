{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst ClusterOptions = require('./config/cluster-options');\nconst PoolOptions = require('./config/pool-options');\nconst PoolCallback = require('./pool-callback');\nconst PoolPromise = require('./pool-promise');\nconst FilteredCluster = require('./filtered-cluster');\nconst EventEmitter = require('events');\n\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round-robin / random / ordered )\n *\n * @param args      cluster arguments. see pool-cluster-options.\n * @constructor\n */\nclass Cluster extends EventEmitter {\n  opts;\n  #nodes = {};\n  #cachedPatterns = {};\n  #nodeCounter = 0;\n  constructor(args) {\n    super();\n    this.opts = new ClusterOptions(args);\n  }\n\n  /**\n   * Add a new pool node to cluster.\n   *\n   * @param id      identifier\n   * @param config  pool configuration\n   */\n  add(id, config) {\n    let identifier;\n    if (typeof id === 'string' || id instanceof String) {\n      identifier = id;\n      if (this.#nodes[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);\n    } else {\n      identifier = 'PoolNode-' + this.#nodeCounter++;\n      config = id;\n    }\n    const options = new PoolOptions(config);\n    this.#nodes[identifier] = this._createPool(options);\n  }\n\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @return {Promise<any[]>}\n   */\n  end() {\n    const cluster = this;\n    this.#cachedPatterns = {};\n    const poolEndPromise = [];\n    Object.keys(this.#nodes).forEach(pool => {\n      const res = cluster.#nodes[pool].end();\n      if (res) poolEndPromise.push(res);\n    });\n    this.#nodes = null;\n    return Promise.all(poolEndPromise);\n  }\n  of(pattern, selector) {\n    return new FilteredCluster(this, pattern, selector);\n  }\n\n  /**\n   * Remove nodes according to pattern.\n   *\n   * @param pattern  pattern\n   */\n  remove(pattern) {\n    if (!pattern) throw new Error('pattern parameter in Cluster.remove(pattern)  is mandatory');\n    const regex = RegExp(pattern);\n    Object.keys(this.#nodes).forEach(function (key) {\n      if (regex.test(key)) {\n        this.#nodes[key].end();\n        delete this.#nodes[key];\n        this.#cachedPatterns = {};\n      }\n    }.bind(this));\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @return {Promise}\n   */\n  getConnection(pattern, selector) {\n    return this._getConnection(pattern, selector, undefined, undefined, undefined);\n  }\n\n  /**\n   * Force using callback methods.\n   */\n  _setCallback() {\n    this.getConnection = this._getConnectionCallback;\n    this._createPool = this._createPoolCallback;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @param remainingRetry remaining possible retry\n   * @return {Promise}\n   * @private\n   */\n  _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        return Promise.reject(new Error('No node have been added to cluster or nodes have been removed due to too much connection error'));\n      }\n      if (avoidNodeKey === undefined) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${lastError ? '. Last connection error was: ' + lastError.message : ''}`;\n      return Promise.reject(new Error(errMsg));\n    }\n    if (remainingRetry === undefined) remainingRetry = matchingNodeList.length;\n    const retry = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      return this._handleConnectionError(matchingNodeList, nodeKey, retry);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _createPool(options) {\n    const pool = new PoolPromise(options);\n    pool.on('error', err => {});\n    return pool;\n  }\n  _createPoolCallback(options) {\n    const pool = new PoolCallback(options);\n    pool.on('error', err => {});\n    return pool;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @private\n   */\n  _getConnectionCallback(pattern, selector, callback, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        callback(new Error('No node have been added to cluster or nodes have been removed due to too much connection error'));\n        return;\n      }\n      if (avoidNodeKey === undefined) callback(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${lastError ? '. Last connection error was: ' + lastError.message : ''}`;\n      callback(new Error(errMsg));\n      return;\n    }\n    const retry = this._getConnectionCallback.bind(this, pattern, selector, callback);\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry, callback);\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  /**\n   * Selecting nodes according to pattern.\n   *\n   * @param pattern pattern\n   * @return {*}\n   * @private\n   */\n  _matchingNodes(pattern) {\n    if (this.#cachedPatterns[pattern]) return this.#cachedPatterns[pattern];\n    const regex = RegExp(pattern);\n    const matchingNodeList = [];\n    Object.keys(this.#nodes).forEach(key => {\n      if (regex.test(key)) {\n        matchingNodeList.push(key);\n      }\n    });\n    this.#cachedPatterns[pattern] = matchingNodeList;\n    return matchingNodeList;\n  }\n\n  /**\n   * Select next node to be chosen in nodeList according to selector and failed nodes.\n   *\n   * @param nodeList        current node list\n   * @param selectorParam   selector\n   * @param avoidNodeKey    last failing node to avoid selecting this one.\n   * @return {Promise}\n   * @private\n   */\n  _selectPool(nodeList, selectorParam, avoidNodeKey) {\n    const selector = selectorParam || this.opts.defaultSelector;\n    let selectorFct;\n    switch (selector) {\n      case 'RR':\n        selectorFct = roundRobinSelector;\n        break;\n      case 'RANDOM':\n        selectorFct = randomSelector;\n        break;\n      case 'ORDER':\n        selectorFct = orderedSelector;\n        break;\n      default:\n        throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);\n    }\n    let nodeIdx = 0;\n    let nodeKey = selectorFct(nodeList, nodeIdx);\n    // first loop : search for node not blacklisted AND not the avoided key\n    while ((avoidNodeKey === nodeKey || this.#nodes[nodeKey].blacklistedUntil && this.#nodes[nodeKey].blacklistedUntil > Date.now()) && nodeIdx < nodeList.length - 1) {\n      nodeIdx++;\n      nodeKey = selectorFct(nodeList, nodeIdx);\n    }\n    if (avoidNodeKey === nodeKey) {\n      // second loop, search even in blacklisted node in order to choose a different node than to be avoided\n      nodeIdx = 0;\n      while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {\n        nodeIdx++;\n        nodeKey = selectorFct(nodeList, nodeIdx);\n      }\n    }\n    return nodeKey;\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @return {Promise}\n   * @private\n   */\n  _handleConnectionError(nodeList, nodeKey, retryFct) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    return node.getConnection().then(conn => {\n      node.blacklistedUntil = null;\n      node.errorCount = 0;\n      return Promise.resolve(conn);\n    }).catch(err => {\n      node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n      node.blacklistedUntil = Date.now() + cluster.opts.restoreNodeTimeout;\n      if (cluster.opts.removeNodeErrorCount && node.errorCount >= cluster.opts.removeNodeErrorCount && cluster.#nodes[nodeKey]) {\n        delete cluster.#nodes[nodeKey];\n        cluster.#cachedPatterns = {};\n        delete nodeList.lastRrIdx;\n        setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n        //remove node from configuration if not already removed\n        node.end().catch(err => {\n          // dismiss error\n        });\n      }\n      if (nodeList.length !== 0 && cluster.opts.canRetry && retryFct) {\n        return retryFct(nodeKey, err);\n      }\n      return Promise.reject(err);\n    });\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @param callback    callback function\n   * @private\n   */\n  _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    node.getConnection((err, conn) => {\n      if (err) {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + cluster.opts.restoreNodeTimeout;\n        if (cluster.opts.removeNodeErrorCount && node.errorCount >= cluster.opts.removeNodeErrorCount && cluster.#nodes[nodeKey]) {\n          delete cluster.#nodes[nodeKey];\n          cluster.#cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n          //remove node from configuration if not already removed\n          node.end(() => {\n            //dismiss error\n          });\n        }\n        if (nodeList.length !== 0 && cluster.opts.canRetry && retryFct) {\n          return retryFct(nodeKey, err);\n        }\n        callback(err);\n      } else {\n        node.errorCount = 0;\n        callback(null, conn);\n      }\n    });\n  }\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  get __tests() {\n    return new TestMethods(this.#nodes);\n  }\n}\nclass TestMethods {\n  #nodes;\n  constructor(nodes) {\n    this.#nodes = nodes;\n  }\n  getNodes() {\n    return this.#nodes;\n  }\n}\n\n/**\n * Round robin selector: using nodes one after the other.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst roundRobinSelector = nodeList => {\n  let lastRoundRobin = nodeList.lastRrIdx;\n  if (lastRoundRobin === undefined) lastRoundRobin = -1;\n  if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;\n  nodeList.lastRrIdx = lastRoundRobin;\n  return nodeList[lastRoundRobin];\n};\n\n/**\n * Random selector: use a random node.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst randomSelector = nodeList => {\n  let randomIdx = Math.floor(Math.random() * nodeList.length);\n  return nodeList[randomIdx];\n};\n\n/**\n * Ordered selector: always use the nodes in sequence, unless failing.\n *\n * @param nodeList  node list\n * @param retry     sequence number if last node is tagged has failing\n * @return {String}\n */\nconst orderedSelector = (nodeList, retry) => {\n  return nodeList[retry];\n};\nmodule.exports = Cluster;","map":null,"metadata":{},"sourceType":"script"}
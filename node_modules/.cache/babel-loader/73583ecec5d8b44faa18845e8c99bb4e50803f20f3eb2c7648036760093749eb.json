{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nclass BinaryEncoder {\n  /**\n   * Write (and escape) current parameter value to output writer\n   *\n   * @param out     output writer\n   * @param value   current parameter\n   * @param opts    connection options\n   * @param info    connection information\n   */\n  static writeParam(out, value, opts, info) {\n    // GEOJSON are not checked, because change to null/Buffer on parameter validation\n    switch (typeof value) {\n      case 'boolean':\n        out.writeInt8(value ? 0x01 : 0x00);\n        break;\n      case 'bigint':\n        if (value >= 2n ** 63n) {\n          out.writeLengthEncodedString(value.toString());\n        } else {\n          out.writeBigInt(value);\n        }\n        break;\n      case 'number':\n        // additional verification, to permit query without type,\n        // like 'SELECT ?' returning same type of value\n        if (Number.isSafeInteger(value) && value >= -2147483648 && value < 2147483647) {\n          out.writeInt32(value);\n          break;\n        }\n        out.writeDouble(value);\n        break;\n      case 'string':\n        out.writeLengthEncodedString(value);\n        break;\n      case 'object':\n        if (value instanceof Date) {\n          out.writeBinaryDate(value);\n        } else if (Buffer.isBuffer(value)) {\n          out.writeLengthEncodedBuffer(value);\n        } else if (typeof value.toSqlString === 'function') {\n          out.writeLengthEncodedString(String(value.toSqlString()));\n        } else {\n          out.writeLengthEncodedString(JSON.stringify(value));\n        }\n        break;\n      default:\n        out.writeLengthEncodedBuffer(value);\n    }\n  }\n  static getBufferFromGeometryValue(value, headerType) {\n    let geoBuff;\n    let pos;\n    let type;\n    if (!headerType) {\n      switch (value.type) {\n        case 'Point':\n          geoBuff = Buffer.allocUnsafe(21);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(1, 1); //wkbPoint\n          if (value.coordinates && Array.isArray(value.coordinates) && value.coordinates.length >= 2 && !isNaN(value.coordinates[0]) && !isNaN(value.coordinates[1])) {\n            geoBuff.writeDoubleLE(value.coordinates[0], 5); //X\n            geoBuff.writeDoubleLE(value.coordinates[1], 13); //Y\n            return geoBuff;\n          } else {\n            return null;\n          }\n        case 'LineString':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const pointNumber = value.coordinates.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (value.coordinates[i] && Array.isArray(value.coordinates[i]) && value.coordinates[i].length >= 2 && !isNaN(value.coordinates[i][0]) && !isNaN(value.coordinates[i][1])) {\n                geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n        case 'Polygon':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const numRings = value.coordinates.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value.coordinates[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value.coordinates[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n        case 'MultiPoint':\n          type = 'MultiPoint';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(4, 1); //wkbMultiPoint\n          break;\n        case 'MultiLineString':\n          type = 'MultiLineString';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(5, 1); //wkbMultiLineString\n          break;\n        case 'MultiPolygon':\n          type = 'MultiPolygon';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(6, 1); //wkbMultiPolygon\n          break;\n        case 'GeometryCollection':\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(7, 1); //wkbGeometryCollection\n\n          if (value.geometries && Array.isArray(value.geometries)) {\n            const coordinateLength = value.geometries.length;\n            const subArrays = [geoBuff];\n            for (let i = 0; i < coordinateLength; i++) {\n              const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);\n              if (tmpBuf == null) break;\n              subArrays.push(tmpBuf);\n            }\n            geoBuff.writeInt32LE(subArrays.length - 1, 5);\n            return Buffer.concat(subArrays);\n          } else {\n            geoBuff.writeInt32LE(0, 5);\n            return geoBuff;\n          }\n        default:\n          return null;\n      }\n      if (value.coordinates && Array.isArray(value.coordinates)) {\n        const coordinateLength = value.coordinates.length;\n        const subArrays = [geoBuff];\n        for (let i = 0; i < coordinateLength; i++) {\n          const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type);\n          if (tmpBuf == null) break;\n          subArrays.push(tmpBuf);\n        }\n        geoBuff.writeInt32LE(subArrays.length - 1, 5);\n        return Buffer.concat(subArrays);\n      } else {\n        geoBuff.writeInt32LE(0, 5);\n        return geoBuff;\n      }\n    } else {\n      switch (headerType) {\n        case 'MultiPoint':\n          if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {\n            geoBuff = Buffer.allocUnsafe(21);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(1, 1); //wkbPoint\n            geoBuff.writeDoubleLE(value[0], 5); //X\n            geoBuff.writeDoubleLE(value[1], 13); //Y\n            return geoBuff;\n          }\n          return null;\n        case 'MultiLineString':\n          if (value && Array.isArray(value)) {\n            const pointNumber = value.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (value[i] && Array.isArray(value[i]) && value[i].length >= 2 && !isNaN(value[i][0]) && !isNaN(value[i][1])) {\n                geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n        case 'MultiPolygon':\n          if (value && Array.isArray(value)) {\n            const numRings = value.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n      }\n      return null;\n    }\n  }\n}\nmodule.exports = BinaryEncoder;","map":{"version":3,"names":["BinaryEncoder","writeParam","out","value","opts","info","writeInt8","writeLengthEncodedString","toString","writeBigInt","Number","isSafeInteger","writeInt32","writeDouble","Date","writeBinaryDate","Buffer","isBuffer","writeLengthEncodedBuffer","toSqlString","String","JSON","stringify","getBufferFromGeometryValue","headerType","geoBuff","pos","type","allocUnsafe","writeInt32LE","coordinates","Array","isArray","length","isNaN","writeDoubleLE","pointNumber","i","numRings","size","lineString","j","geometries","coordinateLength","subArrays","tmpBuf","push","concat","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cmd/encoder/binary-encoder.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nclass BinaryEncoder {\n  /**\n   * Write (and escape) current parameter value to output writer\n   *\n   * @param out     output writer\n   * @param value   current parameter\n   * @param opts    connection options\n   * @param info    connection information\n   */\n  static writeParam(out, value, opts, info) {\n    // GEOJSON are not checked, because change to null/Buffer on parameter validation\n    switch (typeof value) {\n      case 'boolean':\n        out.writeInt8(value ? 0x01 : 0x00);\n        break;\n      case 'bigint':\n        if (value >= 2n ** 63n) {\n          out.writeLengthEncodedString(value.toString());\n        } else {\n          out.writeBigInt(value);\n        }\n        break;\n\n      case 'number':\n        // additional verification, to permit query without type,\n        // like 'SELECT ?' returning same type of value\n        if (Number.isSafeInteger(value) && value >= -2147483648 && value < 2147483647) {\n          out.writeInt32(value);\n          break;\n        }\n        out.writeDouble(value);\n        break;\n      case 'string':\n        out.writeLengthEncodedString(value);\n        break;\n      case 'object':\n        if (value instanceof Date) {\n          out.writeBinaryDate(value);\n        } else if (Buffer.isBuffer(value)) {\n          out.writeLengthEncodedBuffer(value);\n        } else if (typeof value.toSqlString === 'function') {\n          out.writeLengthEncodedString(String(value.toSqlString()));\n        } else {\n          out.writeLengthEncodedString(JSON.stringify(value));\n        }\n        break;\n      default:\n        out.writeLengthEncodedBuffer(value);\n    }\n  }\n\n  static getBufferFromGeometryValue(value, headerType) {\n    let geoBuff;\n    let pos;\n    let type;\n    if (!headerType) {\n      switch (value.type) {\n        case 'Point':\n          geoBuff = Buffer.allocUnsafe(21);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(1, 1); //wkbPoint\n          if (\n            value.coordinates &&\n            Array.isArray(value.coordinates) &&\n            value.coordinates.length >= 2 &&\n            !isNaN(value.coordinates[0]) &&\n            !isNaN(value.coordinates[1])\n          ) {\n            geoBuff.writeDoubleLE(value.coordinates[0], 5); //X\n            geoBuff.writeDoubleLE(value.coordinates[1], 13); //Y\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'LineString':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const pointNumber = value.coordinates.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (\n                value.coordinates[i] &&\n                Array.isArray(value.coordinates[i]) &&\n                value.coordinates[i].length >= 2 &&\n                !isNaN(value.coordinates[i][0]) &&\n                !isNaN(value.coordinates[i][1])\n              ) {\n                geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'Polygon':\n          if (value.coordinates && Array.isArray(value.coordinates)) {\n            const numRings = value.coordinates.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value.coordinates[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value.coordinates[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (\n                    lineString[j] &&\n                    Array.isArray(lineString[j]) &&\n                    lineString[j].length >= 2 &&\n                    !isNaN(lineString[j][0]) &&\n                    !isNaN(lineString[j][1])\n                  ) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          } else {\n            return null;\n          }\n\n        case 'MultiPoint':\n          type = 'MultiPoint';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(4, 1); //wkbMultiPoint\n          break;\n\n        case 'MultiLineString':\n          type = 'MultiLineString';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(5, 1); //wkbMultiLineString\n          break;\n\n        case 'MultiPolygon':\n          type = 'MultiPolygon';\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(6, 1); //wkbMultiPolygon\n          break;\n\n        case 'GeometryCollection':\n          geoBuff = Buffer.allocUnsafe(9);\n          geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n          geoBuff.writeInt32LE(7, 1); //wkbGeometryCollection\n\n          if (value.geometries && Array.isArray(value.geometries)) {\n            const coordinateLength = value.geometries.length;\n            const subArrays = [geoBuff];\n            for (let i = 0; i < coordinateLength; i++) {\n              const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);\n              if (tmpBuf == null) break;\n              subArrays.push(tmpBuf);\n            }\n            geoBuff.writeInt32LE(subArrays.length - 1, 5);\n            return Buffer.concat(subArrays);\n          } else {\n            geoBuff.writeInt32LE(0, 5);\n            return geoBuff;\n          }\n        default:\n          return null;\n      }\n      if (value.coordinates && Array.isArray(value.coordinates)) {\n        const coordinateLength = value.coordinates.length;\n        const subArrays = [geoBuff];\n        for (let i = 0; i < coordinateLength; i++) {\n          const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type);\n          if (tmpBuf == null) break;\n          subArrays.push(tmpBuf);\n        }\n        geoBuff.writeInt32LE(subArrays.length - 1, 5);\n        return Buffer.concat(subArrays);\n      } else {\n        geoBuff.writeInt32LE(0, 5);\n        return geoBuff;\n      }\n    } else {\n      switch (headerType) {\n        case 'MultiPoint':\n          if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {\n            geoBuff = Buffer.allocUnsafe(21);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(1, 1); //wkbPoint\n            geoBuff.writeDoubleLE(value[0], 5); //X\n            geoBuff.writeDoubleLE(value[1], 13); //Y\n            return geoBuff;\n          }\n          return null;\n\n        case 'MultiLineString':\n          if (value && Array.isArray(value)) {\n            const pointNumber = value.length;\n            geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(2, 1); //wkbLineString\n            geoBuff.writeInt32LE(pointNumber, 5);\n            for (let i = 0; i < pointNumber; i++) {\n              if (\n                value[i] &&\n                Array.isArray(value[i]) &&\n                value[i].length >= 2 &&\n                !isNaN(value[i][0]) &&\n                !isNaN(value[i][1])\n              ) {\n                geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i); //X\n                geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i); //Y\n              } else {\n                return null;\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n\n        case 'MultiPolygon':\n          if (value && Array.isArray(value)) {\n            const numRings = value.length;\n            let size = 0;\n            for (let i = 0; i < numRings; i++) {\n              size += 4 + 16 * value[i].length;\n            }\n            geoBuff = Buffer.allocUnsafe(9 + size);\n            geoBuff.writeInt8(0x01, 0); //LITTLE ENDIAN\n            geoBuff.writeInt32LE(3, 1); //wkbPolygon\n            geoBuff.writeInt32LE(numRings, 5);\n            pos = 9;\n            for (let i = 0; i < numRings; i++) {\n              const lineString = value[i];\n              if (lineString && Array.isArray(lineString)) {\n                geoBuff.writeInt32LE(lineString.length, pos);\n                pos += 4;\n                for (let j = 0; j < lineString.length; j++) {\n                  if (\n                    lineString[j] &&\n                    Array.isArray(lineString[j]) &&\n                    lineString[j].length >= 2 &&\n                    !isNaN(lineString[j][0]) &&\n                    !isNaN(lineString[j][1])\n                  ) {\n                    geoBuff.writeDoubleLE(lineString[j][0], pos); //X\n                    geoBuff.writeDoubleLE(lineString[j][1], pos + 8); //Y\n                    pos += 16;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n            }\n            return geoBuff;\n          }\n          return null;\n      }\n      return null;\n    }\n  }\n}\n\nmodule.exports = BinaryEncoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\nclass BinaryDecoder {\n  static newRow(packet, columns) {\n    packet.skip(1); // skip 0x00 header.\n    const len = Math.floor((columns.length + 9) / 8);\n    const nullBitMap = new Array(len);\n    for (let i = 0; i < len; i++) nullBitMap[i] = packet.readUInt8();\n    return nullBitMap;\n  }\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();\n    column.buffer = () => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\n    column.float = () => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\n    column.tiny = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();\n    column.short = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();\n    column.int = () => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\n    column.long = () => isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64();\n    column.decimal = () => isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded();\n    column.date = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\n    column.datetime = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = {\n              type: 'Point'\n            };\n            break;\n          case 'linestring':\n            defaultVal = {\n              type: 'LineString'\n            };\n            break;\n          case 'polygon':\n            defaultVal = {\n              type: 'Polygon'\n            };\n            break;\n          case 'multipoint':\n            defaultVal = {\n              type: 'MultiPoint'\n            };\n            break;\n          case 'multilinestring':\n            defaultVal = {\n              type: 'MultiLineString'\n            };\n            break;\n          case 'multipolygon':\n            defaultVal = {\n              type: 'MultiPolygon'\n            };\n            break;\n          default:\n            defaultVal = {\n              type: column.dataTypeName\n            };\n            break;\n        }\n      }\n      if (isNullBitmap(index, nullBitmap)) {\n        return defaultVal;\n      }\n      return packet.readGeometry(defaultVal);\n    };\n  }\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n\n    // return constant parser (function not depending on column info other than type)\n    const defaultParser = col.signed() ? DEFAULT_SIGNED_PARSER_TYPE[col.columnType] : DEFAULT_UNSIGNED_PARSER_TYPE[col.columnType];\n    if (defaultParser) return defaultParser;\n\n    // parser depending on column info\n    switch (col.columnType) {\n      case FieldType.BIGINT:\n        if (col.signed()) {\n          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;\n        }\n        return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;\n      case FieldType.DATETIME:\n      case FieldType.TIMESTAMP:\n        return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometryBinary.bind(null, defaultVal);\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitBinaryBoolean;\n        }\n        return readBinaryBuffer;\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJsonBinary;\n        }\n        if (col.collation.index === 63) {\n          return readBinaryBuffer;\n        }\n        if (col.isSet()) {\n          return readBinarySet;\n        }\n        return readStringBinary;\n    }\n  }\n}\nconst isNullBitmap = (index, nullBitmap) => {\n  return (nullBitmap[Math.floor((index + 2) / 8)] & 1 << (index + 2) % 8) > 0;\n};\nmodule.exports = BinaryDecoder;\nconst readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt8();\nconst readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();\nconst readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt16();\nconst readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();\nconst readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readUInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\nconst readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();\nconst readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\nconst readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readDouble();\nconst readBigintBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigUInt64();\n};\nconst readBigintBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigInt64();\n};\nconst readBigintAsIntBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigUInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(`value ${val} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\nconst readBigintAsIntBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(`value ${val} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\nconst readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return defaultVal;\n  }\n  return packet.readGeometry(defaultVal);\n};\nconst readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\nconst readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\nconst readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);\nconst readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();\nconst readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  //checkNumberRange additional check is only done when\n  // resulting value is an integer\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(`value ${valDec} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec;\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    const numberValue = Number(valDec);\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {\n      return valDec;\n    }\n    return numberValue;\n  }\n  return valDec;\n};\nconst readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());\nconst readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;\nconst readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\nconst readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\nconst readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();\nconst DEFAULT_SIGNED_PARSER_TYPE = Array(256);\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.INT] = readIntBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;\nconst DEFAULT_UNSIGNED_PARSER_TYPE = Array(256);\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT] = readIntBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;","map":{"version":3,"names":["FieldType","require","Errors","BinaryDecoder","newRow","packet","columns","skip","len","Math","floor","length","nullBitMap","Array","i","readUInt8","castWrapper","column","opts","nullBitmap","index","string","isNullBitmap","readStringLengthEncoded","buffer","readBufferLengthEncoded","float","readFloat","tiny","signed","readInt8","short","readInt16","readUInt16","int","readInt32","long","readBigInt64","decimal","readDecimalLengthEncoded","date","readBinaryDate","datetime","readBinaryDateTime","geometry","defaultVal","dataTypeName","type","readGeometry","parser","col","defaultParser","DEFAULT_SIGNED_PARSER_TYPE","columnType","DEFAULT_UNSIGNED_PARSER_TYPE","BIGINT","bigIntAsNumber","supportBigNumbers","readBigintAsIntBinarySigned","readBigintBinarySigned","readBigintAsIntBinaryUnsigned","readBigintBinaryUnsigned","DATETIME","TIMESTAMP","dateStrings","readTimestampStringBinary","bind","scale","readTimestampBinary","DECIMAL","NEWDECIMAL","readDecimalAsIntBinary","readDecimalBinary","GEOMETRY","__getDefaultGeomVal","readGeometryBinary","BIT","columnLength","bitOneIsBoolean","readBitBinaryBoolean","readBinaryBuffer","dataTypeFormat","autoJsonMap","readJsonBinary","collation","isSet","readBinarySet","readStringBinary","module","exports","readTinyBinarySigned","throwUnexpectedError","readTinyBinaryUnsigned","readShortBinarySigned","readShortBinaryUnsigned","readMediumBinarySigned","result","readInt24","readMediumBinaryUnsigned","readUInt24","readIntBinarySigned","readIntBinaryUnsigned","readUInt32","readFloatBinary","readDoubleBinary","readDouble","readBigUInt64","val","checkNumberRange","Number","isSafeInteger","ER_PARSING_PRECISION","bigNumberStrings","toString","readDateBinary","readBinaryDateTimeAsString","readTimeBinary","readBinaryTime","valDec","decimalAsNumber","numberValue","isInteger","JSON","parse","split","TINY","YEAR","SHORT","INT24","INT","FLOAT","DOUBLE","DATE","TIME"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cmd/decoder/binary-decoder.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\n\nclass BinaryDecoder {\n  static newRow(packet, columns) {\n    packet.skip(1); // skip 0x00 header.\n    const len = Math.floor((columns.length + 9) / 8);\n    const nullBitMap = new Array(len);\n    for (let i = 0; i < len; i++) nullBitMap[i] = packet.readUInt8();\n    return nullBitMap;\n  }\n\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => (isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded());\n    column.buffer = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded());\n    column.float = () => (isNullBitmap(index, nullBitmap) ? null : packet.readFloat());\n    column.tiny = () =>\n      isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();\n    column.short = () =>\n      isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();\n    column.int = () => (isNullBitmap(index, nullBitmap) ? null : packet.readInt32());\n    column.long = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64());\n    column.decimal = () => (isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded());\n    column.date = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts));\n    column.datetime = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime());\n\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = { type: 'Point' };\n            break;\n          case 'linestring':\n            defaultVal = { type: 'LineString' };\n            break;\n          case 'polygon':\n            defaultVal = { type: 'Polygon' };\n            break;\n          case 'multipoint':\n            defaultVal = { type: 'MultiPoint' };\n            break;\n          case 'multilinestring':\n            defaultVal = { type: 'MultiLineString' };\n            break;\n          case 'multipolygon':\n            defaultVal = { type: 'MultiPolygon' };\n            break;\n          default:\n            defaultVal = { type: column.dataTypeName };\n            break;\n        }\n      }\n\n      if (isNullBitmap(index, nullBitmap)) {\n        return defaultVal;\n      }\n      return packet.readGeometry(defaultVal);\n    };\n  }\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n\n    // return constant parser (function not depending on column info other than type)\n    const defaultParser = col.signed()\n      ? DEFAULT_SIGNED_PARSER_TYPE[col.columnType]\n      : DEFAULT_UNSIGNED_PARSER_TYPE[col.columnType];\n    if (defaultParser) return defaultParser;\n\n    // parser depending on column info\n    switch (col.columnType) {\n      case FieldType.BIGINT:\n        if (col.signed()) {\n          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;\n        }\n        return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;\n\n      case FieldType.DATETIME:\n      case FieldType.TIMESTAMP:\n        return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;\n\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;\n\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometryBinary.bind(null, defaultVal);\n\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitBinaryBoolean;\n        }\n        return readBinaryBuffer;\n\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJsonBinary;\n        }\n        if (col.collation.index === 63) {\n          return readBinaryBuffer;\n        }\n        if (col.isSet()) {\n          return readBinarySet;\n        }\n        return readStringBinary;\n    }\n  }\n}\n\nconst isNullBitmap = (index, nullBitmap) => {\n  return (nullBitmap[Math.floor((index + 2) / 8)] & (1 << (index + 2) % 8)) > 0;\n};\n\nmodule.exports = BinaryDecoder;\n\nconst readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt8();\nconst readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();\nconst readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt16();\nconst readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();\nconst readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readUInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\nconst readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();\nconst readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\nconst readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readDouble();\nconst readBigintBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigUInt64();\n};\nconst readBigintBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigInt64();\n};\n\nconst readBigintAsIntBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigUInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(\n      `value ${val} can't safely be converted to number`,\n      false,\n      null,\n      '42000',\n      Errors.ER_PARSING_PRECISION\n    );\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\n\nconst readBigintAsIntBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(\n      `value ${val} can't safely be converted to number`,\n      false,\n      null,\n      '42000',\n      Errors.ER_PARSING_PRECISION\n    );\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\n\nconst readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return defaultVal;\n  }\n  return packet.readGeometry(defaultVal);\n};\nconst readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\nconst readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\nconst readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);\nconst readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();\nconst readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  //checkNumberRange additional check is only done when\n  // resulting value is an integer\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(\n        `value ${valDec} can't safely be converted to number`,\n        false,\n        null,\n        '42000',\n        Errors.ER_PARSING_PRECISION\n      );\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec;\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    const numberValue = Number(valDec);\n    if (\n      opts.supportBigNumbers &&\n      (opts.bigNumberStrings || (Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue)))\n    ) {\n      return valDec;\n    }\n    return numberValue;\n  }\n  return valDec;\n};\nconst readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());\nconst readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;\nconst readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\nconst readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\nconst readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();\n\nconst DEFAULT_SIGNED_PARSER_TYPE = Array(256);\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.INT] = readIntBinarySigned;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;\nDEFAULT_SIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;\n\nconst DEFAULT_UNSIGNED_PARSER_TYPE = Array(256);\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT] = readIntBinaryUnsigned;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;\nDEFAULT_UNSIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
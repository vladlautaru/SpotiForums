{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Errors = require('../misc/errors');\n\n/**\n * Object to easily parse buffer.\n * Packet are MUTABLE (buffer are changed, to avoid massive packet object creation).\n * Use clone() in case immutability is required\n *\n */\nclass Packet {\n  update(buf, pos, end) {\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n    return this;\n  }\n  skip(n) {\n    this.pos += n;\n  }\n  readGeometry(defaultVal) {\n    const geoBuf = this.readBufferLengthEncoded();\n    if (geoBuf === null || geoBuf.length === 0) {\n      return defaultVal;\n    }\n    let geoPos = 4;\n    return readGeometryObject(false);\n    function parseCoordinates(byteOrder) {\n      geoPos += 16;\n      const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n      const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n      return [x, y];\n    }\n    function readGeometryObject(inner) {\n      const byteOrder = geoBuf[geoPos++];\n      const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      switch (wkbType) {\n        case 1:\n          //wkbPoint\n          const coords = parseCoordinates(byteOrder);\n          if (inner) return coords;\n          return {\n            type: 'Point',\n            coordinates: coords\n          };\n        case 2:\n          //wkbLineString\n          const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          let coordinates = [];\n          for (let i = 0; i < pointNumber; i++) {\n            coordinates.push(parseCoordinates(byteOrder));\n          }\n          if (inner) return coordinates;\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n        case 3:\n          //wkbPolygon\n          let polygonCoordinates = [];\n          const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          for (let ring = 0; ring < numRings; ring++) {\n            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            let linesCoordinates = [];\n            for (let i = 0; i < pointNumber; i++) {\n              linesCoordinates.push(parseCoordinates(byteOrder));\n            }\n            polygonCoordinates.push(linesCoordinates);\n          }\n          if (inner) return polygonCoordinates;\n          return {\n            type: 'Polygon',\n            coordinates: polygonCoordinates\n          };\n        case 4:\n          //wkbMultiPoint\n          return {\n            type: 'MultiPoint',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 5:\n          //wkbMultiLineString\n          return {\n            type: 'MultiLineString',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 6:\n          //wkbMultiPolygon\n          return {\n            type: 'MultiPolygon',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 7:\n          //wkbGeometryCollection\n          return {\n            type: 'GeometryCollection',\n            geometries: parseGeomArray(byteOrder, false)\n          };\n      }\n      return null;\n    }\n    function parseGeomArray(byteOrder, inner) {\n      let coordinates = [];\n      const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      for (let i = 0; i < number; i++) {\n        coordinates.push(readGeometryObject(inner));\n      }\n      return coordinates;\n    }\n  }\n  peek() {\n    return this.buf[this.pos];\n  }\n  remaining() {\n    return this.end - this.pos > 0;\n  }\n  readInt8() {\n    const val = this.buf[this.pos++];\n    return val | (val & 2 ** 7) * 0x1fffffe;\n  }\n  readUInt8() {\n    return this.buf[this.pos++];\n  }\n  readInt16() {\n    const first = this.buf[this.pos++];\n    const last = this.buf[this.pos++];\n    const val = first + last * 2 ** 8;\n    return val | (val & 2 ** 15) * 0x1fffe;\n  }\n  readUInt16() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n  }\n  readInt24() {\n    const first = this.buf[this.pos];\n    const last = this.buf[this.pos + 2];\n    const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;\n    this.pos += 3;\n    return val | (val & 2 ** 23) * 0x1fe;\n  }\n  readUInt24() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n  }\n  readUInt32() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + this.buf[this.pos++] * 2 ** 24;\n  }\n  readInt32() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + (this.buf[this.pos++] << 24);\n  }\n  readBigInt64() {\n    const val = this.buf.readBigInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n  readBigUInt64() {\n    const val = this.buf.readBigUInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  /**\n   * Metadata are length encoded, but cannot have length > 256, so simplified readUnsignedLength\n   * @returns {number}\n   */\n  readMetadataLength() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return type;\n    return this.readUInt16();\n  }\n  readUnsignedLength() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return type;\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        //readUInt16();\n        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n      case 0xfd:\n        //readUInt24();\n        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n      case 0xfe:\n        // limitation to BigInt signed value\n        return Number(this.readBigInt64());\n    }\n  }\n  readBuffer(len) {\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n  readBufferRemaining() {\n    let b = this.buf.subarray(this.pos, this.end);\n    this.pos = this.end;\n    return b;\n  }\n  readBufferLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n  readStringNullEnded() {\n    let initialPosition = this.pos;\n    let cnt = 0;\n    while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n      cnt++;\n    }\n    return this.buf.toString(undefined, initialPosition, initialPosition + cnt);\n  }\n  readSignedLengthBigInt() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return BigInt(type);\n    switch (type) {\n      // null test is not used for now, since only used for reading insertId\n      // case 0xfb:\n      //   return null;\n      case 0xfc:\n        return BigInt(this.readUInt16());\n      case 0xfd:\n        return BigInt(this.readUInt24());\n      case 0xfe:\n        return this.readBigInt64();\n    }\n  }\n  readAsciiStringLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  readStringLengthEncoded() {\n    throw new Error('code is normally superseded by Node encoder or Iconv depending on charset used');\n  }\n  readBigIntLengthEncoded() {\n    const len = this.buf[this.pos++];\n\n    // fast-path: if length encoded is < to 16, value is in safe integer range, using atoi\n    if (len < 16) {\n      return BigInt(this._atoi(len));\n    }\n    if (len === 0xfb) return null;\n    return this.readBigIntFromLen(len);\n  }\n  readBigIntFromLen(len) {\n    // atoll\n    let result = 0n;\n    let negate = false;\n    let begin = this.pos;\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10n + BigInt(this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1n * result : result;\n  }\n  readDecimalLengthEncoded() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  readDate() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    let res = [];\n    let value = 0;\n    let initPos = this.pos;\n    this.pos += len;\n    while (initPos < this.pos) {\n      const char = this.buf[initPos++];\n      if (char === 45) {\n        //minus separator\n        res.push(value);\n        value = 0;\n      } else {\n        value = value * 10 + char - 48;\n      }\n    }\n    res.push(value);\n\n    //handle zero-date as null\n    if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n    return new Date(res[0], res[1] - 1, res[2]);\n  }\n  readBinaryDate(opts) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8() - 1;\n        if (len > 3) {\n          day = this.readUInt8();\n        }\n      }\n    }\n    if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? '0000-00-00' : null;\n    if (opts.dateStrings) {\n      return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;\n    }\n    //handle zero-date as null\n    return new Date(year, month, day);\n  }\n  readDateTime() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    this.pos += len;\n    const str = this.buf.toString('ascii', this.pos - len, this.pos);\n    if (str.startsWith('0000-00-00 00:00:00')) return null;\n    return new Date(str);\n  }\n  readBinaryDateTime() {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;\n    return new Date(year, month - 1, day, hour, min, sec, microSec / 1000);\n  }\n  readBinaryDateTimeAsString(scale) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return '0000-00-00 00:00:00' + (scale > 0 ? '.000000'.substring(0, scale + 1) : '');\n    return appendZero(year, 4) + '-' + appendZero(month, 2) + '-' + appendZero(day, 2) + ' ' + appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2) + (microSec > 0 ? scale > 0 ? '.' + appendZero(microSec, 6).substring(0, scale) : '.' + appendZero(microSec, 6) : scale > 0 ? '.' + appendZero(microSec, 6).substring(0, scale) : '');\n  }\n  readBinaryTime() {\n    const len = this.buf[this.pos++];\n    let negate = false;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n    if (len > 0) {\n      negate = this.buf[this.pos++] === 1;\n      hour = this.readUInt32() * 24 + this.readUInt8();\n      min = this.readUInt8();\n      sec = this.readUInt8();\n      if (len > 8) {\n        microSec = this.readUInt32();\n      }\n    }\n    let val = appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2);\n    if (microSec > 0) {\n      val += '.' + appendZero(microSec, 6);\n    }\n    if (negate) return '-' + val;\n    return val;\n  }\n  readFloat() {\n    const val = this.buf.readFloatLE(this.pos);\n    this.pos += 4;\n    return val;\n  }\n  readDouble() {\n    const val = this.buf.readDoubleLE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n  readIntLengthEncoded() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    return this._atoi(len);\n  }\n  _atoi(len) {\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1 * result : result;\n  }\n  readFloatLengthCoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return +this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  skipLengthCodedNumber() {\n    const type = this.buf[this.pos++];\n    switch (type) {\n      case 251:\n        return;\n      case 252:\n        this.pos += 2 + (0xffff & this.buf[this.pos] + (this.buf[this.pos + 1] << 8));\n        return;\n      case 253:\n        this.pos += 3 + (0xffffff & this.buf[this.pos] + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 16));\n        return;\n      case 254:\n        this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));\n        return;\n      default:\n        this.pos += type;\n        return;\n    }\n  }\n  length() {\n    return this.end - this.pos;\n  }\n  subPacketLengthEncoded(len) {}\n\n  /**\n   * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n   *\n   * @param info              current connection info\n   * @param sql               command sql\n   * @param stack             additional stack trace\n   * @returns {Error}\n   */\n  readError(info, sql, stack) {\n    this.skip(1);\n    let errno = this.readUInt16();\n    let sqlState;\n    let msg;\n    // check '#'\n    if (this.peek() === 0x23) {\n      // skip '#'\n      this.skip(6);\n      sqlState = this.buf.toString(undefined, this.pos - 5, this.pos);\n      msg = this.readStringNullEnded();\n    } else {\n      // pre 4.1 format\n      sqlState = 'HY000';\n      msg = this.buf.toString(undefined, this.pos, this.end);\n    }\n    let fatal = sqlState.startsWith('08') || sqlState === '70100';\n    return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);\n  }\n}\nconst appendZero = (val, len) => {\n  let st = val.toString();\n  while (st.length < len) {\n    st = '0' + st;\n  }\n  return st;\n};\nmodule.exports = Packet;","map":{"version":3,"names":["Errors","require","Packet","update","buf","pos","end","skip","n","readGeometry","defaultVal","geoBuf","readBufferLengthEncoded","length","geoPos","readGeometryObject","parseCoordinates","byteOrder","x","readDoubleLE","readDoubleBE","y","inner","wkbType","readInt32LE","readInt32BE","coords","type","coordinates","pointNumber","i","push","polygonCoordinates","numRings","ring","linesCoordinates","parseGeomArray","geometries","number","peek","remaining","readInt8","val","readUInt8","readInt16","first","last","readUInt16","readInt24","readUInt24","readUInt32","readInt32","readBigInt64","readBigInt64LE","readBigUInt64","readBigUInt64LE","readMetadataLength","readUnsignedLength","Number","readBuffer","len","subarray","readBufferRemaining","b","readStringNullEnded","initialPosition","cnt","toString","undefined","readSignedLengthBigInt","BigInt","readAsciiStringLengthEncoded","readStringLengthEncoded","Error","readBigIntLengthEncoded","_atoi","readBigIntFromLen","result","negate","begin","readDecimalLengthEncoded","readDate","res","value","initPos","char","Date","readBinaryDate","opts","year","month","day","dateStrings","appendZero","readDateTime","str","startsWith","readBinaryDateTime","hour","min","sec","microSec","readBinaryDateTimeAsString","scale","substring","readBinaryTime","readFloat","readFloatLE","readDouble","readIntLengthEncoded","readFloatLengthCoded","skipLengthCodedNumber","subPacketLengthEncoded","readError","info","sql","stack","errno","sqlState","msg","fatal","createError","st","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/io/packet.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst Errors = require('../misc/errors');\n\n/**\n * Object to easily parse buffer.\n * Packet are MUTABLE (buffer are changed, to avoid massive packet object creation).\n * Use clone() in case immutability is required\n *\n */\nclass Packet {\n  update(buf, pos, end) {\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n    return this;\n  }\n\n  skip(n) {\n    this.pos += n;\n  }\n\n  readGeometry(defaultVal) {\n    const geoBuf = this.readBufferLengthEncoded();\n    if (geoBuf === null || geoBuf.length === 0) {\n      return defaultVal;\n    }\n    let geoPos = 4;\n    return readGeometryObject(false);\n\n    function parseCoordinates(byteOrder) {\n      geoPos += 16;\n      const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n      const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n      return [x, y];\n    }\n\n    function readGeometryObject(inner) {\n      const byteOrder = geoBuf[geoPos++];\n      const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      switch (wkbType) {\n        case 1: //wkbPoint\n          const coords = parseCoordinates(byteOrder);\n\n          if (inner) return coords;\n          return {\n            type: 'Point',\n            coordinates: coords\n          };\n\n        case 2: //wkbLineString\n          const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          let coordinates = [];\n          for (let i = 0; i < pointNumber; i++) {\n            coordinates.push(parseCoordinates(byteOrder));\n          }\n          if (inner) return coordinates;\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n\n        case 3: //wkbPolygon\n          let polygonCoordinates = [];\n          const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          for (let ring = 0; ring < numRings; ring++) {\n            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            let linesCoordinates = [];\n            for (let i = 0; i < pointNumber; i++) {\n              linesCoordinates.push(parseCoordinates(byteOrder));\n            }\n            polygonCoordinates.push(linesCoordinates);\n          }\n\n          if (inner) return polygonCoordinates;\n          return {\n            type: 'Polygon',\n            coordinates: polygonCoordinates\n          };\n\n        case 4: //wkbMultiPoint\n          return {\n            type: 'MultiPoint',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n\n        case 5: //wkbMultiLineString\n          return {\n            type: 'MultiLineString',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 6: //wkbMultiPolygon\n          return {\n            type: 'MultiPolygon',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 7: //wkbGeometryCollection\n          return {\n            type: 'GeometryCollection',\n            geometries: parseGeomArray(byteOrder, false)\n          };\n      }\n      return null;\n    }\n\n    function parseGeomArray(byteOrder, inner) {\n      let coordinates = [];\n      const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      for (let i = 0; i < number; i++) {\n        coordinates.push(readGeometryObject(inner));\n      }\n      return coordinates;\n    }\n  }\n\n  peek() {\n    return this.buf[this.pos];\n  }\n\n  remaining() {\n    return this.end - this.pos > 0;\n  }\n\n  readInt8() {\n    const val = this.buf[this.pos++];\n    return val | ((val & (2 ** 7)) * 0x1fffffe);\n  }\n\n  readUInt8() {\n    return this.buf[this.pos++];\n  }\n\n  readInt16() {\n    const first = this.buf[this.pos++];\n    const last = this.buf[this.pos++];\n    const val = first + last * 2 ** 8;\n    return val | ((val & (2 ** 15)) * 0x1fffe);\n  }\n\n  readUInt16() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n  }\n\n  readInt24() {\n    const first = this.buf[this.pos];\n    const last = this.buf[this.pos + 2];\n    const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;\n    this.pos += 3;\n    return val | ((val & (2 ** 23)) * 0x1fe);\n  }\n\n  readUInt24() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n  }\n\n  readUInt32() {\n    return (\n      this.buf[this.pos++] +\n      this.buf[this.pos++] * 2 ** 8 +\n      this.buf[this.pos++] * 2 ** 16 +\n      this.buf[this.pos++] * 2 ** 24\n    );\n  }\n\n  readInt32() {\n    return (\n      this.buf[this.pos++] +\n      this.buf[this.pos++] * 2 ** 8 +\n      this.buf[this.pos++] * 2 ** 16 +\n      (this.buf[this.pos++] << 24)\n    );\n  }\n\n  readBigInt64() {\n    const val = this.buf.readBigInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  readBigUInt64() {\n    const val = this.buf.readBigUInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  /**\n   * Metadata are length encoded, but cannot have length > 256, so simplified readUnsignedLength\n   * @returns {number}\n   */\n  readMetadataLength() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return type;\n    return this.readUInt16();\n  }\n\n  readUnsignedLength() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return type;\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        //readUInt16();\n        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n      case 0xfd:\n        //readUInt24();\n        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n      case 0xfe:\n        // limitation to BigInt signed value\n        return Number(this.readBigInt64());\n    }\n  }\n\n  readBuffer(len) {\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n\n  readBufferRemaining() {\n    let b = this.buf.subarray(this.pos, this.end);\n    this.pos = this.end;\n    return b;\n  }\n\n  readBufferLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n\n  readStringNullEnded() {\n    let initialPosition = this.pos;\n    let cnt = 0;\n    while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n      cnt++;\n    }\n    return this.buf.toString(undefined, initialPosition, initialPosition + cnt);\n  }\n\n  readSignedLengthBigInt() {\n    const type = this.buf[this.pos++];\n    if (type < 0xfb) return BigInt(type);\n    switch (type) {\n      // null test is not used for now, since only used for reading insertId\n      // case 0xfb:\n      //   return null;\n      case 0xfc:\n        return BigInt(this.readUInt16());\n      case 0xfd:\n        return BigInt(this.readUInt24());\n      case 0xfe:\n        return this.readBigInt64();\n    }\n  }\n\n  readAsciiStringLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  readStringLengthEncoded() {\n    throw new Error('code is normally superseded by Node encoder or Iconv depending on charset used');\n  }\n\n  readBigIntLengthEncoded() {\n    const len = this.buf[this.pos++];\n\n    // fast-path: if length encoded is < to 16, value is in safe integer range, using atoi\n    if (len < 16) {\n      return BigInt(this._atoi(len));\n    }\n\n    if (len === 0xfb) return null;\n\n    return this.readBigIntFromLen(len);\n  }\n\n  readBigIntFromLen(len) {\n    // atoll\n    let result = 0n;\n    let negate = false;\n    let begin = this.pos;\n\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10n + BigInt(this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1n * result : result;\n  }\n\n  readDecimalLengthEncoded() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  readDate() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    let res = [];\n    let value = 0;\n    let initPos = this.pos;\n    this.pos += len;\n    while (initPos < this.pos) {\n      const char = this.buf[initPos++];\n      if (char === 45) {\n        //minus separator\n        res.push(value);\n        value = 0;\n      } else {\n        value = value * 10 + char - 48;\n      }\n    }\n    res.push(value);\n\n    //handle zero-date as null\n    if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n\n    return new Date(res[0], res[1] - 1, res[2]);\n  }\n\n  readBinaryDate(opts) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8() - 1;\n        if (len > 3) {\n          day = this.readUInt8();\n        }\n      }\n    }\n    if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? '0000-00-00' : null;\n    if (opts.dateStrings) {\n      return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;\n    }\n    //handle zero-date as null\n    return new Date(year, month, day);\n  }\n\n  readDateTime() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    this.pos += len;\n    const str = this.buf.toString('ascii', this.pos - len, this.pos);\n    if (str.startsWith('0000-00-00 00:00:00')) return null;\n    return new Date(str);\n  }\n\n  readBinaryDateTime() {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;\n    return new Date(year, month - 1, day, hour, min, sec, microSec / 1000);\n  }\n\n  readBinaryDateTimeAsString(scale) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0)\n      return '0000-00-00 00:00:00' + (scale > 0 ? '.000000'.substring(0, scale + 1) : '');\n\n    return (\n      appendZero(year, 4) +\n      '-' +\n      appendZero(month, 2) +\n      '-' +\n      appendZero(day, 2) +\n      ' ' +\n      appendZero(hour, 2) +\n      ':' +\n      appendZero(min, 2) +\n      ':' +\n      appendZero(sec, 2) +\n      (microSec > 0\n        ? scale > 0\n          ? '.' + appendZero(microSec, 6).substring(0, scale)\n          : '.' + appendZero(microSec, 6)\n        : scale > 0\n          ? '.' + appendZero(microSec, 6).substring(0, scale)\n          : '')\n    );\n  }\n\n  readBinaryTime() {\n    const len = this.buf[this.pos++];\n    let negate = false;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n\n    if (len > 0) {\n      negate = this.buf[this.pos++] === 1;\n      hour = this.readUInt32() * 24 + this.readUInt8();\n      min = this.readUInt8();\n      sec = this.readUInt8();\n      if (len > 8) {\n        microSec = this.readUInt32();\n      }\n    }\n    let val = appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2);\n    if (microSec > 0) {\n      val += '.' + appendZero(microSec, 6);\n    }\n    if (negate) return '-' + val;\n    return val;\n  }\n\n  readFloat() {\n    const val = this.buf.readFloatLE(this.pos);\n    this.pos += 4;\n    return val;\n  }\n\n  readDouble() {\n    const val = this.buf.readDoubleLE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  readIntLengthEncoded() {\n    const len = this.buf[this.pos++];\n    if (len === 0xfb) return null;\n    return this._atoi(len);\n  }\n\n  _atoi(len) {\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1 * result : result;\n  }\n\n  readFloatLengthCoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return +this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  skipLengthCodedNumber() {\n    const type = this.buf[this.pos++];\n    switch (type) {\n      case 251:\n        return;\n      case 252:\n        this.pos += 2 + (0xffff & (this.buf[this.pos] + (this.buf[this.pos + 1] << 8)));\n        return;\n      case 253:\n        this.pos +=\n          3 + (0xffffff & (this.buf[this.pos] + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 16)));\n        return;\n      case 254:\n        this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));\n        return;\n      default:\n        this.pos += type;\n        return;\n    }\n  }\n\n  length() {\n    return this.end - this.pos;\n  }\n\n  subPacketLengthEncoded(len) {}\n\n  /**\n   * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n   *\n   * @param info              current connection info\n   * @param sql               command sql\n   * @param stack             additional stack trace\n   * @returns {Error}\n   */\n  readError(info, sql, stack) {\n    this.skip(1);\n    let errno = this.readUInt16();\n    let sqlState;\n    let msg;\n    // check '#'\n    if (this.peek() === 0x23) {\n      // skip '#'\n      this.skip(6);\n      sqlState = this.buf.toString(undefined, this.pos - 5, this.pos);\n      msg = this.readStringNullEnded();\n    } else {\n      // pre 4.1 format\n      sqlState = 'HY000';\n      msg = this.buf.toString(undefined, this.pos, this.end);\n    }\n    let fatal = sqlState.startsWith('08') || sqlState === '70100';\n    return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);\n  }\n}\n\nconst appendZero = (val, len) => {\n  let st = val.toString();\n  while (st.length < len) {\n    st = '0' + st;\n  }\n  return st;\n};\n\nmodule.exports = Packet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
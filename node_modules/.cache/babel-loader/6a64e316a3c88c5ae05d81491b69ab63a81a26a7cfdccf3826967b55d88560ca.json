{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\nclass TextDecoder {\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => packet.readStringLengthEncoded();\n    column.buffer = () => packet.readBufferLengthEncoded();\n    column.float = () => packet.readFloatLengthCoded();\n    column.tiny = () => packet.readIntLengthEncoded();\n    column.short = () => packet.readIntLengthEncoded();\n    column.int = () => packet.readIntLengthEncoded();\n    column.long = () => packet.readBigIntLengthEncoded();\n    column.decimal = () => packet.readDecimalLengthEncoded();\n    column.date = () => packet.readDate(opts);\n    column.datetime = () => packet.readDateTime();\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = {\n              type: 'Point'\n            };\n            break;\n          case 'linestring':\n            defaultVal = {\n              type: 'LineString'\n            };\n            break;\n          case 'polygon':\n            defaultVal = {\n              type: 'Polygon'\n            };\n            break;\n          case 'multipoint':\n            defaultVal = {\n              type: 'MultiPoint'\n            };\n            break;\n          case 'multilinestring':\n            defaultVal = {\n              type: 'MultiLineString'\n            };\n            break;\n          case 'multipolygon':\n            defaultVal = {\n              type: 'MultiPolygon'\n            };\n            break;\n          default:\n            defaultVal = {\n              type: column.dataTypeName\n            };\n            break;\n        }\n      }\n      return packet.readGeometry(defaultVal);\n    };\n  }\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n\n    // return constant parser (function not depending on column info other than type)\n    const defaultParser = DEFAULT_PARSER_TYPE[col.columnType];\n    if (defaultParser) return defaultParser;\n\n    // parser depending on column info\n    switch (col.columnType) {\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntLengthCoded : readDecimalLengthCoded;\n      case FieldType.BIGINT:\n        if (opts.bigIntAsNumber || opts.supportBigNumbers) return readBigIntAsNumberLengthCoded;\n        return readBigIntLengthCoded;\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometry.bind(null, defaultVal);\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitAsBoolean;\n        }\n        return readBufferLengthEncoded;\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJson;\n        }\n        if (col.collation.index === 63) {\n          return readBufferLengthEncoded;\n        }\n        if (col.isSet()) {\n          return readSet;\n        }\n        return readStringLengthEncoded;\n    }\n  }\n}\nmodule.exports = TextDecoder;\nconst readGeometry = (defaultVal, packet, opts, throwUnexpectedError) => packet.readGeometry(defaultVal);\nconst readIntLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readIntLengthEncoded();\nconst readStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readStringLengthEncoded();\nconst readFloatLengthCoded = (packet, opts, throwUnexpectedError) => packet.readFloatLengthCoded();\nconst readBigIntLengthCoded = (packet, opts, throwUnexpectedError) => packet.readBigIntLengthEncoded();\nconst readBigIntAsNumberLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const len = packet.readUnsignedLength();\n  if (len === null) return null;\n  if (len < 16) {\n    const val = packet._atoi(len);\n    if (opts.supportBigNumbers && opts.bigNumberStrings) {\n      return '' + val;\n    }\n    return val;\n  }\n  const val = packet.readBigIntFromLen(len);\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(`value ${val} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\nconst readDecimalAsIntLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(`value ${valDec} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec;\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    const numberValue = Number(valDec);\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {\n      return valDec;\n    }\n    return numberValue;\n  }\n  return valDec;\n};\nconst readDate = (packet, opts, throwUnexpectedError) => {\n  if (opts.dateStrings) {\n    return packet.readAsciiStringLengthEncoded();\n  }\n  return packet.readDate();\n};\nconst readTimestamp = (packet, opts, throwUnexpectedError) => {\n  if (opts.dateStrings) {\n    return packet.readAsciiStringLengthEncoded();\n  }\n  return packet.readDateTime();\n};\nconst readAsciiStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readAsciiStringLengthEncoded();\nconst readBitAsBoolean = (packet, opts, throwUnexpectedError) => {\n  const val = packet.readBufferLengthEncoded();\n  return val == null ? null : val[0] === 1;\n};\nconst readBufferLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readBufferLengthEncoded();\nconst readJson = (packet, opts, throwUnexpectedError) => JSON.parse(packet.readStringLengthEncoded());\nconst readSet = (packet, opts, throwUnexpectedError) => {\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\nconst DEFAULT_PARSER_TYPE = Array(256);\nDEFAULT_PARSER_TYPE[FieldType.TINY] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.SHORT] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.INT] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.INT24] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.YEAR] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.FLOAT] = readFloatLengthCoded;\nDEFAULT_PARSER_TYPE[FieldType.DOUBLE] = readFloatLengthCoded;\nDEFAULT_PARSER_TYPE[FieldType.DATE] = readDate;\nDEFAULT_PARSER_TYPE[FieldType.DATETIME] = readTimestamp;\nDEFAULT_PARSER_TYPE[FieldType.TIMESTAMP] = readTimestamp;\nDEFAULT_PARSER_TYPE[FieldType.TIME] = readAsciiStringLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.JSON] = readJson;","map":{"version":3,"names":["FieldType","require","Errors","TextDecoder","castWrapper","column","packet","opts","nullBitmap","index","string","readStringLengthEncoded","buffer","readBufferLengthEncoded","float","readFloatLengthCoded","tiny","readIntLengthEncoded","short","int","long","readBigIntLengthEncoded","decimal","readDecimalLengthEncoded","date","readDate","datetime","readDateTime","geometry","defaultVal","dataTypeName","type","readGeometry","parser","col","defaultParser","DEFAULT_PARSER_TYPE","columnType","DECIMAL","NEWDECIMAL","scale","readDecimalAsIntLengthCoded","readDecimalLengthCoded","BIGINT","bigIntAsNumber","supportBigNumbers","readBigIntAsNumberLengthCoded","readBigIntLengthCoded","GEOMETRY","__getDefaultGeomVal","bind","BIT","columnLength","bitOneIsBoolean","readBitAsBoolean","dataTypeFormat","autoJsonMap","readJson","collation","isSet","readSet","module","exports","throwUnexpectedError","len","readUnsignedLength","val","_atoi","bigNumberStrings","readBigIntFromLen","checkNumberRange","Number","isSafeInteger","ER_PARSING_PRECISION","toString","valDec","decimalAsNumber","numberValue","isInteger","dateStrings","readAsciiStringLengthEncoded","readTimestamp","JSON","parse","split","Array","TINY","SHORT","INT","INT24","YEAR","FLOAT","DOUBLE","DATE","DATETIME","TIMESTAMP","TIME"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cmd/decoder/text-decoder.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\n\nclass TextDecoder {\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => packet.readStringLengthEncoded();\n    column.buffer = () => packet.readBufferLengthEncoded();\n    column.float = () => packet.readFloatLengthCoded();\n    column.tiny = () => packet.readIntLengthEncoded();\n    column.short = () => packet.readIntLengthEncoded();\n    column.int = () => packet.readIntLengthEncoded();\n    column.long = () => packet.readBigIntLengthEncoded();\n    column.decimal = () => packet.readDecimalLengthEncoded();\n    column.date = () => packet.readDate(opts);\n    column.datetime = () => packet.readDateTime();\n\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = { type: 'Point' };\n            break;\n          case 'linestring':\n            defaultVal = { type: 'LineString' };\n            break;\n          case 'polygon':\n            defaultVal = { type: 'Polygon' };\n            break;\n          case 'multipoint':\n            defaultVal = { type: 'MultiPoint' };\n            break;\n          case 'multilinestring':\n            defaultVal = { type: 'MultiLineString' };\n            break;\n          case 'multipolygon':\n            defaultVal = { type: 'MultiPolygon' };\n            break;\n          default:\n            defaultVal = { type: column.dataTypeName };\n            break;\n        }\n      }\n\n      return packet.readGeometry(defaultVal);\n    };\n  }\n\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n\n    // return constant parser (function not depending on column info other than type)\n    const defaultParser = DEFAULT_PARSER_TYPE[col.columnType];\n    if (defaultParser) return defaultParser;\n\n    // parser depending on column info\n    switch (col.columnType) {\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntLengthCoded : readDecimalLengthCoded;\n\n      case FieldType.BIGINT:\n        if (opts.bigIntAsNumber || opts.supportBigNumbers) return readBigIntAsNumberLengthCoded;\n        return readBigIntLengthCoded;\n\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometry.bind(null, defaultVal);\n\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitAsBoolean;\n        }\n        return readBufferLengthEncoded;\n\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJson;\n        }\n        if (col.collation.index === 63) {\n          return readBufferLengthEncoded;\n        }\n        if (col.isSet()) {\n          return readSet;\n        }\n        return readStringLengthEncoded;\n    }\n  }\n}\n\nmodule.exports = TextDecoder;\n\nconst readGeometry = (defaultVal, packet, opts, throwUnexpectedError) => packet.readGeometry(defaultVal);\n\nconst readIntLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readIntLengthEncoded();\nconst readStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readStringLengthEncoded();\nconst readFloatLengthCoded = (packet, opts, throwUnexpectedError) => packet.readFloatLengthCoded();\nconst readBigIntLengthCoded = (packet, opts, throwUnexpectedError) => packet.readBigIntLengthEncoded();\n\nconst readBigIntAsNumberLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const len = packet.readUnsignedLength();\n  if (len === null) return null;\n  if (len < 16) {\n    const val = packet._atoi(len);\n    if (opts.supportBigNumbers && opts.bigNumberStrings) {\n      return '' + val;\n    }\n    return val;\n  }\n\n  const val = packet.readBigIntFromLen(len);\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(\n      `value ${val} can't safely be converted to number`,\n      false,\n      null,\n      '42000',\n      Errors.ER_PARSING_PRECISION\n    );\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\n\nconst readDecimalAsIntLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(\n        `value ${valDec} can't safely be converted to number`,\n        false,\n        null,\n        '42000',\n        Errors.ER_PARSING_PRECISION\n      );\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec;\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalLengthCoded = (packet, opts, throwUnexpectedError) => {\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    const numberValue = Number(valDec);\n    if (\n      opts.supportBigNumbers &&\n      (opts.bigNumberStrings || (Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue)))\n    ) {\n      return valDec;\n    }\n    return numberValue;\n  }\n  return valDec;\n};\nconst readDate = (packet, opts, throwUnexpectedError) => {\n  if (opts.dateStrings) {\n    return packet.readAsciiStringLengthEncoded();\n  }\n  return packet.readDate();\n};\nconst readTimestamp = (packet, opts, throwUnexpectedError) => {\n  if (opts.dateStrings) {\n    return packet.readAsciiStringLengthEncoded();\n  }\n  return packet.readDateTime();\n};\nconst readAsciiStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readAsciiStringLengthEncoded();\nconst readBitAsBoolean = (packet, opts, throwUnexpectedError) => {\n  const val = packet.readBufferLengthEncoded();\n  return val == null ? null : val[0] === 1;\n};\nconst readBufferLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readBufferLengthEncoded();\nconst readJson = (packet, opts, throwUnexpectedError) => JSON.parse(packet.readStringLengthEncoded());\nconst readSet = (packet, opts, throwUnexpectedError) => {\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\n\nconst DEFAULT_PARSER_TYPE = Array(256);\nDEFAULT_PARSER_TYPE[FieldType.TINY] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.SHORT] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.INT] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.INT24] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.YEAR] = readIntLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.FLOAT] = readFloatLengthCoded;\nDEFAULT_PARSER_TYPE[FieldType.DOUBLE] = readFloatLengthCoded;\nDEFAULT_PARSER_TYPE[FieldType.DATE] = readDate;\nDEFAULT_PARSER_TYPE[FieldType.DATETIME] = readTimestamp;\nDEFAULT_PARSER_TYPE[FieldType.TIMESTAMP] = readTimestamp;\nDEFAULT_PARSER_TYPE[FieldType.TIME] = readAsciiStringLengthEncoded;\nDEFAULT_PARSER_TYPE[FieldType.JSON] = readJson;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
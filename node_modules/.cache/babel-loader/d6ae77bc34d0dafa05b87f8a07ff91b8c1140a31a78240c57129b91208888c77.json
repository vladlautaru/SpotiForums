{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst hexArray = '0123456789ABCDEF'.split('');\nconst Errors = require('../misc/errors');\nconst Iconv = require('iconv-lite');\nconst TextEncoder = require('../cmd/encoder/text-encoder');\n\n/**\n * Write bytes/hexadecimal value of a byte array to a string.\n * String output example :\n * 38 00 00 00 03 63 72 65  61 74 65 20 74 61 62 6C     8....create tabl\n * 65 20 42 6C 6F 62 54 65  73 74 63 6C 6F 62 74 65     e BlobTestclobte\n * 73 74 32 20 28 73 74 72  6D 20 74 65 78 74 29 20     st2 (strm text)\n * 43 48 41 52 53 45 54 20  75 74 66 38                 CHARSET utf8\n */\nmodule.exports.log = function (opts, buf, off, end, header) {\n  let out = [];\n  if (!buf) return '';\n  if (off === undefined || off === null) off = 0;\n  if (end === undefined || end === null) end = buf.length;\n  let asciiValue = new Array(16);\n  asciiValue[8] = ' ';\n  let useHeader = header !== undefined;\n  let offset = off || 0;\n  const maxLgh = Math.min(useHeader ? opts.debugLen - header.length : opts.debugLen, end - offset);\n  const isLimited = end - offset > maxLgh;\n  let byteValue;\n  let posHexa = 0;\n  let pos = 0;\n  out.push('+--------------------------------------------------+\\n' + '|  0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f |\\n' + '+--------------------------------------------------+------------------+\\n');\n  if (useHeader) {\n    while (pos < header.length) {\n      if (posHexa === 0) out.push('| ');\n      byteValue = header[pos++] & 0xff;\n      out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 0x0f], ' ');\n      asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : '.';\n      if (posHexa === 8) out.push(' ');\n    }\n  }\n  pos = offset;\n  while (pos < maxLgh + offset) {\n    if (posHexa === 0) out.push('| ');\n    byteValue = buf[pos] & 0xff;\n    out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 0x0f], ' ');\n    asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : '.';\n    if (posHexa === 8) out.push(' ');\n    if (posHexa === 16) {\n      out.push('| ', asciiValue.join(''), ' |\\n');\n      posHexa = 0;\n    }\n    pos++;\n  }\n  let remaining = posHexa;\n  if (remaining > 0) {\n    if (remaining < 8) {\n      for (; remaining < 8; remaining++) {\n        out.push('   ');\n        asciiValue[posHexa++] = ' ';\n      }\n      out.push(' ');\n    }\n    for (; remaining < 16; remaining++) {\n      out.push('   ');\n      asciiValue[posHexa++] = ' ';\n    }\n    out.push('| ', asciiValue.join(''), isLimited ? ' |...\\n' : ' |\\n');\n  } else if (isLimited) {\n    out[out.length - 1] = ' |...\\n';\n  }\n  out.push('+--------------------------------------------------+------------------+\\n');\n  return out.join('');\n};\nmodule.exports.toHexString = bytes => {\n  return Array.from(bytes, byte => {\n    return ('0' + (byte & 0xff).toString(16)).slice(-2);\n  }).join('');\n};\nmodule.exports.escapeId = (opts, info, value) => {\n  if (!value || value === '') {\n    throw Errors.createError('Cannot escape empty ID value', Errors.ER_NULL_ESCAPEID, info, '0A000');\n  }\n  if (value.includes('\\u0000')) {\n    throw Errors.createError('Cannot escape ID with null character (u0000)', Errors.ER_NULL_CHAR_ESCAPEID, info, '0A000');\n  }\n\n  // always return escaped value, even when there is no special characters\n  // to permit working with reserved words\n  return '`' + value.replace(/`/g, '``') + '`';\n};\nconst escapeParameters = (opts, info, value) => {\n  if (value === undefined || value === null) return 'NULL';\n  switch (typeof value) {\n    case 'boolean':\n      return value ? 'true' : 'false';\n    case 'bigint':\n    case 'number':\n      return '' + value;\n    case 'object':\n      if (value instanceof Date) {\n        return TextEncoder.getFixedFormatDate(value);\n      } else if (Buffer.isBuffer(value)) {\n        let stValue;\n        if (Buffer.isEncoding(info.collation.charset)) {\n          stValue = value.toString(info.collation.charset, 0, value.length);\n        } else {\n          stValue = Iconv.decode(value, info.collation.charset);\n        }\n        return \"_binary'\" + escapeString(stValue) + \"'\";\n      } else if (typeof value.toSqlString === 'function') {\n        return \"'\" + escapeString(String(value.toSqlString())) + \"'\";\n      } else if (Array.isArray(value)) {\n        let out = opts.arrayParenthesis ? '(' : '';\n        for (let i = 0; i < value.length; i++) {\n          if (i !== 0) out += ',';\n          out += escapeParameters(opts, info, value[i]);\n        }\n        if (opts.arrayParenthesis) out += ')';\n        return out;\n      } else {\n        if (value.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(value.type)) {\n          //GeoJSON format.\n          let prefix = info && (info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6)) ? 'ST_' : '';\n          switch (value.type) {\n            case 'Point':\n              return prefix + \"PointFromText('POINT(\" + TextEncoder.geoPointToString(value.coordinates) + \")')\";\n            case 'LineString':\n              return prefix + \"LineFromText('LINESTRING(\" + TextEncoder.geoArrayPointToString(value.coordinates) + \")')\";\n            case 'Polygon':\n              return prefix + \"PolygonFromText('POLYGON(\" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + \")')\";\n            case 'MultiPoint':\n              return prefix + \"MULTIPOINTFROMTEXT('MULTIPOINT(\" + TextEncoder.geoArrayPointToString(value.coordinates) + \")')\";\n            case 'MultiLineString':\n              return prefix + \"MLineFromText('MULTILINESTRING(\" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + \")')\";\n            case 'MultiPolygon':\n              return prefix + \"MPolyFromText('MULTIPOLYGON(\" + TextEncoder.geoMultiPolygonToString(value.coordinates) + \")')\";\n            case 'GeometryCollection':\n              return prefix + \"GeomCollFromText('GEOMETRYCOLLECTION(\" + TextEncoder.geometricCollectionToString(value.geometries) + \")')\";\n          }\n        } else {\n          if (opts.permitSetMultiParamEntries) {\n            let out = '';\n            let first = true;\n            for (let key in value) {\n              const val = value[key];\n              if (typeof val === 'function') continue;\n              if (first) {\n                first = false;\n              } else {\n                out += ',';\n              }\n              out += '`' + key + '`=';\n              out += this.escape(opts, info, val);\n            }\n            if (out === '') return \"'\" + escapeString(JSON.stringify(value)) + \"'\";\n            return out;\n          } else {\n            return \"'\" + escapeString(JSON.stringify(value)) + \"'\";\n          }\n        }\n      }\n    default:\n      return \"'\" + escapeString(value) + \"'\";\n  }\n};\n\n// see https://mariadb.com/kb/en/library/string-literals/\nconst LITTERAL_ESCAPE = {\n  '\\u0000': '\\\\0',\n  \"'\": \"\\\\'\",\n  '\"': '\\\\\"',\n  '\\b': '\\\\b',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\u001A': '\\\\Z',\n  '\\\\': '\\\\\\\\'\n};\nconst CHARS_GLOBAL_REGEXP = /[\\000\\032\"'\\\\\\b\\n\\r\\t]/g;\nconst escapeString = val => {\n  let offset = 0;\n  let escaped = '';\n  let match;\n  while (match = CHARS_GLOBAL_REGEXP.exec(val)) {\n    escaped += val.substring(offset, match.index);\n    escaped += LITTERAL_ESCAPE[match[0]];\n    offset = CHARS_GLOBAL_REGEXP.lastIndex;\n  }\n  if (offset === 0) {\n    return val;\n  }\n  if (offset < val.length) {\n    escaped += val.substring(offset);\n  }\n  return escaped;\n};\nmodule.exports.escape = escapeParameters;","map":{"version":3,"names":["hexArray","split","Errors","require","Iconv","TextEncoder","module","exports","log","opts","buf","off","end","header","out","undefined","length","asciiValue","Array","useHeader","offset","maxLgh","Math","min","debugLen","isLimited","byteValue","posHexa","pos","push","String","fromCharCode","join","remaining","toHexString","bytes","from","byte","toString","slice","escapeId","info","value","createError","ER_NULL_ESCAPEID","includes","ER_NULL_CHAR_ESCAPEID","replace","escapeParameters","Date","getFixedFormatDate","Buffer","isBuffer","stValue","isEncoding","collation","charset","decode","escapeString","toSqlString","isArray","arrayParenthesis","i","type","prefix","isMariaDB","hasMinVersion","geoPointToString","coordinates","geoArrayPointToString","geoMultiArrayPointToString","geoMultiPolygonToString","geometricCollectionToString","geometries","permitSetMultiParamEntries","first","key","val","escape","JSON","stringify","LITTERAL_ESCAPE","CHARS_GLOBAL_REGEXP","escaped","match","exec","substring","index","lastIndex"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/misc/utils.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\nconst hexArray = '0123456789ABCDEF'.split('');\nconst Errors = require('../misc/errors');\nconst Iconv = require('iconv-lite');\nconst TextEncoder = require('../cmd/encoder/text-encoder');\n\n/**\n * Write bytes/hexadecimal value of a byte array to a string.\n * String output example :\n * 38 00 00 00 03 63 72 65  61 74 65 20 74 61 62 6C     8....create tabl\n * 65 20 42 6C 6F 62 54 65  73 74 63 6C 6F 62 74 65     e BlobTestclobte\n * 73 74 32 20 28 73 74 72  6D 20 74 65 78 74 29 20     st2 (strm text)\n * 43 48 41 52 53 45 54 20  75 74 66 38                 CHARSET utf8\n */\nmodule.exports.log = function (opts, buf, off, end, header) {\n  let out = [];\n  if (!buf) return '';\n  if (off === undefined || off === null) off = 0;\n  if (end === undefined || end === null) end = buf.length;\n  let asciiValue = new Array(16);\n  asciiValue[8] = ' ';\n\n  let useHeader = header !== undefined;\n  let offset = off || 0;\n  const maxLgh = Math.min(useHeader ? opts.debugLen - header.length : opts.debugLen, end - offset);\n  const isLimited = end - offset > maxLgh;\n  let byteValue;\n  let posHexa = 0;\n  let pos = 0;\n\n  out.push(\n    '+--------------------------------------------------+\\n' +\n      '|  0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f |\\n' +\n      '+--------------------------------------------------+------------------+\\n'\n  );\n\n  if (useHeader) {\n    while (pos < header.length) {\n      if (posHexa === 0) out.push('| ');\n      byteValue = header[pos++] & 0xff;\n      out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 0x0f], ' ');\n      asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : '.';\n      if (posHexa === 8) out.push(' ');\n    }\n  }\n\n  pos = offset;\n  while (pos < maxLgh + offset) {\n    if (posHexa === 0) out.push('| ');\n    byteValue = buf[pos] & 0xff;\n\n    out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 0x0f], ' ');\n\n    asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : '.';\n\n    if (posHexa === 8) out.push(' ');\n    if (posHexa === 16) {\n      out.push('| ', asciiValue.join(''), ' |\\n');\n      posHexa = 0;\n    }\n    pos++;\n  }\n\n  let remaining = posHexa;\n  if (remaining > 0) {\n    if (remaining < 8) {\n      for (; remaining < 8; remaining++) {\n        out.push('   ');\n        asciiValue[posHexa++] = ' ';\n      }\n      out.push(' ');\n    }\n\n    for (; remaining < 16; remaining++) {\n      out.push('   ');\n      asciiValue[posHexa++] = ' ';\n    }\n\n    out.push('| ', asciiValue.join(''), isLimited ? ' |...\\n' : ' |\\n');\n  } else if (isLimited) {\n    out[out.length - 1] = ' |...\\n';\n  }\n  out.push('+--------------------------------------------------+------------------+\\n');\n  return out.join('');\n};\n\nmodule.exports.toHexString = (bytes) => {\n  return Array.from(bytes, (byte) => {\n    return ('0' + (byte & 0xff).toString(16)).slice(-2);\n  }).join('');\n};\n\nmodule.exports.escapeId = (opts, info, value) => {\n  if (!value || value === '') {\n    throw Errors.createError('Cannot escape empty ID value', Errors.ER_NULL_ESCAPEID, info, '0A000');\n  }\n  if (value.includes('\\u0000')) {\n    throw Errors.createError(\n      'Cannot escape ID with null character (u0000)',\n      Errors.ER_NULL_CHAR_ESCAPEID,\n      info,\n      '0A000'\n    );\n  }\n\n  // always return escaped value, even when there is no special characters\n  // to permit working with reserved words\n  return '`' + value.replace(/`/g, '``') + '`';\n};\n\nconst escapeParameters = (opts, info, value) => {\n  if (value === undefined || value === null) return 'NULL';\n\n  switch (typeof value) {\n    case 'boolean':\n      return value ? 'true' : 'false';\n    case 'bigint':\n    case 'number':\n      return '' + value;\n    case 'object':\n      if (value instanceof Date) {\n        return TextEncoder.getFixedFormatDate(value);\n      } else if (Buffer.isBuffer(value)) {\n        let stValue;\n        if (Buffer.isEncoding(info.collation.charset)) {\n          stValue = value.toString(info.collation.charset, 0, value.length);\n        } else {\n          stValue = Iconv.decode(value, info.collation.charset);\n        }\n        return \"_binary'\" + escapeString(stValue) + \"'\";\n      } else if (typeof value.toSqlString === 'function') {\n        return \"'\" + escapeString(String(value.toSqlString())) + \"'\";\n      } else if (Array.isArray(value)) {\n        let out = opts.arrayParenthesis ? '(' : '';\n        for (let i = 0; i < value.length; i++) {\n          if (i !== 0) out += ',';\n          out += escapeParameters(opts, info, value[i]);\n        }\n        if (opts.arrayParenthesis) out += ')';\n        return out;\n      } else {\n        if (\n          value.type != null &&\n          [\n            'Point',\n            'LineString',\n            'Polygon',\n            'MultiPoint',\n            'MultiLineString',\n            'MultiPolygon',\n            'GeometryCollection'\n          ].includes(value.type)\n        ) {\n          //GeoJSON format.\n          let prefix =\n            info &&\n            ((info.isMariaDB() && info.hasMinVersion(10, 1, 4)) || (!info.isMariaDB() && info.hasMinVersion(5, 7, 6)))\n              ? 'ST_'\n              : '';\n          switch (value.type) {\n            case 'Point':\n              return prefix + \"PointFromText('POINT(\" + TextEncoder.geoPointToString(value.coordinates) + \")')\";\n\n            case 'LineString':\n              return (\n                prefix + \"LineFromText('LINESTRING(\" + TextEncoder.geoArrayPointToString(value.coordinates) + \")')\"\n              );\n\n            case 'Polygon':\n              return (\n                prefix + \"PolygonFromText('POLYGON(\" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + \")')\"\n              );\n\n            case 'MultiPoint':\n              return (\n                prefix +\n                \"MULTIPOINTFROMTEXT('MULTIPOINT(\" +\n                TextEncoder.geoArrayPointToString(value.coordinates) +\n                \")')\"\n              );\n\n            case 'MultiLineString':\n              return (\n                prefix +\n                \"MLineFromText('MULTILINESTRING(\" +\n                TextEncoder.geoMultiArrayPointToString(value.coordinates) +\n                \")')\"\n              );\n\n            case 'MultiPolygon':\n              return (\n                prefix + \"MPolyFromText('MULTIPOLYGON(\" + TextEncoder.geoMultiPolygonToString(value.coordinates) + \")')\"\n              );\n\n            case 'GeometryCollection':\n              return (\n                prefix +\n                \"GeomCollFromText('GEOMETRYCOLLECTION(\" +\n                TextEncoder.geometricCollectionToString(value.geometries) +\n                \")')\"\n              );\n          }\n        } else {\n          if (opts.permitSetMultiParamEntries) {\n            let out = '';\n            let first = true;\n            for (let key in value) {\n              const val = value[key];\n              if (typeof val === 'function') continue;\n              if (first) {\n                first = false;\n              } else {\n                out += ',';\n              }\n              out += '`' + key + '`=';\n              out += this.escape(opts, info, val);\n            }\n            if (out === '') return \"'\" + escapeString(JSON.stringify(value)) + \"'\";\n            return out;\n          } else {\n            return \"'\" + escapeString(JSON.stringify(value)) + \"'\";\n          }\n        }\n      }\n    default:\n      return \"'\" + escapeString(value) + \"'\";\n  }\n};\n\n// see https://mariadb.com/kb/en/library/string-literals/\nconst LITTERAL_ESCAPE = {\n  '\\u0000': '\\\\0',\n  \"'\": \"\\\\'\",\n  '\"': '\\\\\"',\n  '\\b': '\\\\b',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\u001A': '\\\\Z',\n  '\\\\': '\\\\\\\\'\n};\n\nconst CHARS_GLOBAL_REGEXP = /[\\000\\032\"'\\\\\\b\\n\\r\\t]/g;\n\nconst escapeString = (val) => {\n  let offset = 0;\n  let escaped = '';\n  let match;\n\n  while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {\n    escaped += val.substring(offset, match.index);\n    escaped += LITTERAL_ESCAPE[match[0]];\n    offset = CHARS_GLOBAL_REGEXP.lastIndex;\n  }\n\n  if (offset === 0) {\n    return val;\n  }\n\n  if (offset < val.length) {\n    escaped += val.substring(offset);\n  }\n\n  return escaped;\n};\n\nmodule.exports.escape = escapeParameters;\n"],"mappings":"AAAA;AACA;;AAEA,YAAY;;AACZ,MAAMA,QAAQ,GAAG,kBAAkB,CAACC,KAAK,CAAC,EAAE,CAAC;AAC7C,MAAMC,MAAM,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACxC,MAAMC,KAAK,GAAGD,OAAO,CAAC,YAAY,CAAC;AACnC,MAAME,WAAW,GAAGF,OAAO,CAAC,6BAA6B,CAAC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAG,MAAM,CAACC,OAAO,CAACC,GAAG,GAAG,UAAUC,IAAI,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,MAAM,EAAE;EAC1D,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAI,CAACJ,GAAG,EAAE,OAAO,EAAE;EACnB,IAAIC,GAAG,KAAKI,SAAS,IAAIJ,GAAG,KAAK,IAAI,EAAEA,GAAG,GAAG,CAAC;EAC9C,IAAIC,GAAG,KAAKG,SAAS,IAAIH,GAAG,KAAK,IAAI,EAAEA,GAAG,GAAGF,GAAG,CAACM,MAAM;EACvD,IAAIC,UAAU,GAAG,IAAIC,KAAK,CAAC,EAAE,CAAC;EAC9BD,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG;EAEnB,IAAIE,SAAS,GAAGN,MAAM,KAAKE,SAAS;EACpC,IAAIK,MAAM,GAAGT,GAAG,IAAI,CAAC;EACrB,MAAMU,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACJ,SAAS,GAAGV,IAAI,CAACe,QAAQ,GAAGX,MAAM,CAACG,MAAM,GAAGP,IAAI,CAACe,QAAQ,EAAEZ,GAAG,GAAGQ,MAAM,CAAC;EAChG,MAAMK,SAAS,GAAGb,GAAG,GAAGQ,MAAM,GAAGC,MAAM;EACvC,IAAIK,SAAS;EACb,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,GAAG,GAAG,CAAC;EAEXd,GAAG,CAACe,IAAI,CACN,wDAAwD,GACtD,wDAAwD,GACxD,2EACJ,CAAC;EAED,IAAIV,SAAS,EAAE;IACb,OAAOS,GAAG,GAAGf,MAAM,CAACG,MAAM,EAAE;MAC1B,IAAIW,OAAO,KAAK,CAAC,EAAEb,GAAG,CAACe,IAAI,CAAC,IAAI,CAAC;MACjCH,SAAS,GAAGb,MAAM,CAACe,GAAG,EAAE,CAAC,GAAG,IAAI;MAChCd,GAAG,CAACe,IAAI,CAAC7B,QAAQ,CAAC0B,SAAS,KAAK,CAAC,CAAC,EAAE1B,QAAQ,CAAC0B,SAAS,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC;MACpET,UAAU,CAACU,OAAO,EAAE,CAAC,GAAGD,SAAS,GAAG,EAAE,IAAIA,SAAS,GAAG,GAAG,GAAGI,MAAM,CAACC,YAAY,CAACL,SAAS,CAAC,GAAG,GAAG;MAChG,IAAIC,OAAO,KAAK,CAAC,EAAEb,GAAG,CAACe,IAAI,CAAC,GAAG,CAAC;IAClC;EACF;EAEAD,GAAG,GAAGR,MAAM;EACZ,OAAOQ,GAAG,GAAGP,MAAM,GAAGD,MAAM,EAAE;IAC5B,IAAIO,OAAO,KAAK,CAAC,EAAEb,GAAG,CAACe,IAAI,CAAC,IAAI,CAAC;IACjCH,SAAS,GAAGhB,GAAG,CAACkB,GAAG,CAAC,GAAG,IAAI;IAE3Bd,GAAG,CAACe,IAAI,CAAC7B,QAAQ,CAAC0B,SAAS,KAAK,CAAC,CAAC,EAAE1B,QAAQ,CAAC0B,SAAS,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC;IAEpET,UAAU,CAACU,OAAO,EAAE,CAAC,GAAGD,SAAS,GAAG,EAAE,IAAIA,SAAS,GAAG,GAAG,GAAGI,MAAM,CAACC,YAAY,CAACL,SAAS,CAAC,GAAG,GAAG;IAEhG,IAAIC,OAAO,KAAK,CAAC,EAAEb,GAAG,CAACe,IAAI,CAAC,GAAG,CAAC;IAChC,IAAIF,OAAO,KAAK,EAAE,EAAE;MAClBb,GAAG,CAACe,IAAI,CAAC,IAAI,EAAEZ,UAAU,CAACe,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC;MAC3CL,OAAO,GAAG,CAAC;IACb;IACAC,GAAG,EAAE;EACP;EAEA,IAAIK,SAAS,GAAGN,OAAO;EACvB,IAAIM,SAAS,GAAG,CAAC,EAAE;IACjB,IAAIA,SAAS,GAAG,CAAC,EAAE;MACjB,OAAOA,SAAS,GAAG,CAAC,EAAEA,SAAS,EAAE,EAAE;QACjCnB,GAAG,CAACe,IAAI,CAAC,KAAK,CAAC;QACfZ,UAAU,CAACU,OAAO,EAAE,CAAC,GAAG,GAAG;MAC7B;MACAb,GAAG,CAACe,IAAI,CAAC,GAAG,CAAC;IACf;IAEA,OAAOI,SAAS,GAAG,EAAE,EAAEA,SAAS,EAAE,EAAE;MAClCnB,GAAG,CAACe,IAAI,CAAC,KAAK,CAAC;MACfZ,UAAU,CAACU,OAAO,EAAE,CAAC,GAAG,GAAG;IAC7B;IAEAb,GAAG,CAACe,IAAI,CAAC,IAAI,EAAEZ,UAAU,CAACe,IAAI,CAAC,EAAE,CAAC,EAAEP,SAAS,GAAG,SAAS,GAAG,MAAM,CAAC;EACrE,CAAC,MAAM,IAAIA,SAAS,EAAE;IACpBX,GAAG,CAACA,GAAG,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG,SAAS;EACjC;EACAF,GAAG,CAACe,IAAI,CAAC,2EAA2E,CAAC;EACrF,OAAOf,GAAG,CAACkB,IAAI,CAAC,EAAE,CAAC;AACrB,CAAC;AAED1B,MAAM,CAACC,OAAO,CAAC2B,WAAW,GAAIC,KAAK,IAAK;EACtC,OAAOjB,KAAK,CAACkB,IAAI,CAACD,KAAK,EAAGE,IAAI,IAAK;IACjC,OAAO,CAAC,GAAG,GAAG,CAACA,IAAI,GAAG,IAAI,EAAEC,QAAQ,CAAC,EAAE,CAAC,EAAEC,KAAK,CAAC,CAAC,CAAC,CAAC;EACrD,CAAC,CAAC,CAACP,IAAI,CAAC,EAAE,CAAC;AACb,CAAC;AAED1B,MAAM,CAACC,OAAO,CAACiC,QAAQ,GAAG,CAAC/B,IAAI,EAAEgC,IAAI,EAAEC,KAAK,KAAK;EAC/C,IAAI,CAACA,KAAK,IAAIA,KAAK,KAAK,EAAE,EAAE;IAC1B,MAAMxC,MAAM,CAACyC,WAAW,CAAC,8BAA8B,EAAEzC,MAAM,CAAC0C,gBAAgB,EAAEH,IAAI,EAAE,OAAO,CAAC;EAClG;EACA,IAAIC,KAAK,CAACG,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAC5B,MAAM3C,MAAM,CAACyC,WAAW,CACtB,8CAA8C,EAC9CzC,MAAM,CAAC4C,qBAAqB,EAC5BL,IAAI,EACJ,OACF,CAAC;EACH;;EAEA;EACA;EACA,OAAO,GAAG,GAAGC,KAAK,CAACK,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,GAAG;AAC9C,CAAC;AAED,MAAMC,gBAAgB,GAAGA,CAACvC,IAAI,EAAEgC,IAAI,EAAEC,KAAK,KAAK;EAC9C,IAAIA,KAAK,KAAK3B,SAAS,IAAI2B,KAAK,KAAK,IAAI,EAAE,OAAO,MAAM;EAExD,QAAQ,OAAOA,KAAK;IAClB,KAAK,SAAS;MACZ,OAAOA,KAAK,GAAG,MAAM,GAAG,OAAO;IACjC,KAAK,QAAQ;IACb,KAAK,QAAQ;MACX,OAAO,EAAE,GAAGA,KAAK;IACnB,KAAK,QAAQ;MACX,IAAIA,KAAK,YAAYO,IAAI,EAAE;QACzB,OAAO5C,WAAW,CAAC6C,kBAAkB,CAACR,KAAK,CAAC;MAC9C,CAAC,MAAM,IAAIS,MAAM,CAACC,QAAQ,CAACV,KAAK,CAAC,EAAE;QACjC,IAAIW,OAAO;QACX,IAAIF,MAAM,CAACG,UAAU,CAACb,IAAI,CAACc,SAAS,CAACC,OAAO,CAAC,EAAE;UAC7CH,OAAO,GAAGX,KAAK,CAACJ,QAAQ,CAACG,IAAI,CAACc,SAAS,CAACC,OAAO,EAAE,CAAC,EAAEd,KAAK,CAAC1B,MAAM,CAAC;QACnE,CAAC,MAAM;UACLqC,OAAO,GAAGjD,KAAK,CAACqD,MAAM,CAACf,KAAK,EAAED,IAAI,CAACc,SAAS,CAACC,OAAO,CAAC;QACvD;QACA,OAAO,UAAU,GAAGE,YAAY,CAACL,OAAO,CAAC,GAAG,GAAG;MACjD,CAAC,MAAM,IAAI,OAAOX,KAAK,CAACiB,WAAW,KAAK,UAAU,EAAE;QAClD,OAAO,GAAG,GAAGD,YAAY,CAAC5B,MAAM,CAACY,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;MAC9D,CAAC,MAAM,IAAIzC,KAAK,CAAC0C,OAAO,CAAClB,KAAK,CAAC,EAAE;QAC/B,IAAI5B,GAAG,GAAGL,IAAI,CAACoD,gBAAgB,GAAG,GAAG,GAAG,EAAE;QAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,KAAK,CAAC1B,MAAM,EAAE8C,CAAC,EAAE,EAAE;UACrC,IAAIA,CAAC,KAAK,CAAC,EAAEhD,GAAG,IAAI,GAAG;UACvBA,GAAG,IAAIkC,gBAAgB,CAACvC,IAAI,EAAEgC,IAAI,EAAEC,KAAK,CAACoB,CAAC,CAAC,CAAC;QAC/C;QACA,IAAIrD,IAAI,CAACoD,gBAAgB,EAAE/C,GAAG,IAAI,GAAG;QACrC,OAAOA,GAAG;MACZ,CAAC,MAAM;QACL,IACE4B,KAAK,CAACqB,IAAI,IAAI,IAAI,IAClB,CACE,OAAO,EACP,YAAY,EACZ,SAAS,EACT,YAAY,EACZ,iBAAiB,EACjB,cAAc,EACd,oBAAoB,CACrB,CAAClB,QAAQ,CAACH,KAAK,CAACqB,IAAI,CAAC,EACtB;UACA;UACA,IAAIC,MAAM,GACRvB,IAAI,KACFA,IAAI,CAACwB,SAAS,CAAC,CAAC,IAAIxB,IAAI,CAACyB,aAAa,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,IAAM,CAACzB,IAAI,CAACwB,SAAS,CAAC,CAAC,IAAIxB,IAAI,CAACyB,aAAa,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAC,GACtG,KAAK,GACL,EAAE;UACR,QAAQxB,KAAK,CAACqB,IAAI;YAChB,KAAK,OAAO;cACV,OAAOC,MAAM,GAAG,uBAAuB,GAAG3D,WAAW,CAAC8D,gBAAgB,CAACzB,KAAK,CAAC0B,WAAW,CAAC,GAAG,KAAK;YAEnG,KAAK,YAAY;cACf,OACEJ,MAAM,GAAG,2BAA2B,GAAG3D,WAAW,CAACgE,qBAAqB,CAAC3B,KAAK,CAAC0B,WAAW,CAAC,GAAG,KAAK;YAGvG,KAAK,SAAS;cACZ,OACEJ,MAAM,GAAG,2BAA2B,GAAG3D,WAAW,CAACiE,0BAA0B,CAAC5B,KAAK,CAAC0B,WAAW,CAAC,GAAG,KAAK;YAG5G,KAAK,YAAY;cACf,OACEJ,MAAM,GACN,iCAAiC,GACjC3D,WAAW,CAACgE,qBAAqB,CAAC3B,KAAK,CAAC0B,WAAW,CAAC,GACpD,KAAK;YAGT,KAAK,iBAAiB;cACpB,OACEJ,MAAM,GACN,iCAAiC,GACjC3D,WAAW,CAACiE,0BAA0B,CAAC5B,KAAK,CAAC0B,WAAW,CAAC,GACzD,KAAK;YAGT,KAAK,cAAc;cACjB,OACEJ,MAAM,GAAG,8BAA8B,GAAG3D,WAAW,CAACkE,uBAAuB,CAAC7B,KAAK,CAAC0B,WAAW,CAAC,GAAG,KAAK;YAG5G,KAAK,oBAAoB;cACvB,OACEJ,MAAM,GACN,uCAAuC,GACvC3D,WAAW,CAACmE,2BAA2B,CAAC9B,KAAK,CAAC+B,UAAU,CAAC,GACzD,KAAK;UAEX;QACF,CAAC,MAAM;UACL,IAAIhE,IAAI,CAACiE,0BAA0B,EAAE;YACnC,IAAI5D,GAAG,GAAG,EAAE;YACZ,IAAI6D,KAAK,GAAG,IAAI;YAChB,KAAK,IAAIC,GAAG,IAAIlC,KAAK,EAAE;cACrB,MAAMmC,GAAG,GAAGnC,KAAK,CAACkC,GAAG,CAAC;cACtB,IAAI,OAAOC,GAAG,KAAK,UAAU,EAAE;cAC/B,IAAIF,KAAK,EAAE;gBACTA,KAAK,GAAG,KAAK;cACf,CAAC,MAAM;gBACL7D,GAAG,IAAI,GAAG;cACZ;cACAA,GAAG,IAAI,GAAG,GAAG8D,GAAG,GAAG,IAAI;cACvB9D,GAAG,IAAI,IAAI,CAACgE,MAAM,CAACrE,IAAI,EAAEgC,IAAI,EAAEoC,GAAG,CAAC;YACrC;YACA,IAAI/D,GAAG,KAAK,EAAE,EAAE,OAAO,GAAG,GAAG4C,YAAY,CAACqB,IAAI,CAACC,SAAS,CAACtC,KAAK,CAAC,CAAC,GAAG,GAAG;YACtE,OAAO5B,GAAG;UACZ,CAAC,MAAM;YACL,OAAO,GAAG,GAAG4C,YAAY,CAACqB,IAAI,CAACC,SAAS,CAACtC,KAAK,CAAC,CAAC,GAAG,GAAG;UACxD;QACF;MACF;IACF;MACE,OAAO,GAAG,GAAGgB,YAAY,CAAChB,KAAK,CAAC,GAAG,GAAG;EAC1C;AACF,CAAC;;AAED;AACA,MAAMuC,eAAe,GAAG;EACtB,QAAQ,EAAE,KAAK;EACf,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,QAAQ,EAAE,KAAK;EACf,IAAI,EAAE;AACR,CAAC;AAED,MAAMC,mBAAmB,GAAG,yBAAyB;AAErD,MAAMxB,YAAY,GAAImB,GAAG,IAAK;EAC5B,IAAIzD,MAAM,GAAG,CAAC;EACd,IAAI+D,OAAO,GAAG,EAAE;EAChB,IAAIC,KAAK;EAET,OAAQA,KAAK,GAAGF,mBAAmB,CAACG,IAAI,CAACR,GAAG,CAAC,EAAG;IAC9CM,OAAO,IAAIN,GAAG,CAACS,SAAS,CAAClE,MAAM,EAAEgE,KAAK,CAACG,KAAK,CAAC;IAC7CJ,OAAO,IAAIF,eAAe,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;IACpChE,MAAM,GAAG8D,mBAAmB,CAACM,SAAS;EACxC;EAEA,IAAIpE,MAAM,KAAK,CAAC,EAAE;IAChB,OAAOyD,GAAG;EACZ;EAEA,IAAIzD,MAAM,GAAGyD,GAAG,CAAC7D,MAAM,EAAE;IACvBmE,OAAO,IAAIN,GAAG,CAACS,SAAS,CAAClE,MAAM,CAAC;EAClC;EAEA,OAAO+D,OAAO;AAChB,CAAC;AAED7E,MAAM,CAACC,OAAO,CAACuE,MAAM,GAAG9B,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
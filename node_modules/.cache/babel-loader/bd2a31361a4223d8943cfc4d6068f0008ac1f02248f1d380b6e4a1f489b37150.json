{"ast":null,"code":"//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst ClusterOptions = require('./config/cluster-options');\nconst PoolOptions = require('./config/pool-options');\nconst PoolCallback = require('./pool-callback');\nconst PoolPromise = require('./pool-promise');\nconst FilteredCluster = require('./filtered-cluster');\nconst EventEmitter = require('events');\n\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round-robin / random / ordered )\n *\n * @param args      cluster arguments. see pool-cluster-options.\n * @constructor\n */\nclass Cluster extends EventEmitter {\n  #opts;\n  #nodes = {};\n  #cachedPatterns = {};\n  #nodeCounter = 0;\n  constructor(args) {\n    super();\n    this.#opts = new ClusterOptions(args);\n  }\n\n  /**\n   * Add a new pool node to cluster.\n   *\n   * @param id      identifier\n   * @param config  pool configuration\n   */\n  add(id, config) {\n    let identifier;\n    if (typeof id === 'string' || id instanceof String) {\n      identifier = id;\n      if (this.#nodes[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);\n    } else {\n      identifier = 'PoolNode-' + this.#nodeCounter++;\n      config = id;\n    }\n    const options = new PoolOptions(config);\n    this.#nodes[identifier] = this._createPool(options);\n  }\n\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @return {Promise<any[]>}\n   */\n  end() {\n    const cluster = this;\n    this.#cachedPatterns = {};\n    const poolEndPromise = [];\n    Object.keys(this.#nodes).forEach(pool => {\n      const res = cluster.#nodes[pool].end();\n      if (res) poolEndPromise.push(res);\n    });\n    this.#nodes = null;\n    return Promise.all(poolEndPromise);\n  }\n  of(pattern, selector) {\n    return new FilteredCluster(this, pattern, selector);\n  }\n\n  /**\n   * Remove nodes according to pattern.\n   *\n   * @param pattern  pattern\n   */\n  remove(pattern) {\n    if (!pattern) throw new Error('pattern parameter in Cluster.remove(pattern)  is mandatory');\n    const regex = RegExp(pattern);\n    Object.keys(this.#nodes).forEach(function (key) {\n      if (regex.test(key)) {\n        this.#nodes[key].end();\n        delete this.#nodes[key];\n        this.#cachedPatterns = {};\n      }\n    }.bind(this));\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @return {Promise}\n   */\n  getConnection(pattern, selector) {\n    return this._getConnection(pattern, selector, undefined, undefined, undefined);\n  }\n\n  /**\n   * Force using callback methods.\n   */\n  _setCallback() {\n    this.getConnection = this._getConnectionCallback;\n    this._createPool = this._createPoolCallback;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @param remainingRetry remaining possible retry\n   * @return {Promise}\n   * @private\n   */\n  _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        return Promise.reject(new Error('No node have been added to cluster or nodes have been removed due to too much connection error'));\n      }\n      if (avoidNodeKey === undefined) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${lastError ? '. Last connection error was: ' + lastError.message : ''}`;\n      return Promise.reject(new Error(errMsg));\n    }\n    if (remainingRetry === undefined) remainingRetry = matchingNodeList.length;\n    const retry = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      return this._handleConnectionError(matchingNodeList, nodeKey, retry);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _createPool(options) {\n    const pool = new PoolPromise(options);\n    pool.on('error', err => {});\n    return pool;\n  }\n  _createPoolCallback(options) {\n    const pool = new PoolCallback(options);\n    pool.on('error', err => {});\n    return pool;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @private\n   */\n  _getConnectionCallback(pattern, selector, callback, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        callback(new Error('No node have been added to cluster or nodes have been removed due to too much connection error'));\n        return;\n      }\n      if (avoidNodeKey === undefined) callback(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${lastError ? '. Last connection error was: ' + lastError.message : ''}`;\n      callback(new Error(errMsg));\n      return;\n    }\n    const retry = this._getConnectionCallback.bind(this, pattern, selector, callback);\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry, callback);\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  /**\n   * Selecting nodes according to pattern.\n   *\n   * @param pattern pattern\n   * @return {*}\n   * @private\n   */\n  _matchingNodes(pattern) {\n    if (this.#cachedPatterns[pattern]) return this.#cachedPatterns[pattern];\n    const regex = RegExp(pattern);\n    const matchingNodeList = [];\n    Object.keys(this.#nodes).forEach(key => {\n      if (regex.test(key)) {\n        matchingNodeList.push(key);\n      }\n    });\n    this.#cachedPatterns[pattern] = matchingNodeList;\n    return matchingNodeList;\n  }\n\n  /**\n   * Select next node to be chosen in nodeList according to selector and failed nodes.\n   *\n   * @param nodeList        current node list\n   * @param selectorParam   selector\n   * @param avoidNodeKey    last failing node to avoid selecting this one.\n   * @return {Promise}\n   * @private\n   */\n  _selectPool(nodeList, selectorParam, avoidNodeKey) {\n    const selector = selectorParam || this.#opts.defaultSelector;\n    let selectorFct;\n    switch (selector) {\n      case 'RR':\n        selectorFct = roundRobinSelector;\n        break;\n      case 'RANDOM':\n        selectorFct = randomSelector;\n        break;\n      case 'ORDER':\n        selectorFct = orderedSelector;\n        break;\n      default:\n        throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);\n    }\n    let nodeIdx = 0;\n    let nodeKey = selectorFct(nodeList, nodeIdx);\n    // first loop : search for node not blacklisted AND not the avoided key\n    while ((avoidNodeKey === nodeKey || this.#nodes[nodeKey].blacklistedUntil && this.#nodes[nodeKey].blacklistedUntil > Date.now()) && nodeIdx < nodeList.length - 1) {\n      nodeIdx++;\n      nodeKey = selectorFct(nodeList, nodeIdx);\n    }\n    if (avoidNodeKey === nodeKey) {\n      // second loop, search even in blacklisted node in order to choose a different node than to be avoided\n      nodeIdx = 0;\n      while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {\n        nodeIdx++;\n        nodeKey = selectorFct(nodeList, nodeIdx);\n      }\n    }\n    return nodeKey;\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @return {Promise}\n   * @private\n   */\n  _handleConnectionError(nodeList, nodeKey, retryFct) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    return node.getConnection().then(conn => {\n      node.blacklistedUntil = null;\n      node.errorCount = 0;\n      return Promise.resolve(conn);\n    }).catch(err => {\n      node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n      node.blacklistedUntil = Date.now() + cluster.#opts.restoreNodeTimeout;\n      if (cluster.#opts.removeNodeErrorCount && node.errorCount >= cluster.#opts.removeNodeErrorCount && cluster.#nodes[nodeKey]) {\n        delete cluster.#nodes[nodeKey];\n        cluster.#cachedPatterns = {};\n        delete nodeList.lastRrIdx;\n        setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n        //remove node from configuration if not already removed\n        node.end().catch(err => {\n          // dismiss error\n        });\n      }\n      if (nodeList.length !== 0 && cluster.#opts.canRetry && retryFct) {\n        return retryFct(nodeKey, err);\n      }\n      return Promise.reject(err);\n    });\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @param callback    callback function\n   * @private\n   */\n  _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    node.getConnection((err, conn) => {\n      if (err) {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + cluster.#opts.restoreNodeTimeout;\n        if (cluster.#opts.removeNodeErrorCount && node.errorCount >= cluster.#opts.removeNodeErrorCount && cluster.#nodes[nodeKey]) {\n          delete cluster.#nodes[nodeKey];\n          cluster.#cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n          //remove node from configuration if not already removed\n          node.end(() => {\n            //dismiss error\n          });\n        }\n        if (nodeList.length !== 0 && cluster.#opts.canRetry && retryFct) {\n          return retryFct(nodeKey, err);\n        }\n        callback(err);\n      } else {\n        node.errorCount = 0;\n        callback(null, conn);\n      }\n    });\n  }\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  get __tests() {\n    return new TestMethods(this.#nodes);\n  }\n}\nclass TestMethods {\n  #nodes;\n  constructor(nodes) {\n    this.#nodes = nodes;\n  }\n  getNodes() {\n    return this.#nodes;\n  }\n}\n\n/**\n * Round robin selector: using nodes one after the other.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst roundRobinSelector = nodeList => {\n  let lastRoundRobin = nodeList.lastRrIdx;\n  if (lastRoundRobin === undefined) lastRoundRobin = -1;\n  if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;\n  nodeList.lastRrIdx = lastRoundRobin;\n  return nodeList[lastRoundRobin];\n};\n\n/**\n * Random selector: use a random node.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst randomSelector = nodeList => {\n  let randomIdx = Math.floor(Math.random() * nodeList.length);\n  return nodeList[randomIdx];\n};\n\n/**\n * Ordered selector: always use the nodes in sequence, unless failing.\n *\n * @param nodeList  node list\n * @param retry     sequence number if last node is tagged has failing\n * @return {String}\n */\nconst orderedSelector = (nodeList, retry) => {\n  return nodeList[retry];\n};\nmodule.exports = Cluster;","map":{"version":3,"names":["ClusterOptions","require","PoolOptions","PoolCallback","PoolPromise","FilteredCluster","EventEmitter","Cluster","opts","nodes","cachedPatterns","nodeCounter","constructor","args","add","id","config","identifier","String","Error","options","_createPool","end","cluster","poolEndPromise","Object","keys","forEach","pool","res","push","Promise","all","of","pattern","selector","remove","regex","RegExp","key","test","bind","getConnection","_getConnection","undefined","_setCallback","_getConnectionCallback","_createPoolCallback","remainingRetry","avoidNodeKey","lastError","matchingNodeList","_matchingNodes","length","reject","errMsg","message","retry","nodeKey","_selectPool","_handleConnectionError","e","on","err","callback","_handleConnectionCallbackError","nodeList","selectorParam","defaultSelector","selectorFct","roundRobinSelector","randomSelector","orderedSelector","nodeIdx","blacklistedUntil","Date","now","retryFct","node","then","conn","errorCount","resolve","catch","restoreNodeTimeout","removeNodeErrorCount","lastRrIdx","setImmediate","emit","canRetry","__tests","TestMethods","getNodes","lastRoundRobin","randomIdx","Math","floor","random","module","exports"],"sources":["D:/Ale lui Vlad/Projects/SpotiForums/spotiforums/node_modules/mariadb/lib/cluster.js"],"sourcesContent":["//  SPDX-License-Identifier: LGPL-2.1-or-later\n//  Copyright (c) 2015-2024 MariaDB Corporation Ab\n\n'use strict';\n\nconst ClusterOptions = require('./config/cluster-options');\nconst PoolOptions = require('./config/pool-options');\nconst PoolCallback = require('./pool-callback');\nconst PoolPromise = require('./pool-promise');\nconst FilteredCluster = require('./filtered-cluster');\nconst EventEmitter = require('events');\n\n/**\n * Create a new Cluster.\n * Cluster handle pools with patterns and handle failover / distributed load\n * according to selectors (round-robin / random / ordered )\n *\n * @param args      cluster arguments. see pool-cluster-options.\n * @constructor\n */\nclass Cluster extends EventEmitter {\n  #opts;\n  #nodes = {};\n  #cachedPatterns = {};\n  #nodeCounter = 0;\n\n  constructor(args) {\n    super();\n    this.#opts = new ClusterOptions(args);\n  }\n\n  /**\n   * Add a new pool node to cluster.\n   *\n   * @param id      identifier\n   * @param config  pool configuration\n   */\n  add(id, config) {\n    let identifier;\n    if (typeof id === 'string' || id instanceof String) {\n      identifier = id;\n      if (this.#nodes[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);\n    } else {\n      identifier = 'PoolNode-' + this.#nodeCounter++;\n      config = id;\n    }\n    const options = new PoolOptions(config);\n    this.#nodes[identifier] = this._createPool(options);\n  }\n\n  /**\n   * End cluster (and underlying pools).\n   *\n   * @return {Promise<any[]>}\n   */\n  end() {\n    const cluster = this;\n    this.#cachedPatterns = {};\n    const poolEndPromise = [];\n    Object.keys(this.#nodes).forEach((pool) => {\n      const res = cluster.#nodes[pool].end();\n      if (res) poolEndPromise.push(res);\n    });\n    this.#nodes = null;\n    return Promise.all(poolEndPromise);\n  }\n\n  of(pattern, selector) {\n    return new FilteredCluster(this, pattern, selector);\n  }\n\n  /**\n   * Remove nodes according to pattern.\n   *\n   * @param pattern  pattern\n   */\n  remove(pattern) {\n    if (!pattern) throw new Error('pattern parameter in Cluster.remove(pattern)  is mandatory');\n\n    const regex = RegExp(pattern);\n    Object.keys(this.#nodes).forEach(\n      function (key) {\n        if (regex.test(key)) {\n          this.#nodes[key].end();\n          delete this.#nodes[key];\n          this.#cachedPatterns = {};\n        }\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @return {Promise}\n   */\n  getConnection(pattern, selector) {\n    return this._getConnection(pattern, selector, undefined, undefined, undefined);\n  }\n\n  /**\n   * Force using callback methods.\n   */\n  _setCallback() {\n    this.getConnection = this._getConnectionCallback;\n    this._createPool = this._createPoolCallback;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @param remainingRetry remaining possible retry\n   * @return {Promise}\n   * @private\n   */\n  _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        return Promise.reject(\n          new Error('No node have been added to cluster or nodes have been removed due to too much connection error')\n        );\n      }\n      if (avoidNodeKey === undefined) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${\n        lastError ? '. Last connection error was: ' + lastError.message : ''\n      }`;\n      return Promise.reject(new Error(errMsg));\n    }\n\n    if (remainingRetry === undefined) remainingRetry = matchingNodeList.length;\n    const retry = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;\n\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      return this._handleConnectionError(matchingNodeList, nodeKey, retry);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  _createPool(options) {\n    const pool = new PoolPromise(options);\n    pool.on('error', (err) => {});\n    return pool;\n  }\n\n  _createPoolCallback(options) {\n    const pool = new PoolCallback(options);\n    pool.on('error', (err) => {});\n    return pool;\n  }\n\n  /**\n   * Get connection from available pools matching pattern, according to selector\n   * with additional parameter to avoid reusing failing node\n   *\n   * @param pattern       pattern filter (not mandatory)\n   * @param selector      node selector ('RR','RANDOM' or 'ORDER')\n   * @param callback      callback function\n   * @param avoidNodeKey  failing node\n   * @param lastError     last error\n   * @private\n   */\n  _getConnectionCallback(pattern, selector, callback, avoidNodeKey, lastError) {\n    const matchingNodeList = this._matchingNodes(pattern || /^/);\n\n    if (matchingNodeList.length === 0) {\n      if (Object.keys(this.#nodes).length === 0 && !lastError) {\n        callback(\n          new Error('No node have been added to cluster or nodes have been removed due to too much connection error')\n        );\n        return;\n      }\n\n      if (avoidNodeKey === undefined) callback(new Error(`No node found for pattern '${pattern}'`));\n      const errMsg = `No Connection available for '${pattern}'${\n        lastError ? '. Last connection error was: ' + lastError.message : ''\n      }`;\n      callback(new Error(errMsg));\n      return;\n    }\n\n    const retry = this._getConnectionCallback.bind(this, pattern, selector, callback);\n    try {\n      const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);\n      this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry, callback);\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  /**\n   * Selecting nodes according to pattern.\n   *\n   * @param pattern pattern\n   * @return {*}\n   * @private\n   */\n  _matchingNodes(pattern) {\n    if (this.#cachedPatterns[pattern]) return this.#cachedPatterns[pattern];\n\n    const regex = RegExp(pattern);\n    const matchingNodeList = [];\n    Object.keys(this.#nodes).forEach((key) => {\n      if (regex.test(key)) {\n        matchingNodeList.push(key);\n      }\n    });\n\n    this.#cachedPatterns[pattern] = matchingNodeList;\n    return matchingNodeList;\n  }\n\n  /**\n   * Select next node to be chosen in nodeList according to selector and failed nodes.\n   *\n   * @param nodeList        current node list\n   * @param selectorParam   selector\n   * @param avoidNodeKey    last failing node to avoid selecting this one.\n   * @return {Promise}\n   * @private\n   */\n  _selectPool(nodeList, selectorParam, avoidNodeKey) {\n    const selector = selectorParam || this.#opts.defaultSelector;\n\n    let selectorFct;\n    switch (selector) {\n      case 'RR':\n        selectorFct = roundRobinSelector;\n        break;\n\n      case 'RANDOM':\n        selectorFct = randomSelector;\n        break;\n\n      case 'ORDER':\n        selectorFct = orderedSelector;\n        break;\n\n      default:\n        throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);\n    }\n\n    let nodeIdx = 0;\n    let nodeKey = selectorFct(nodeList, nodeIdx);\n    // first loop : search for node not blacklisted AND not the avoided key\n    while (\n      (avoidNodeKey === nodeKey ||\n        (this.#nodes[nodeKey].blacklistedUntil && this.#nodes[nodeKey].blacklistedUntil > Date.now())) &&\n      nodeIdx < nodeList.length - 1\n    ) {\n      nodeIdx++;\n      nodeKey = selectorFct(nodeList, nodeIdx);\n    }\n\n    if (avoidNodeKey === nodeKey) {\n      // second loop, search even in blacklisted node in order to choose a different node than to be avoided\n      nodeIdx = 0;\n      while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {\n        nodeIdx++;\n        nodeKey = selectorFct(nodeList, nodeIdx);\n      }\n    }\n\n    return nodeKey;\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @return {Promise}\n   * @private\n   */\n  _handleConnectionError(nodeList, nodeKey, retryFct) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    return node\n      .getConnection()\n      .then((conn) => {\n        node.blacklistedUntil = null;\n        node.errorCount = 0;\n        return Promise.resolve(conn);\n      })\n      .catch((err) => {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + cluster.#opts.restoreNodeTimeout;\n        if (\n          cluster.#opts.removeNodeErrorCount &&\n          node.errorCount >= cluster.#opts.removeNodeErrorCount &&\n          cluster.#nodes[nodeKey]\n        ) {\n          delete cluster.#nodes[nodeKey];\n          cluster.#cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n          //remove node from configuration if not already removed\n          node.end().catch((err) => {\n            // dismiss error\n          });\n        }\n\n        if (nodeList.length !== 0 && cluster.#opts.canRetry && retryFct) {\n          return retryFct(nodeKey, err);\n        }\n        return Promise.reject(err);\n      });\n  }\n\n  /**\n   * Connect, or if fail handle retry / set timeout error\n   *\n   * @param nodeList    current node list\n   * @param nodeKey     node name to connect\n   * @param retryFct    retry function\n   * @param callback    callback function\n   * @private\n   */\n  _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {\n    const cluster = this;\n    const node = this.#nodes[nodeKey];\n    node.getConnection((err, conn) => {\n      if (err) {\n        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;\n        node.blacklistedUntil = Date.now() + cluster.#opts.restoreNodeTimeout;\n        if (\n          cluster.#opts.removeNodeErrorCount &&\n          node.errorCount >= cluster.#opts.removeNodeErrorCount &&\n          cluster.#nodes[nodeKey]\n        ) {\n          delete cluster.#nodes[nodeKey];\n          cluster.#cachedPatterns = {};\n          delete nodeList.lastRrIdx;\n          setImmediate(cluster.emit.bind(cluster, 'remove', nodeKey));\n\n          //remove node from configuration if not already removed\n          node.end(() => {\n            //dismiss error\n          });\n        }\n\n        if (nodeList.length !== 0 && cluster.#opts.canRetry && retryFct) {\n          return retryFct(nodeKey, err);\n        }\n\n        callback(err);\n      } else {\n        node.errorCount = 0;\n        callback(null, conn);\n      }\n    });\n  }\n\n  //*****************************************************************\n  // internal public testing methods\n  //*****************************************************************\n\n  get __tests() {\n    return new TestMethods(this.#nodes);\n  }\n}\n\nclass TestMethods {\n  #nodes;\n\n  constructor(nodes) {\n    this.#nodes = nodes;\n  }\n  getNodes() {\n    return this.#nodes;\n  }\n}\n\n/**\n * Round robin selector: using nodes one after the other.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst roundRobinSelector = (nodeList) => {\n  let lastRoundRobin = nodeList.lastRrIdx;\n  if (lastRoundRobin === undefined) lastRoundRobin = -1;\n  if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;\n  nodeList.lastRrIdx = lastRoundRobin;\n  return nodeList[lastRoundRobin];\n};\n\n/**\n * Random selector: use a random node.\n *\n * @param nodeList  node list\n * @return {String}\n */\nconst randomSelector = (nodeList) => {\n  let randomIdx = Math.floor(Math.random() * nodeList.length);\n  return nodeList[randomIdx];\n};\n\n/**\n * Ordered selector: always use the nodes in sequence, unless failing.\n *\n * @param nodeList  node list\n * @param retry     sequence number if last node is tagged has failing\n * @return {String}\n */\nconst orderedSelector = (nodeList, retry) => {\n  return nodeList[retry];\n};\n\nmodule.exports = Cluster;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}